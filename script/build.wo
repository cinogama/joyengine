import woo::std;

import pkg::fsys;
import pkg::try;
import pkg::iterator;
import pkg::regex;
import pkg::worst;

using fsys;
using iterator;

let workpath = fsys::workpath();
let third_party_located_path = workpath / "3rd";
let build_path = workpath / "build";

func copy_all_licenses()
{
    return try!
    {
        try! third_party_paths = subpath(third_party_located_path);

        for (let _3rd_path : third_party_paths->iter |> filter(\path = isdir(path);))
        {
            try! subpath_of_3rd = allsubpath(_3rd_path);
            for (let p : subpath_of_3rd)
            {
                if (isfile(p) && (
                    filename(p)->lower->find("license") != -1
                    || filename(p)->lower->find("copying") != -1))
                {
                    let relpath = p->tostring()->sub(third_party_located_path->tostring->len);

                    let target_path = build_path / "licenses" / relpath;
                    do mkdir(parent(target_path));
                    do copy(p, target_path);

                    std::println("copy license file: ", p->tostring());
                }
            }
        }
        expected_ok!;
    }
    catch! errono
    {
        return F"Failed to copy all licenses: {errono}.";
    };
}

func copy_opengles_emu_env_libs()=> result<void, string>
{
    let gles_env_path = third_party_located_path / "opengles_env_w64";
    let lib_filenames = [
        "libEGL.dll",
        "libGLESv2.dll",
        "libMaliEmulator.dll",
        "log4cplus.dll",
    ];
    do lib_filenames
        ->> \name = copy(gles_env_path / name, build_path);
        ;
    do mkdir(build_path / "openglessl");
    do copy(gles_env_path / "openglessl", build_path / "openglessl");

    expected_ok!;
}

func copy_pkgs(copy_src_only: bool)=> result<void, string>
{
    let source_path = workpath / "pkg";
    let target_path = build_path / "pkg";
    do mkdir(target_path);

    for (let path : recursive_walk(workpath / "pkg") |> iterator::iter_result)
    {
        if (isfile(path))
        {
            try! relative_path = relative(path, source_path)
                -> orbind(\eno = result::err(F"Failed to get relative path: {eno}."););

            do mkdir(parent(target_path / relative_path));

            if (copy_src_only && extension(path)->lower != ".wo")
                continue;

            do copy(path, target_path / relative_path);
        }
    }
    expected_ok!;
}

func scan_extern_function_in_path(i)
{
    let r = regex::create(@"extern\(\s*\"(.*?)\"\s*,\s*\"(.*?)\""@);
    let iter = i 
        |> filter_map(\p = isfile(p) ? readall(p) | option::none;)
        |> flat_map(\p = r->search(p);)
        |> map(\match_result = (match_result.1[1], match_result.1[2]);)
        ;

    let result = {}mut: map<string, mut map<string, mut void>>;
    for (let (libname, funcname) : iter)
    {
        if (!result->contain(libname))
            result[libname] = {}mut;

        result[libname][funcname] = do nil;
    }
    return result->>\k, v = (k, v->unmapping->>\kv = kv.0;->std::sort(\l, r = l < r;));;
}

func generate_je_api_decls()=> result<void, string>
{
    let libfuncs = scan_extern_function_in_path(
        walk(workpath / "src")->iterator::iter_result);

    let mut result = 
@"// THIS FILE IS AUTO GENERATED BY /script/build.wo

#define JE_IMPL
#define JE_ENABLE_DEBUG_API
#include "jeecs.hpp"

"@;
    for (let (_, funcs) : libfuncs)
        for (let f : funcs)
            result += F"WO_API wo_api {f}(wo_vm vm, wo_value args);\n";
    
    result += @"
void* _je_api_lib_handle = nullptr;

void je_api_init()
{
    assert(_je_api_lib_handle == nullptr);

    wo_extern_lib_func_t je_fs[] = {
"@;

   for (let (_, funcs) : libfuncs)
        for (let f : funcs)
            result += F"        wo_extern_lib_func_t\{\"{f}\", (void*)&{f}\},\n";

    result += 
@"      WO_EXTERN_LIB_FUNC_END,
    };
    _je_api_lib_handle = wo_register_lib("libjoyecs", je_fs);
}

void je_api_finish()
{
    assert(_je_api_lib_handle != nullptr);

    wo_unload_lib(_je_api_lib_handle);
    _je_api_lib_handle = nullptr;
}
"@;

    if (!writeall(workpath / "src" / "jeecs_woolang_extern_library.cpp", result))
        throw! F"Failed to update jeecs_woolang_extern_library.cpp.";
    expected_ok!;
}

func generate_je_3rd_pkg_decls()=> result<void, string>
{
    let libfuncs = scan_extern_function_in_path(
        recursive_walk(workpath / "3rd" / "pkg")->iterator::iter_result
            |> filter(\p = extension(p)->lower == ".wo";));

      let mut result = 
@"// THIS FILE IS AUTO GENERATED BY /script/build.wo

#define JE_IMPL
#define JE_ENABLE_DEBUG_API
#include "jeecs.hpp"

#if JE4_STATIC_LINK_WOOLANG_PKGS
"@;

    for (let (_, funcname) : libfuncs)
    {
        for (let f : funcname)
            result += F"WO_API wo_api {f}(wo_vm vm, wo_value args);\n";
    }

    result += @"
#endif

std::vector<void*> _je_3rd_pkg_lib_handle;
void je_3rd_pkg_init()
{
    assert(_je_3rd_pkg_lib_handle.empty()); 

#if JE4_STATIC_LINK_WOOLANG_PKGS
"@;

    for (let (libname, funcname) : libfuncs)
    {
        result += F"    wo_extern_lib_func_t {libname}_fs[] = \{\n";
        for (let f : funcname)
            result += F"        wo_extern_lib_func_t\{\"{f}\", (void*)&{f}\},\n";

        result += F"        WO_EXTERN_LIB_FUNC_END,\n    };\n";
        result += F"    _je_3rd_pkg_lib_handle.push_back(\n"
                + F"        wo_register_lib(\"{libname}\", {libname}_fs));\n\n";
    }
    
    result += @"
#endif    
}

void je_3rd_pkg_finish()
{
    for (auto* lib : _je_3rd_pkg_lib_handle)
    {
        assert(lib != nullptr);
        wo_unload_lib(lib);
    }
    _je_3rd_pkg_lib_handle.clear();
}
"@;

    if (!writeall(workpath / "src" / "jeecs_3rd_pkg_extern_library.cpp", result))
        throw! F"Failed to update jeecs_3rd_pkg_extern_library.cpp.";
    expected_ok!;
}

func main()
{
    let mut copy_gles_emu = false;
    let mut copy_pkg_src_only = false;

    for (let cmd : std::args())
    {
        if (cmd == "-static-link-pkgs")
            copy_pkg_src_only = true;
        else if (cmd == "-gles-win32")
            copy_gles_emu = true;
    }

    try! _ = copy_pkgs(copy_pkg_src_only);
    if (copy_gles_emu)
    {
        try! _ = copy_opengles_emu_env_libs();
    }
    try! _ = generate_je_api_decls();
    try! _ = generate_je_3rd_pkg_decls();
    try! _ = copy_all_licenses();

    expected_ok!;
}

match (main())
{
ok(_)?
    {
        std::println("Done.");
        return 0;
    }
err(_)?
    {
        std::println("Failed.");
        return -1;
    }
}
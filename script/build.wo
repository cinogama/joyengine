import woo::std;

import pkg::fsys;
import pkg::try;
import pkg::iterator;
import pkg::regex;
import pkg::worst;

using fsys;
using iterator;

let workpath = fsys::workpath();
let third_party_located_path = workpath / "3rd";
let build_path = workpath / "build";

func copy_all_licenses()
{
    return try!
    {
        try! third_party_paths = subpath(third_party_located_path);

        for (let _3rd_path : third_party_paths->iter |> filter(\path = isdir(path);))
        {
            try! subpath_of_3rd = allsubpath(_3rd_path);
            for (let p : subpath_of_3rd)
            {
                if (isfile(p) && (
                    filename(p)->lower->find("license") != -1
                    || filename(p)->lower->find("copying") != -1))
                {
                    let relpath = p->tostring()->sub(third_party_located_path->tostring->len);

                    let target_path = build_path / "licenses" / relpath;
                    do mkdir(parent(target_path));
                    do copy(p, target_path);

                    std::println("copy license file: ", p->tostring());
                }
            }
        }
        return_ok!;
    }
    catch! errono
    {
        return F"Failed to copy all licenses: {errono}.";
    };
}

func copy_opengles_emu_env_libs()=> result<void, string>
{
    let gles_env_path = third_party_located_path / "opengles_env_w64";
    let lib_filenames = [
        "libEGL.dll",
        "libGLESv2.dll",
        "libMaliEmulator.dll",
        "log4cplus.dll",
    ];
    do lib_filenames
        ->> \name = copy(gles_env_path / name, build_path);
        ;
    do mkdir(build_path / "openglessl");
    do copy(gles_env_path / "openglessl", build_path / "openglessl");

    return_ok!;
}

func copy_pkgs(copy_src_only: bool)=> result<void, string>
{
    let source_path = workpath / "pkg";
    let target_path = build_path / "pkg";
    do mkdir(target_path);

    for (let path : recursive_walk(workpath / "pkg") |> iterator::iter_result)
    {
        if (isfile(path))
        {
            try! relative_path = relative(path, source_path)
                -> map_err(\eno = F"Failed to get relative path: {eno}.";);

            do mkdir(parent(target_path / relative_path));

            if (copy_src_only && extension(path)->lower != ".wo")
                continue;

            do copy(path, target_path / relative_path);
        }
    }
    return_ok!;
}

func scan_extern_function_in_path(i)
{
    let r = regex::create(@"extern\s*\(\s*\"(.*?)\"\s*,\s*\"(.*?)\""@);
    let iter = i 
        |> filter_map(\p = isfile(p) ? readall(p) | option::none;)
        |> flat_map(\p = r->search(p);)
        |> map(\match_result = (match_result.1[1], match_result.1[2]);)
        ;

    let result = {}mut: map<string, mut map<string, mut void>>;
    for (let (libname, funcname) : iter)
    {
        if (!result->contain(libname))
            result[libname] = {}mut;

        std::println(F"Found {libname}::{funcname}");
        result[libname][funcname] = do nil;
    }
    return result->>\k, v = (k, v->unmapping->>\kv = kv.0;->std::sort(\l, r = l < r;));;
}

func scan_pkg_entry_leave_function_in_path(i)
{
    let entrys = {}mut: map<string, void>;
    let leaves = {}mut: map<string, void>;

    let entry_r = regex::create(@"\s+wolib_entry\s*\("@);
    let leave_r = regex::create(@"\s+wolib_exit\s*\("@);

    for (let pkg_dir : i)
    {
        if (isdir(pkg_dir))
        {
            let pkgname = filename(pkg_dir);
            for (let content : recursive_walk(pkg_dir) 
                |> iter_result
                |> filter(\p = isfile(p) && ext == ".cpp" || ext == ".c" where ext = extension(p)->lower;)
                |> filter_map(\p = readall(p);))
            {
                if (!entry_r->search(content) |> collect -> empty)
                {
                    std::println(F"Found {pkgname} entry function.");
                    entrys->set(pkgname, do nil);
                }
                if (!leave_r->search(content) |> collect -> empty)
                {
                    std::println(F"Found {pkgname} leave function.");
                    leaves->set(pkgname, do nil);
                }
            }
        }
    }

    return (entrys->keys, leaves->keys);
}

func generate_je_api_decls()=> result<void, string>
{
    let libfuncs = scan_extern_function_in_path(
        walk(workpath / "src")->iterator::iter_result);

    let mut result = 
@"// THIS FILE IS AUTO GENERATED BY /script/build.wo

#define JE_IMPL
#define JE_ENABLE_DEBUG_API
#include "jeecs.hpp"

"@;
    for (let (_, funcs) : libfuncs)
        for (let f : funcs)
            result += F"WO_API wo_api {f}(wo_vm vm, wo_value args);\n";
    
    result += @"
wo_dylib_handle_t _je_api_lib_handle = nullptr;

void je_extern_lib_woo_api_init()
{
    assert(_je_api_lib_handle == nullptr);

    wo_extern_lib_func_t je_fs[] = {
"@;

   for (let (_, funcs) : libfuncs)
        for (let f : funcs)
            result += F"        wo_extern_lib_func_t\{\"{f}\", (void*)&{f}\},\n";

    result += 
@"      WO_EXTERN_LIB_FUNC_END,
    };
    _je_api_lib_handle = wo_fake_lib("libjoyecs", je_fs, nullptr);
}

void je_extern_lib_woo_api_finish()
{
    assert(_je_api_lib_handle != nullptr);

    wo_unload_lib(_je_api_lib_handle, WO_DYLIB_UNREF_AND_BURY);
    _je_api_lib_handle = nullptr;
}
"@;

    if (!writeall(workpath / "src" / "jeecs_extern_library_woo_api.cpp", result))
        throw! F"Failed to update jeecs_extern_library_woo_api.cpp.";
    return_ok!;
}

func generate_je_static_module_decls()=> result<void, string>
{
    let module_name_regex = regex::create(@"(.*)\.je4module"@);
    let module_name_list = []mut: vec<string>;

    for (let p : walk(workpath / "module")->iterator::iter_result)
    {
        if (module_name_regex->test(filename(p)) 
            && isdir(p) 
            && exist(p / "CMakeLists.txt"))
        {
            module_name_list->add(purename(p));
        }
    }

    let mut result = 
@"// THIS FILE IS AUTO GENERATED BY /script/build.wo

#define JE_IMPL
#define JE_ENABLE_DEBUG_API
#include "jeecs.hpp"

#if JE4_STATIC_LINK_MODULE_AND_PKGS
extern "C"
{
"@;

    for (let mname : module_name_list)
    {
        result += F"JE_EXPORT void jestatic_module_{mname}_entry(wo_dylib_handle_t lib_instance);\n";
        result += F"JE_EXPORT void jestatic_module_{mname}_leave();\n";
    }

    result += @"
}
#endif

std::vector<wo_dylib_handle_t> _je_static_module_lib_handle;
void je_extern_lib_module_init()
{
    assert(_je_static_module_lib_handle.empty());
#if JE4_STATIC_LINK_MODULE_AND_PKGS
"@;

    for (let mname : module_name_list)
    {
        result += F"    wo_extern_lib_func_t {mname}_fs[] = \{\n";
        result += F"        wo_extern_lib_func_t\{\"jeecs_module_entry\", (void*)&jestatic_module_{mname}_entry\},\n";
        result += F"        wo_extern_lib_func_t\{\"jeecs_module_leave\", (void*)&jestatic_module_{mname}_leave\},\n";
        result += F"        WO_EXTERN_LIB_FUNC_END,\n    };\n";
        result += F"    _je_static_module_lib_handle.push_back(\n"
                + F"        wo_fake_lib(\"{mname}\", {mname}_fs, nullptr));\n\n";
    }

    result += @"
#endif
}

void je_extern_lib_module_finish()
{
    for (auto* lib : _je_static_module_lib_handle)
    {
        assert(lib != nullptr);
        wo_unload_lib(lib, WO_DYLIB_UNREF_AND_BURY);
    }
    _je_static_module_lib_handle.clear();
}
"@;

    if (!writeall(workpath / "src" / "jeecs_extern_library_module.cpp", result))
        throw! F"Failed to update jeecs_extern_library_module.cpp.";

    return result::ok(do nil);
}

func generate_je_3rd_pkg_decls()=> result<void, string>
{
    let libfuncs = scan_extern_function_in_path(
        recursive_walk(workpath / "3rd" / "pkg")->iterator::iter_result
            |> filter(\p = extension(p)->lower == ".wo";))
        ->> \libname, funcnames = (libname, funcname_symbolname->to_vec)
            where funcname_symbolname = funcnames->> \fname = (fname, fname);
            ;
        ;

    let (libentry, libleave) = scan_pkg_entry_leave_function_in_path(
        walk(workpath / "3rd" / "pkg")->iterator::iter_result);

    let mut result = 
@"// THIS FILE IS AUTO GENERATED BY /script/build.wo

#define JE_IMPL
#define JE_ENABLE_DEBUG_API
#include "jeecs.hpp"

#if JE4_STATIC_LINK_MODULE_AND_PKGS
"@;

    for (let (_, funcnames) : libfuncs)
    {
        for (let (funcname, _) : funcnames)
            result += F"WO_API wo_api {funcname}(wo_vm vm, wo_value args);\n";

        result += "\n";
    }

    result += "\n";

    for (let pkgname : libentry)
    {
        let entry_func_name = F"je_static_wo_pkg_{pkgname}_entry";
        result += F"WO_API void {entry_func_name}(wo_dylib_handle_t lib_instance);\n";
        libfuncs["lib" + pkgname]->add((entry_func_name, "wolib_entry"));
    }

    result += "\n";

    for (let pkgname : libleave)
    {
        let exit_func_name = F"je_static_wo_pkg_{pkgname}_exit";
        result += F"WO_API void {exit_func_name}();\n";
        libfuncs["lib" + pkgname]->add((exit_func_name, "wolib_exit"));
    }

    result += @"
#endif

std::vector<wo_dylib_handle_t> _je_3rd_pkg_lib_handle;
void je_extern_lib_3rd_pkgs_init()
{
    assert(_je_3rd_pkg_lib_handle.empty()); 

#if JE4_STATIC_LINK_MODULE_AND_PKGS
"@;

    for (let (libname, funcnames) : libfuncs)
    {
        result += F"    wo_extern_lib_func_t {libname}_fs[] = \{\n";
        for (let (funcname, symbolname) : funcnames)
            result += F"        wo_extern_lib_func_t\{\"{symbolname}\", (void*)&{funcname}\},\n";

        result += F"        WO_EXTERN_LIB_FUNC_END,\n    };\n";
        result += F"    _je_3rd_pkg_lib_handle.push_back(\n"
                + F"        wo_fake_lib(\"{libname}\", {libname}_fs, nullptr));\n\n";
    }

    result += @"
#endif    
}

void je_extern_lib_3rd_pkgs_finish()
{
"@;
    result += @"
    for (auto* lib : _je_3rd_pkg_lib_handle)
    {
        assert(lib != nullptr);
        wo_unload_lib(lib, WO_DYLIB_UNREF_AND_BURY);
    }
    _je_3rd_pkg_lib_handle.clear();
}
"@;

    if (!writeall(workpath / "src" / "jeecs_extern_library_3rd_pkg.cpp", result))
        throw! F"Failed to update jeecs_extern_library_3rd_pkg.cpp.";
    return_ok!;
}

func main()
{
    let mut copy_gles_emu = false;
    let mut copy_pkg_src_only = false;

    for (let cmd : std::args())
    {
        if (cmd == "-static-link-pkgs")
            copy_pkg_src_only = true;
        else if (cmd == "-gles-win32")
            copy_gles_emu = true;
    }

    try! _ = copy_pkgs(copy_pkg_src_only);
    if (copy_gles_emu)
    {
        try! _ = copy_opengles_emu_env_libs();
    }
    try! _ = generate_je_api_decls();
    try! _ = generate_je_3rd_pkg_decls();
    try! _ = generate_je_static_module_decls();
    try! _ = copy_all_licenses();

    return_ok!;
}

match (main())
{
ok(_)?
    {
        std::println("Done.");
        return 0;
    }
err(_)?
    {
        std::println("Failed.");
        return -1;
    }
}
// Joyengine 4.x
import woo::std;
import je;

namespace je::gui
{
    public alias ImVec2 = (real, real);
    public alias Color32RGBA = (int, int, int, int);
    
    public enum WindowsAttribute
    {
        ImGuiWindowFlags_None                   = 0,
        ImGuiWindowFlags_NoTitleBar             = 0x00000001,   // Disable title-bar
        ImGuiWindowFlags_NoResize               = 0x00000002,   // Disable user resizing with the lower-right grip
        ImGuiWindowFlags_NoMove                 = 0x00000004,   // Disable user moving the window
        ImGuiWindowFlags_NoScrollbar            = 0x00000008,   // Disable scrollbars (window can still scroll with mouse or programmatically)
        ImGuiWindowFlags_NoScrollWithMouse      = 0x00000010,   // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.
        ImGuiWindowFlags_NoCollapse             = 0x00000020,   // Disable user collapsing window by double-clicking on it. Also referred to as Window Menu Button (e.g. within a docking node).
        ImGuiWindowFlags_AlwaysAutoResize       = 0x00000040,   // Resize every window to its content every frame
        ImGuiWindowFlags_NoBackground           = 0x00000080,   // Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).
        ImGuiWindowFlags_NoSavedSettings        = 0x00000100,   // Never load/save settings in .ini file
        ImGuiWindowFlags_NoMouseInputs          = 0x00000200,   // Disable catching mouse, hovering test with pass through.
        ImGuiWindowFlags_MenuBar                = 0x00000400,  // Has a menu-bar
        ImGuiWindowFlags_HorizontalScrollbar    = 0x00000800,  // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.
        ImGuiWindowFlags_NoFocusOnAppearing     = 0x00001000,  // Disable taking focus when transitioning from hidden to visible state
        ImGuiWindowFlags_NoBringToFrontOnFocus  = 0x00002000,  // Disable bringing window to front when taking focus (e.g. clicking on it or programmatically giving it focus)
        ImGuiWindowFlags_AlwaysVerticalScrollbar= 0x00004000,  // Always show vertical scrollbar (even if ContentSize.y < Size.y)
        ImGuiWindowFlags_AlwaysHorizontalScrollbar=0x00008000,  // Always show horizontal scrollbar (even if ContentSize.x < Size.x)
        ImGuiWindowFlags_AlwaysUseWindowPadding = 0x00010000,  // Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)
        
        ImGuiWindowFlags_NoNavInputs            = 0x00040000,  // No gamepad/keyboard navigation within the window
        ImGuiWindowFlags_NoNavFocus             = 0x00080000,  // No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB)
        ImGuiWindowFlags_UnsavedDocument        = 0x00100000,  // Display a dot next to the title. When used in a tab/docking context, tab is selected when clicking the X + closure is not assumed (will wait for user to stop submitting the tab). Otherwise closure is assumed when pressing the X, so if you keep submitting the tab may reappear at end of tab bar.
        ImGuiWindowFlags_NoDocking              = 0x00200000,  // Disable docking of this window
    //ImGuiWindowFlags_NoNav                  = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,
    //ImGuiWindowFlags_NoDecoration           = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,
    //ImGuiWindowFlags_NoInputs               = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,
    }
    
    public enum TreeNodeAttribute
    {
        ImGuiTreeNodeFlags_None                 = 0,
        ImGuiTreeNodeFlags_Selected             = 0x0000'0001,   // Draw as selected
        ImGuiTreeNodeFlags_Framed               = 0x0000'0002,   // Draw frame with background (e.g. for CollapsingHeader)
        ImGuiTreeNodeFlags_AllowItemOverlap     = 0x0000'0004,   // Hit testing to allow subsequent widgets to overlap this one
        ImGuiTreeNodeFlags_NoTreePushOnOpen     = 0x0000'0008,   // Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack
        ImGuiTreeNodeFlags_NoAutoOpenOnLog      = 0x0000'0010,   // Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)
        ImGuiTreeNodeFlags_DefaultOpen          = 0x0000'0020,   // Default node to be open
        ImGuiTreeNodeFlags_OpenOnDoubleClick    = 0x0000'0040,   // Need double-click to open node
        ImGuiTreeNodeFlags_OpenOnArrow          = 0x0000'0080,   // Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.
        ImGuiTreeNodeFlags_Leaf                 = 0x0000'0100,   // No collapsing, no arrow (use as a convenience for leaf nodes).
        ImGuiTreeNodeFlags_Bullet               = 0x0000'0200,   // Display a bullet instead of arrow
        ImGuiTreeNodeFlags_FramePadding         = 0x0000'0400,  // Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().
        ImGuiTreeNodeFlags_SpanAvailWidth       = 0x0000'0800,  // Extend hit box to the right-most edge, even if not framed. This is not the default in order to allow adding other items on the same line. In the future we may refactor the hit system to be front-to-back, allowing natural overlaps and then this can become the default.
        ImGuiTreeNodeFlags_SpanFullWidth        = 0x0000'1000,  // Extend hit box to the left-most and right-most edges (bypass the indented area).
        ImGuiTreeNodeFlags_NavLeftJumpsBackHere = 0x0000'2000,  // (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)
        ImGuiTreeNodeFlags_NoScrollOnOpen     = 0x0000'4000,  // FIXME: TODO: Disable automatic scroll on TreePop() if node got just open and contents is not visible
        ImGuiTreeNodeFlags_CollapsingHeader     = ImGuiTreeNodeFlags_Framed + ImGuiTreeNodeFlags_NoTreePushOnOpen + ImGuiTreeNodeFlags_NoAutoOpenOnLog,
    };
    
    public enum ImGuiMouseButton
    {
        ImGuiMouseButton_Left = 0,
        ImGuiMouseButton_Right = 1,
        ImGuiMouseButton_Middle = 2,
        ImGuiMouseButton_COUNT = 5
        };
        
    extern("libjoyecs", "je_gui_job_vm_handle")
        public func JobID()=> handle;
        
    extern("libjoyecs", "je_gui_set_clip_board_text")
        public func SetClipboardText(text: string)=> void;
    extern("libjoyecs", "je_gui_get_clip_board_text")
        public func GetClipboardText()=> string;
        
    extern("libjoyecs", "je_gui_get_main_viewport_pos")
        public func GetMainViewportPos()=> ImVec2;
    extern("libjoyecs", "je_gui_get_window_pos")
        public func GetWindowPos()=> ImVec2;
    extern("libjoyecs", "je_gui_get_mouse_pos")
        public func GetMousePos()=> ImVec2;
    extern("libjoyecs", "je_gui_get_mouse_wheel")
        public func GetMouseWheel()=> ImVec2;
    extern("libjoyecs", "je_gui_get_mouse_delta_pos")
        public func GetMouseDeltaPos()=> ImVec2;
    extern("libjoyecs", "je_gui_get_cursor_pos")
        public func GetCursorPos()=> ImVec2;
    extern("libjoyecs", "je_gui_get_item_rect_size")
        public func GetItemRectSize()=> ImVec2;
        
    extern("libjoyecs", "je_gui_get_item_rect")
        public func GetItemRect()=> (ImVec2, ImVec2);
        
    extern("libjoyecs", "je_gui_begin")
        public func Begin(title:string)=> bool;
    extern("libjoyecs", "je_gui_begin_attr")
        public func BeginAttr(title:string, attribute:WindowsAttribute)=> bool;
    extern("libjoyecs", "je_gui_begin_open")
        public func BeginAttrOpen(title:string, attribute:WindowsAttribute)=> option<bool>;
    public func BeginOpen(title:string)
    {
        return BeginAttrOpen(title, WindowsAttribute::ImGuiWindowFlags_None);
    }
    
    extern("libjoyecs", "je_gui_end")
        public func End()=> void;
        
    extern("libjoyecs", "je_gui_begin_child")
        public func BeginChild(title:string)=> bool;
    extern("libjoyecs", "je_gui_begin_child_attr")
        public func BeginChildAttr(title:string, attr: WindowsAttribute)=> bool;
    extern("libjoyecs", "je_gui_begin_child_size")
        public func BeginChildSize(title:string, sizex: real, sizey: real)=> bool;
        
    extern("libjoyecs", "je_gui_is_window_focused")
        public func IsWindowFocused()=> bool;
        
    extern("libjoyecs", "je_gui_end_child")
        public func EndChild()=> void;
        
    extern("libjoyecs", "je_gui_progress_bar")
        public func ProgressBar(f: real)=> void;
        
    extern("libjoyecs", "je_gui_progress_bar_size")
        public func ProgressBarSize(f: real, size: (real, real))=> void;
        
    extern("libjoyecs", "je_gui_text")
        public func Text(msg:string)=> void;
    extern("libjoyecs", "je_gui_text_disabled")
        public func TextDisabled(msg:string)=> void;
        
    extern("libjoyecs", "je_gui_button")
        public func Button(msg:string)=> bool;
    extern("libjoyecs", "je_gui_button_size")
        public func ButtonSize(msg:string, size: ImVec2)=> bool;
        
    extern("libjoyecs", "je_gui_invisible_button")
        public func InvisibleButton(msg:string, size: ImVec2)=> bool;
        
    extern("libjoyecs", "je_gui_begin_main_menu_bar")
        public func BeginMainMenuBar()=> bool;
        
    extern("libjoyecs", "je_gui_menu_item")
        public func MenuItem(text:string)=> bool;
    extern("libjoyecs", "je_gui_menu_item_shortcut")
        public func MenuItemShortcut(text:string, shortcut:string)=> bool;
    extern("libjoyecs", "je_gui_menu_item_enabled")
        public func MenuItemEnabled(text:string, enable:bool)=> bool;
    extern("libjoyecs", "je_gui_menu_item_shortcut_enabled")
        public func MenuItemShortcutEnabled(text:string, shortcut:string, enable:bool)=> bool;
    extern("libjoyecs", "je_gui_menu_item_selected")
        public func MenuItemShortcutSelectedEnabled(text:string, shortcut:string, selected:bool, enable:bool)=> option<bool /*selected*/>;
    public func MenuItemSelectedEnabled(text:string, selected:bool, enable:bool)=> option<bool /*selected*/>
    {
        return MenuItemShortcutSelectedEnabled(text, "", selected, enable);
    }
    public func MenuItemSelected(text:string, selected:bool)=> option<bool /*selected*/>
    {
        return MenuItemShortcutSelectedEnabled(text, "", selected, true);
    }
    
    extern("libjoyecs", "je_gui_end_main_menu_bar")
        public func EndMainMenuBar()=> void;
        
    extern("libjoyecs", "je_gui_begin_menu_bar")
        public func BeginMenuBar()=> bool;
        
    extern("libjoyecs", "je_gui_end_menu_bar")
        public func EndMenuBar()=> void;
        
    extern("libjoyecs", "je_gui_begin_menu")
        public func BeginMenu(text:string)=> bool;
    extern("libjoyecs", "je_gui_begin_menu_enabled")
        public func BeginMenuEnabled(text:string, enable:bool)=> bool;
        
    extern("libjoyecs", "je_gui_listbox")
        public func ListBox(label:string, items:array<string>)=> option<int>;
    extern("libjoyecs", "je_gui_listbox_select")
        public func ListBoxSelect(label:string, items:array<string>, select_item:int)=> option<int>;
    extern("libjoyecs", "je_gui_listbox_select_height")
        public func ListBoxSelectHeight(label:string, items:array<string>, select_item:int, height_count:int)=> option<int>;
    extern("libjoyecs", "je_gui_listbox_withsize")
        public func ListBoxSelectSize(label:string, items:array<string>, select_item:int, width:real, height:real)=> option<int>;
        
    extern("libjoyecs", "je_gui_begin_listbox")
        public func BeginListBox(label:string, width:real, height:real)=>bool;
    extern("libjoyecs", "je_gui_begin_selectable")
        public func Selectable(label:string)=>bool;
    extern("libjoyecs", "je_gui_begin_selectable_selected")
        public func SelectableSelected(label:string, selected:bool)=>bool;
    extern("libjoyecs", "je_gui_end_listbox")
        public func EndListBox()=> void;
        
    extern("libjoyecs", "je_gui_sameline")
        public func SameLine()=>void;
        
    extern("libjoyecs", "je_gui_begingroup")
        public func BeginGroup()=>void;
    extern("libjoyecs", "je_gui_endgroup")
        public func EndGroup()=>void;
        
    extern("libjoyecs", "je_gui_treenode")
        public func TreeNode(label:string)=>bool;
    extern("libjoyecs", "je_gui_treenodeex")
        public func TreeNodeEx(label:string, attrib: TreeNodeAttribute)=>bool;
    extern("libjoyecs", "je_gui_treepop")
        public func TreePop()=>void;
        
    extern("libjoyecs", "je_gui_is_itemclicked")
        public func IsItemClicked(button: ImGuiMouseButton)=> bool;
        
    public func IsItemClickedLeft()
    {
        return IsItemClicked(ImGuiMouseButton::ImGuiMouseButton_Left);
    }
    
    extern("libjoyecs", "je_gui_is_itemtoggledopen")
        public func IsItemToggledOpen()=> bool;
    extern("libjoyecs", "je_gui_is_itemhovered")
        public func IsItemHovered()=> bool;
    extern("libjoyecs", "je_gui_is_mousehoveringrect")
        public func IsMouseHoveringRect(p0: (real, real), p1: (real, real))=> bool;
        
    extern("libjoyecs", "je_gui_is_item_active")
        public func IsItemActive()=> bool;
        
    extern("libjoyecs", "je_gui_is_mouse_dragging")
        public func IsMouseDragging(attr: ImGuiMouseButton)=> bool;
    extern("libjoyecs", "je_gui_is_mouse_down")
        public func IsMouseDown(attr: ImGuiMouseButton)=> bool;
    extern("libjoyecs", "je_gui_is_mouse_released")
        public func IsMouseReleased(attr: ImGuiMouseButton)=> bool;
        
    public enum ImGuiKey
    {
        // Keyboard
        ImGuiKey_None = 0,
        ImGuiKey_Tab = 512,             // == ImGuiKey_NamedKey_BEGIN
        ImGuiKey_LeftArrow,
        ImGuiKey_RightArrow,
        ImGuiKey_UpArrow,
        ImGuiKey_DownArrow,
        ImGuiKey_PageUp,
        ImGuiKey_PageDown,
        ImGuiKey_Home,
        ImGuiKey_End,
        ImGuiKey_Insert,
        ImGuiKey_Delete,
        ImGuiKey_Backspace,
        ImGuiKey_Space,
        ImGuiKey_Enter,
        ImGuiKey_Escape,
        ImGuiKey_LeftCtrl, ImGuiKey_LeftShift, ImGuiKey_LeftAlt, ImGuiKey_LeftSuper,
        ImGuiKey_RightCtrl, ImGuiKey_RightShift, ImGuiKey_RightAlt, ImGuiKey_RightSuper,
        ImGuiKey_Menu,
        ImGuiKey_0, ImGuiKey_1, ImGuiKey_2, ImGuiKey_3, ImGuiKey_4, ImGuiKey_5, ImGuiKey_6, ImGuiKey_7, ImGuiKey_8, ImGuiKey_9,
        ImGuiKey_A, ImGuiKey_B, ImGuiKey_C, ImGuiKey_D, ImGuiKey_E, ImGuiKey_F, ImGuiKey_G, ImGuiKey_H, ImGuiKey_I, ImGuiKey_J,
        ImGuiKey_K, ImGuiKey_L, ImGuiKey_M, ImGuiKey_N, ImGuiKey_O, ImGuiKey_P, ImGuiKey_Q, ImGuiKey_R, ImGuiKey_S, ImGuiKey_T,
        ImGuiKey_U, ImGuiKey_V, ImGuiKey_W, ImGuiKey_X, ImGuiKey_Y, ImGuiKey_Z,
        ImGuiKey_F1, ImGuiKey_F2, ImGuiKey_F3, ImGuiKey_F4, ImGuiKey_F5, ImGuiKey_F6,
        ImGuiKey_F7, ImGuiKey_F8, ImGuiKey_F9, ImGuiKey_F10, ImGuiKey_F11, ImGuiKey_F12,
        ImGuiKey_Apostrophe,        // '
        ImGuiKey_Comma,             // ,
        ImGuiKey_Minus,             // -
        ImGuiKey_Period,            // .
        ImGuiKey_Slash,             // /
        ImGuiKey_Semicolon,         // ;
        ImGuiKey_Equal,             // =
        ImGuiKey_LeftBracket,       // [
        ImGuiKey_Backslash,         // \ (this text inhibit multiline comment caused by backslash)
        ImGuiKey_RightBracket,      // ]
        ImGuiKey_GraveAccent,       // `
        ImGuiKey_CapsLock,
        ImGuiKey_ScrollLock,
        ImGuiKey_NumLock,
        ImGuiKey_PrintScreen,
        ImGuiKey_Pause,
        ImGuiKey_Keypad0, ImGuiKey_Keypad1, ImGuiKey_Keypad2, ImGuiKey_Keypad3, ImGuiKey_Keypad4,
        ImGuiKey_Keypad5, ImGuiKey_Keypad6, ImGuiKey_Keypad7, ImGuiKey_Keypad8, ImGuiKey_Keypad9,
        ImGuiKey_KeypadDecimal,
        ImGuiKey_KeypadDivide,
        ImGuiKey_KeypadMultiply,
        ImGuiKey_KeypadSubtract,
        ImGuiKey_KeypadAdd,
        ImGuiKey_KeypadEnter,
        ImGuiKey_KeypadEqual,
        
        // Gamepad (some of those are analog values, 0.0f to 1.0f)                          // NAVIGATION ACTION
        // (download controller mapping PNG/PSD at http://dearimgui.com/controls_sheets)
        ImGuiKey_GamepadStart,          // Menu (Xbox)      + (Switch)   Start/Options (PS)
        ImGuiKey_GamepadBack,           // View (Xbox)      - (Switch)   Share (PS)
        ImGuiKey_GamepadFaceLeft,       // X (Xbox)         Y (Switch)   Square (PS)        // Tap: Toggle Menu. Hold: Windowing mode (Focus/Move/Resize windows)
        ImGuiKey_GamepadFaceRight,      // B (Xbox)         A (Switch)   Circle (PS)        // Cancel / Close / Exit
        ImGuiKey_GamepadFaceUp,         // Y (Xbox)         X (Switch)   Triangle (PS)      // Text Input / On-screen Keyboard
        ImGuiKey_GamepadFaceDown,       // A (Xbox)         B (Switch)   Cross (PS)         // Activate / Open / Toggle / Tweak
        ImGuiKey_GamepadDpadLeft,       // D-pad Left                                       // Move / Tweak / Resize Window (in Windowing mode)
        ImGuiKey_GamepadDpadRight,      // D-pad Right                                      // Move / Tweak / Resize Window (in Windowing mode)
        ImGuiKey_GamepadDpadUp,         // D-pad Up                                         // Move / Tweak / Resize Window (in Windowing mode)
        ImGuiKey_GamepadDpadDown,       // D-pad Down                                       // Move / Tweak / Resize Window (in Windowing mode)
        ImGuiKey_GamepadL1,             // L Bumper (Xbox)  L (Switch)   L1 (PS)            // Tweak Slower / Focus Previous (in Windowing mode)
        ImGuiKey_GamepadR1,             // R Bumper (Xbox)  R (Switch)   R1 (PS)            // Tweak Faster / Focus Next (in Windowing mode)
        ImGuiKey_GamepadL2,             // L Trig. (Xbox)   ZL (Switch)  L2 (PS) [Analog]
        ImGuiKey_GamepadR2,             // R Trig. (Xbox)   ZR (Switch)  R2 (PS) [Analog]
        ImGuiKey_GamepadL3,             // L Stick (Xbox)   L3 (Switch)  L3 (PS)
        ImGuiKey_GamepadR3,             // R Stick (Xbox)   R3 (Switch)  R3 (PS)
        ImGuiKey_GamepadLStickLeft,     // [Analog]                                         // Move Window (in Windowing mode)
        ImGuiKey_GamepadLStickRight,    // [Analog]                                         // Move Window (in Windowing mode)
        ImGuiKey_GamepadLStickUp,       // [Analog]                                         // Move Window (in Windowing mode)
        ImGuiKey_GamepadLStickDown,     // [Analog]                                         // Move Window (in Windowing mode)
        ImGuiKey_GamepadRStickLeft,     // [Analog]
        ImGuiKey_GamepadRStickRight,    // [Analog]
        ImGuiKey_GamepadRStickUp,       // [Analog]
        ImGuiKey_GamepadRStickDown,     // [Analog]
        
        // Aliases: Mouse Buttons (auto-submitted from AddMouseButtonEvent() calls)
        // - This is mirroring the data also written to io.MouseDown[], io.MouseWheel, in a format allowing them to be accessed via standard key API.
        ImGuiKey_MouseLeft, ImGuiKey_MouseRight, ImGuiKey_MouseMiddle, ImGuiKey_MouseX1, ImGuiKey_MouseX2, ImGuiKey_MouseWheelX, ImGuiKey_MouseWheelY,
        
        // [Internal] Reserved for mod storage
        ImGuiKey_ReservedForModCtrl, ImGuiKey_ReservedForModShift, ImGuiKey_ReservedForModAlt, ImGuiKey_ReservedForModSuper,
        ImGuiKey_COUNT,
        
        // Keyboard Modifiers (explicitly submitted by backend via AddKeyEvent() calls)
        // - This is mirroring the data also written to io.KeyCtrl, io.KeyShift, io.KeyAlt, io.KeySuper, in a format allowing
        //   them to be accessed via standard key API, allowing calls such as IsKeyPressed(), IsKeyReleased(), querying duration etc.
        // - Code polling every key (e.g. an interface to detect a key press for input mapping) might want to ignore those
        //   and prefer using the real keys (e.g. ImGuiKey_LeftCtrl, ImGuiKey_RightCtrl instead of ImGuiMod_Ctrl).
        // - In theory the value of keyboard modifiers should be roughly equivalent to a logical or of the equivalent left/right keys.
        //   In practice: it's complicated; mods are often provided from different sources. Keyboard layout, IME, sticky keys and
        //   backends tend to interfere and break that equivalence. The safer decision is to relay that ambiguity down to the end-user...
        ImGuiMod_None                   = 0,
        ImGuiMod_Ctrl                   = 0x1000, // 1 << 12, // Ctrl
        ImGuiMod_Shift                  = 0x2000, // 1 << 13, // Shift
        ImGuiMod_Alt                    = 0x4000, // 1 << 14, // Option/Menu
        ImGuiMod_Super                  = 0x8000, // 1 << 15, // Cmd/Super/Windows
        ImGuiMod_Shortcut               = 0x0800, // 1 << 11, // Alias for Ctrl (non-macOS) _or_ Super (macOS).
        ImGuiMod_Mask_                  = 0xF800,  // 5-bits
    }
    
    extern("libjoyecs", "je_gui_is_key_down")
        public func IsKeyDown(attr: ImGuiKey)=> bool;
        
    extern("libjoyecs", "je_gui_set_tooltip")
        public func SetTooltip(msg: string)=> bool;
        
    extern("libjoyecs", "je_gui_beginpopup_contextitem_label")
        public func BeginPopupContextItemLabel(label:string)=>bool;
    extern("libjoyecs", "je_gui_beginpopup_contextitem")
        public func BeginPopupContextItem()=>bool;
        
    extern("libjoyecs", "je_gui_beginpopup_contextwindow_label")
        public func BeginPopupContextWindowLabel(label:string)=>bool;
    extern("libjoyecs", "je_gui_beginpopup_contextwindow")
        public func BeginPopupContextWindow()=>bool;
        
    public enum TabBarAttribute
    {
        ImGuiTabBarFlags_None                           = 0,
        ImGuiTabBarFlags_Reorderable                    = 1,   // Allow manually dragging tabs to re-order them + New tabs are appended at the end of list
        ImGuiTabBarFlags_AutoSelectNewTabs              = 2,   // Automatically select new tabs when they appear
        ImGuiTabBarFlags_TabListPopupButton             = 4,   // Disable buttons to open the tab list popup
        ImGuiTabBarFlags_NoCloseWithMiddleMouseButton   = 8,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
        ImGuiTabBarFlags_NoTabListScrollingButtons      = 16,   // Disable scrolling buttons (apply when fitting policy is ImGuiTabBarFlags_FittingPolicyScroll)
        ImGuiTabBarFlags_NoTooltip                      = 32,   // Disable tooltips when hovering a tab
        ImGuiTabBarFlags_FittingPolicyResizeDown        = 64,   // Resize tabs when they don't fit
        ImGuiTabBarFlags_FittingPolicyScroll            = 128,   // Add scroll buttons when tabs don't fit
        ImGuiTabBarFlags_FittingPolicyMask_             = ImGuiTabBarFlags_FittingPolicyResizeDown + ImGuiTabBarFlags_FittingPolicyScroll,
        ImGuiTabBarFlags_FittingPolicyDefault_          = ImGuiTabBarFlags_FittingPolicyResizeDown,
    }
    
    public enum TabItemAttribute
    {
        ImGuiTabItemFlags_None                          = 0,
        ImGuiTabItemFlags_UnsavedDocument               = 1,   // Display a dot next to the title + tab is selected when clicking the X + closure is not assumed (will wait for user to stop submitting the tab). Otherwise closure is assumed when pressing the X, so if you keep submitting the tab may reappear at end of tab bar.
        ImGuiTabItemFlags_SetSelected                   = 2,   // Trigger flag to programmatically make the tab selected when calling BeginTabItem()
        ImGuiTabItemFlags_NoCloseWithMiddleMouseButton  = 4,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
        ImGuiTabItemFlags_NoPushId                      = 8,   // Don't call PushID(tab->ID)/PopID() on BeginTabItem()/EndTabItem()
        ImGuiTabItemFlags_NoTooltip                     = 16,   // Disable tooltip for the given tab
        ImGuiTabItemFlags_NoReorder                     = 32,   // Disable reordering this tab or having another tab cross over this tab
        ImGuiTabItemFlags_Leading                       = 64,   // Enforce the tab position to the left of the tab bar (after the tab list popup button)
        ImGuiTabItemFlags_Trailing                      = 128,    // Enforce the tab position to the right of the tab bar (before the scrolling buttons)
    }
    
    extern("libjoyecs", "je_gui_begintabbar")
        public func BeginTabBarAttr(label: string, attr: TabBarAttribute)=> bool;
    public func BeginTabBar(label: string)
    {
        return BeginTabBarAttr(label, TabBarAttribute::ImGuiTabBarFlags_None);
    }
    extern("libjoyecs", "je_gui_endtabbar")
        public func EndTabBar()=> void;
        
    extern("libjoyecs", "je_gui_begintabitem")
        public func BeginTabItemAttr(label: string, attr: TabItemAttribute)=> bool;
    extern("libjoyecs", "je_gui_begintabitem_open")
        public func BeginTabItemAttrOpen(label: string, attr: TabItemAttribute)=> (bool /* show */, bool /* open */);
        
    public func BeginTabItem(label: string)
    {
        return BeginTabItemAttr(label, TabItemAttribute::ImGuiTabItemFlags_None);
    }
    public func BeginTabItemOpen(label: string)
    {
        return BeginTabItemAttrOpen(label, TabItemAttribute::ImGuiTabItemFlags_None);
    }
    
    extern("libjoyecs", "je_gui_endtabitem")
        public func EndTabItem()=> void;
        
    public enum PopupAttribute
    {
        NONE
        }
        
    extern("libjoyecs", "je_gui_openpopup_on_item_click")
        public func OpenPopupOnItemClick()=>void;
    extern("libjoyecs", "je_gui_openpopup_on_item_click_attr")
        public func OpenPopupOnItemClickAttr(flag:PopupAttribute)=>void;
    extern("libjoyecs", "je_gui_openpopup_on_item_click_label")
        public func OpenPopupOnItemClickLabel(label:string)=>void;
    extern("libjoyecs", "je_gui_openpopup_on_item_click_label_attr")
        public func OpenPopupOnItemClickLabelAttr(label:string, flag:PopupAttribute)=>void;
        
    extern("libjoyecs", "je_gui_openpopup")
        public func OpenPopup(label:string)=>void;
        
    extern("libjoyecs", "je_gui_beginpopup")
        public func BeginPopup(label:string)=>bool;
        
    extern("libjoyecs", "je_gui_endpopup")
        public func EndPopup()=>void;
        
    extern("libjoyecs", "je_gui_push_id")
        public func PushIDInt(id:int)=>void;
        
    extern("libjoyecs", "je_gui_push_id_str")
        public func PushIDStr(id:string)=>void;
        
    extern("libjoyecs", "je_gui_pop_id")
        public func PopID()=>void;
        
    extern("libjoyecs", "je_gui_get_id")
        public func GetID(name: string)=>int;
        
    extern("libjoyecs", "je_gui_checkbox")
        public func CheckBox(label: string, checked: bool)=> option<bool>;
        
    extern("libjoyecs", "je_gui_colorpicker4")
        public func ColorPicker4(label:string, color: (real, real, real, real))=> option<(real, real, real, real)>;
        
    extern("libjoyecs", "je_gui_colorbutton")
        public func ColorButton(label:string, color: (real, real, real, real))=> bool;
        
    public enum ImGuiInputTextFlags
    {
        ImGuiInputTextFlags_None                = 0,
        ImGuiInputTextFlags_CharsDecimal        = 0x00000001,   // Allow 0123456789.+-*/
        ImGuiInputTextFlags_CharsHexadecimal    = 0x00000002,   // Allow 0123456789ABCDEFabcdef
        ImGuiInputTextFlags_CharsUppercase      = 0x00000004,   // Turn a..z into A..Z
        ImGuiInputTextFlags_CharsNoBlank        = 0x00000008,   // Filter out spaces, tabs
        ImGuiInputTextFlags_AutoSelectAll       = 0x00000010,   // Select entire text when first taking mouse focus
        ImGuiInputTextFlags_EnterReturnsTrue    = 0x00000020,   // Return 'true' when Enter is pressed (as opposed to every time the value was modified). Consider looking at the IsItemDeactivatedAfterEdit() function.
        ImGuiInputTextFlags_CallbackCompletion  = 0x00000040,   // Callback on pressing TAB (for completion handling)
        ImGuiInputTextFlags_CallbackHistory     = 0x00000080,   // Callback on pressing Up/Down arrows (for history handling)
        ImGuiInputTextFlags_CallbackAlways      = 0x00000100,   // Callback on each iteration. User code may query cursor position, modify text buffer.
        ImGuiInputTextFlags_CallbackCharFilter  = 0x00000200,   // Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
        ImGuiInputTextFlags_AllowTabInput       = 0x00000400,  // Pressing TAB input a '\t' character into the text field
        ImGuiInputTextFlags_CtrlEnterForNewLine = 0x00000800,  // In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter).
        ImGuiInputTextFlags_NoHorizontalScroll  = 0x00001000,  // Disable following the cursor horizontally
        ImGuiInputTextFlags_AlwaysOverwrite     = 0x00002000,  // Overwrite mode
        ImGuiInputTextFlags_ReadOnly            = 0x00004000,  // Read-only mode
        ImGuiInputTextFlags_Password            = 0x00008000,  // Password mode, display all characters as '*'
        ImGuiInputTextFlags_NoUndoRedo          = 0x00010000,  // Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().
        ImGuiInputTextFlags_CharsScientific     = 0x00020000,  // Allow 0123456789.+-*/eE (Scientific notation input)
        ImGuiInputTextFlags_CallbackResize      = 0x00040000,  // Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. Notify when the string wants to be resized (for string types which hold a cache of their Size). You will be provided a new BufSize in the callback and NEED to honor it. (see misc/cpp/imgui_stdlib.h for an example of using this)
        ImGuiInputTextFlags_CallbackEdit        = 0x00080000,  // Callback on any edit (note that InputText() already returns true on edit, the callback is useful mainly to manipulate the underlying buffer while focus is active)
        ImGuiInputTextFlags_EscapeClearsAll     = 0x00100000,  // Escape key clears content if not empty, and deactivate otherwise (contrast to default behavior of Escape to revert)
        
    // Obsolete names
    //ImGuiInputTextFlags_AlwaysInsertMode  = ImGuiInputTextFlags_AlwaysOverwrite   // [renamed in 1.82] name was not matching behavior
    };
    
    extern("libjoyecs", "je_gui_input_text_box")
        public func InputText(label:string, buffer: string)=> option<string>;
        
    extern("libjoyecs", "je_gui_input_text_attr_box")
        public func InputTextAttr(label:string, buffer: string, flag: ImGuiInputTextFlags)=> option<string>;
        
    extern("libjoyecs", "je_gui_drag_float")
        public func DragFloat(label: string, value: real, step: real, min: real, max: real)=> option<real>;
        
    extern("libjoyecs", "je_gui_input_float_box")
        public func InputFloat(label: string, value: real)=> option<real>;
    extern("libjoyecs", "je_gui_input_float_format_box")
        public func InputFloatFormat(label: string, value: real, format: string)=> option<real>;
        
    extern("libjoyecs", "je_gui_input_int_box")
        public func InputInt(label: string, value: int)=> option<int>;
        
    extern("libjoyecs", "je_gui_input_int2_box")
        public func InputInt2(label: string, x: int, y: int)=> option<(int, int)>;
        
    extern("libjoyecs", "je_gui_input_int3_box")
        public func InputInt3(label: string, x: int, y: int, z: int)=> option<(int, int, int)>;
        
    extern("libjoyecs", "je_gui_input_int4_box")
        public func InputInt4(label: string, x: int, y: int, z: int, w: int)=> option<(int, int, int, int)>;
        
    extern("libjoyecs", "je_gui_input_float2_box")
        public func InputFloat2(label: string, x: real, y: real)=> option<(real, real)>;
    extern("libjoyecs", "je_gui_input_float2_format_box")
        public func InputFloat2Format(label: string, x: real, y: real, format: string)=> option<(real, real)>;
        
    extern("libjoyecs", "je_gui_input_float3_box")
        public func InputFloat3(label: string, x: real, y: real, z: real)=> option<(real, real, real)>;
    extern("libjoyecs", "je_gui_input_float3_format_box")
        public func InputFloat3Format(label: string, x: real, y: real, z: real, format: string)=> option<(real, real, real)>;
        
    extern("libjoyecs", "je_gui_input_float4_box")
        public func InputFloat4(label: string, x: real, y: real, z: real, w: real)=> option<(real, real, real, real)>;
    extern("libjoyecs", "je_gui_input_float4_format_box")
        public func InputFloat4Format(label: string, x: real, y: real, z: real, w: real, format: string)=> option<(real, real, real, real)>;
        
    extern("libjoyecs", "je_gui_input_text_multiline")
        public func InputTextMultiline(label:string, buffer: string)=> option<string>;
    extern("libjoyecs", "je_gui_input_text_multiline_size")
        public func InputTextMultilineSize(label:string, buffer: string, width:real, height:real)=> option<string>;
        
    extern("libjoyecs", "je_gui_combo")
        public func Combo(label:string, items: array<string>, select_item: option<int>)=> option<int>;
        
    extern("libjoyecs", "je_gui_end_menu")
        public func EndMenu()=> void;
        
    extern("libjoyecs", "je_gui_separator")
        public func Separator()=> void;
        
    extern("libjoyecs", "je_gui_image")
        public func Image(tex: je::graphic::texture)=> void;
    extern("libjoyecs", "je_gui_image_scale")
        public func ImageScale(tex: je::graphic::texture, scale: real)=> void;
    extern("libjoyecs", "je_gui_image_size")
        public func ImageSize(tex: je::graphic::texture, width: real, height: real)=> void;
    extern("libjoyecs", "je_gui_image_size_color")
        public func ImageSizeColor(tex: je::graphic::texture, width: real, height: real, color: Color32RGBA)=> void;
        
    extern("libjoyecs", "je_gui_push_item_width")
        public func PushItemWidth(width: real)=> void;
        
    extern("libjoyecs", "je_gui_pop_item_width")
        public func PopItemWidth()=> void;
        
    extern("libjoyecs", "je_gui_push_clip_rect")
        public func PushClipRect(from: ImVec2, to: ImVec2)=> void;
        
    extern("libjoyecs", "je_gui_pop_clip_rect")
        public func PopClipRect()=> void;
        
    public enum ImGuiCol
    {
        ImGuiCol_Text,
        ImGuiCol_TextDisabled,
        ImGuiCol_WindowBg,              // Background of normal windows
        ImGuiCol_ChildBg,               // Background of child windows
        ImGuiCol_PopupBg,               // Background of popups, menus, tooltips windows
        ImGuiCol_Border,
        ImGuiCol_BorderShadow,
        ImGuiCol_FrameBg,               // Background of checkbox, radio button, plot, slider, text input
        ImGuiCol_FrameBgHovered,
        ImGuiCol_FrameBgActive,
        ImGuiCol_TitleBg,
        ImGuiCol_TitleBgActive,
        ImGuiCol_TitleBgCollapsed,
        ImGuiCol_MenuBarBg,
        ImGuiCol_ScrollbarBg,
        ImGuiCol_ScrollbarGrab,
        ImGuiCol_ScrollbarGrabHovered,
        ImGuiCol_ScrollbarGrabActive,
        ImGuiCol_CheckMark,
        ImGuiCol_SliderGrab,
        ImGuiCol_SliderGrabActive,
        ImGuiCol_Button,
        ImGuiCol_ButtonHovered,
        ImGuiCol_ButtonActive,
        ImGuiCol_Header,                // Header* colors are used for CollapsingHeader, TreeNode, Selectable, MenuItem
        ImGuiCol_HeaderHovered,
        ImGuiCol_HeaderActive,
        ImGuiCol_Separator,
        ImGuiCol_SeparatorHovered,
        ImGuiCol_SeparatorActive,
        ImGuiCol_ResizeGrip,            // Resize grip in lower-right and lower-left corners of windows.
        ImGuiCol_ResizeGripHovered,
        ImGuiCol_ResizeGripActive,
        ImGuiCol_Tab,                   // TabItem in a TabBar
        ImGuiCol_TabHovered,
        ImGuiCol_TabActive,
        ImGuiCol_TabUnfocused,
        ImGuiCol_TabUnfocusedActive,
        ImGuiCol_DockingPreview,        // Preview overlay color when about to docking something
        ImGuiCol_DockingEmptyBg,        // Background color for empty node (e.g. CentralNode with no window docked into it)
        ImGuiCol_PlotLines,
        ImGuiCol_PlotLinesHovered,
        ImGuiCol_PlotHistogram,
        ImGuiCol_PlotHistogramHovered,
        ImGuiCol_TableHeaderBg,         // Table header background
        ImGuiCol_TableBorderStrong,     // Table outer and header borders (prefer using Alpha=1.0 here)
        ImGuiCol_TableBorderLight,      // Table inner borders (prefer using Alpha=1.0 here)
        ImGuiCol_TableRowBg,            // Table row background (even rows)
        ImGuiCol_TableRowBgAlt,         // Table row background (odd rows)
        ImGuiCol_TextSelectedBg,
        ImGuiCol_DragDropTarget,        // Rectangle highlighting a drop target
        ImGuiCol_NavHighlight,          // Gamepad/keyboard: current highlighted item
        ImGuiCol_NavWindowingHighlight, // Highlight window when using CTRL+TAB
        ImGuiCol_NavWindowingDimBg,     // Darken/colorize entire screen behind the CTRL+TAB window list, when active
        ImGuiCol_ModalWindowDimBg,      // Darken/colorize entire screen behind a modal window, when one is active
        ImGuiCol_COUNT
        };
        
    extern("libjoyecs", "je_gui_push_style_color")
        public func PushStyleColor(item: ImGuiCol, col: Color32RGBA)=> void;
        
    extern("libjoyecs", "je_gui_pop_style_color")
        public func PopStyleColor(n: int)=> void;
        
    using DrawListT = handle
    {
        extern("libjoyecs", "je_gui_draw_list_add_text")
            public func AddText(self: DrawListT, pos: ImVec2, color: Color32RGBA, text: string)=> void;
            
        extern("libjoyecs", "je_gui_draw_list_add_image")
            public func AddImage(self: DrawListT, from: ImVec2, to: ImVec2, tex: graphic::texture, color: Color32RGBA)=> void;
            
        extern("libjoyecs", "je_gui_draw_list_add_line")
            public func AddLine(self: DrawListT, from: ImVec2, to: ImVec2, color: Color32RGBA, board: real)=> void;
            
        extern("libjoyecs", "je_gui_draw_list_add_rect")
            public func AddRect(self: DrawListT, from: ImVec2, to: ImVec2, color: Color32RGBA, board: real)=> void;
            
        extern("libjoyecs", "je_gui_draw_list_add_rect_filled")
            public func AddRectFilled(self: DrawListT, from: ImVec2, to: ImVec2, color: Color32RGBA)=> void;
            
        extern("libjoyecs", "je_gui_draw_list_add_triangle")
            public func AddTriangle(self: DrawListT, p1: ImVec2, p2: ImVec2, p3: ImVec2, color: Color32RGBA, board: real)=> void;
            
        extern("libjoyecs", "je_gui_draw_list_add_triangle_filled")
            public func AddTriangleFilled(self: DrawListT, p1: ImVec2, p2: ImVec2, p3: ImVec2, color: Color32RGBA)=> void;
            
        extern("libjoyecs", "je_gui_draw_list_add_circle")
            public func AddCircle(self: DrawListT, center: ImVec2, r: real, color: Color32RGBA, board: real)=> void;
            
        extern("libjoyecs", "je_gui_draw_list_add_filled_circle")
            public func AddCircleFilled(self: DrawListT, center: ImVec2, r: real, color: Color32RGBA)=> void;
            
        extern("libjoyecs", "je_gui_draw_list_add_bezier_quad")
            public func AddBezierQuadratic(self: DrawListT, p1: ImVec2, p2: ImVec2, p3: ImVec2, color: Color32RGBA, board: real)=> void;
            
        extern("libjoyecs", "je_gui_draw_list_add_bezier_cubic")
            public func AddBezierCubic(self: DrawListT, p1: ImVec2, p2: ImVec2, p3: ImVec2, p4: ImVec2, color: Color32RGBA, board: real)=> void;
    }
    extern("libjoyecs", "je_gui_get_window_draw_list")
        public func GetWindowDrawList()=> DrawListT;
        
    extern("libjoyecs", "je_gui_imagebutton")
        public func ImageButton(label: string, tex: je::graphic::texture)=> bool;
    extern("libjoyecs", "je_gui_imagebutton_scale")
        public func ImageButtonScale(label: string, tex: je::graphic::texture, scale: real)=> bool;
    extern("libjoyecs", "je_gui_imagebutton_size")
        public func ImageButtonSize(label: string, tex: je::graphic::texture, width: real, height: real)=> bool;
        
    extern("libjoyecs", "je_gui_content_region_avail")
        public func GetContentRegionAvail()=> ImVec2;
        
    extern("libjoyecs", "je_gui_set_next_window_size_constraints")
        public func SetNextWindowSizeConstraints(minsz: ImVec2, maxsz: ImVec2)=> void;
        
    extern("libjoyecs", "je_gui_set_next_window_size")
        public func SetNextWindowSize(sz: ImVec2)=> void;
        
    extern("libjoyecs", "je_gui_set_next_window_pos")
        public func SetNextWindowPos(pos: ImVec2)=> void;
        
    public enum DragAttribute
    {
        ImGuiDragDropFlags_None                         = 0,
        // BeginDragDropSource() flags
        ImGuiDragDropFlags_SourceNoPreviewTooltip       = 0x0001,   // By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disable this behavior.
        ImGuiDragDropFlags_SourceNoDisableHover         = 0x0002,   // By default, when dragging we clear data so that IsItemHovered() will return false, to avoid subsequent user code submitting tooltips. This flag disable this behavior so you can still call IsItemHovered() on the source item.
        ImGuiDragDropFlags_SourceNoHoldToOpenOthers     = 0x0004,   // Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.
        ImGuiDragDropFlags_SourceAllowNullID            = 0x0008,   // Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.
        ImGuiDragDropFlags_SourceExtern                 = 0x0010,   // External source (from outside of dear imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.
        ImGuiDragDropFlags_SourceAutoExpirePayload      = 0x0020,   // Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged)
        // AcceptDragDropPayload() flags
        ImGuiDragDropFlags_AcceptBeforeDelivery         = 0x0040,  // AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.
        ImGuiDragDropFlags_AcceptNoDrawDefaultRect      = 0x0080,  // Do not draw the default highlight rectangle when hovering over target.
        ImGuiDragDropFlags_AcceptNoPreviewTooltip       = 0x0100,  // Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.
        ImGuiDragDropFlags_AcceptPeekOnly               = ImGuiDragDropFlags_AcceptBeforeDelivery + ImGuiDragDropFlags_AcceptNoDrawDefaultRect,  // For peeking ahead and inspecting the payload before delivery.
    }
    
    extern("libjoyecs", "je_gui_begin_drag_drop_source")
        public func BeginDragDropSource()=> bool;
    extern("libjoyecs", "je_gui_begin_drag_drop_source_attr")
        public func BeginDragDropSourceAttr(attrib: DragAttribute)=> bool;
    extern("libjoyecs", "je_gui_set_drag_drop_payload")
        public func SetDragDropPayload(type: string, data: string)=> bool;
    extern("libjoyecs", "je_gui_end_drag_drop_source")
        public func EndDragDropSource()=> void;
        
    public func DragItem(type: string, payload: string, holddo: ()=>void)
    {
        if (BeginDragDropSource())
        {
            do SetDragDropPayload(type, payload);
            holddo();
            do EndDragDropSource();
        }
    }
    
    extern("libjoyecs", "je_gui_begin_drag_drop_target")
        public func BeginDragDropTarget()=> bool;
    extern("libjoyecs", "je_gui_accept_drag_drop_payload")
        public func AcceptDragDropPayload(type: string)=> option<string>;
    extern("libjoyecs", "je_gui_end_accept_drop_source")
        public func EndDragDropTarget()=> void;
        
    public func AcceptDrag(types: array<string>)=> option<(string, string)>
    {
        if (BeginDragDropTarget())
        {
            let drag_result = types
                ->> \type = (type, AcceptDragDropPayload(type));
                ->  forall(\accept_type_result = accept_result->is_value
                        where (_, accept_result) = accept_type_result;)
                    ->  get(0)
                    ->> \e = (e[0], e[1]->unwrap);
                    ;
                    
            EndDragDropTarget();
            
            return drag_result;
        }
        return option::none;
    }
    
    extern("libjoyecs", "je_gui_set_next_item_open")
        public func SetNextItemOpen(open: bool)=> void;
        
    extern("libjoyecs", "je_gui_begin_tool_tip")
        public func BeginTooltip()=> void;
        
    extern("libjoyecs", "je_gui_end_tool_tip")
        public func EndTooltip()=> void;
        
    extern("libjoyecs", "je_gui_begin_disabled")
        public func BeginDisabled(able: bool) => void;
        
    extern("libjoyecs", "je_gui_end_disabled")
        public func EndDisabled() => void;
        
    extern("libjoyecs", "je_gui_style_get_config_color")
        public func GetStyleColor(item: ImGuiCol)=> (real, real, real, real);
        
    extern("libjoyecs", "je_gui_style_set_config_color")
        public func SetStyleColor(item: ImGuiCol, col: (real, real, real, real))=>void;
        
    extern("libjoyecs", "je_gui_style_set_config_color_dark")
        public func SetStyleColorDark()=>void;
        
    extern("libjoyecs", "je_gui_style_set_config_color_classic")
        public func SetStyleColorClassic()=>void;
        
    extern("libjoyecs", "je_gui_style_set_config_color_light")
        public func SetStyleColorLight()=>void;
        
    public enum DockNodeFlags
    {
        ImGuiDockNodeFlags_None                         = 0,
        ImGuiDockNodeFlags_KeepAliveOnly                = 0x00000001,   //       // Don't display the dockspace node but keep it alive. Windows docked into this dockspace node won't be undocked.
        //ImGuiDockNodeFlags_NoCentralNode              = 0x00000002,   //       // Disable Central Node (the node which can stay empty)
        ImGuiDockNodeFlags_NoDockingOverCentralNode     = 0x00000004,   //       // Disable docking over the Central Node, which will be always kept empty.
        ImGuiDockNodeFlags_PassthruCentralNode          = 0x00000008,   //       // Enable passthru dockspace: 1) DockSpace() will render a ImGuiCol_WindowBg background covering everything excepted the Central Node when empty. Meaning the host window should probably use SetNextWindowBgAlpha(0.0f) prior to Begin() when using this. 2) When Central Node is empty: let inputs pass-through + won't display a DockingEmptyBg background. See demo for details.
        ImGuiDockNodeFlags_NoDockingSplit               = 0x00000010,   //       // Disable other windows/nodes from splitting this node.
        ImGuiDockNodeFlags_NoResize                     = 0x00000020,   // Saved // Disable resizing node using the splitter/separators. Useful with programmatically setup dockspaces.
        ImGuiDockNodeFlags_AutoHideTabBar               = 0x00000040,   //       // Tab bar will automatically hide when there is a single window in the dock node.
        ImGuiDockNodeFlags_NoUndocking                  = 0x00000080,   //       // Disable undocking this node.
    };
    
    extern("libjoyecs", "je_gui_dock_space")
        public func DockSpace(id: int, size: ImVec2, attrib: DockNodeFlags)=> void;
        
    extern("libjoyecs", "je_gui_dock_space_over_viewport")
        public func DockSpaceOverViewport()=> void;
        
    public enum StyleVar
    {
        // Enum name --------------------- // Member in ImGuiStyle structure (see ImGuiStyle for descriptions)
        ImGuiStyleVar_Alpha,               // float     Alpha
        ImGuiStyleVar_DisabledAlpha,       // float     DisabledAlpha
        ImGuiStyleVar_WindowPadding,       // ImVec2    WindowPadding
        ImGuiStyleVar_WindowRounding,      // float     WindowRounding
        ImGuiStyleVar_WindowBorderSize,    // float     WindowBorderSize
        ImGuiStyleVar_WindowMinSize,       // ImVec2    WindowMinSize
        ImGuiStyleVar_WindowTitleAlign,    // ImVec2    WindowTitleAlign
        ImGuiStyleVar_ChildRounding,       // float     ChildRounding
        ImGuiStyleVar_ChildBorderSize,     // float     ChildBorderSize
        ImGuiStyleVar_PopupRounding,       // float     PopupRounding
        ImGuiStyleVar_PopupBorderSize,     // float     PopupBorderSize
        ImGuiStyleVar_FramePadding,        // ImVec2    FramePadding
        ImGuiStyleVar_FrameRounding,       // float     FrameRounding
        ImGuiStyleVar_FrameBorderSize,     // float     FrameBorderSize
        ImGuiStyleVar_ItemSpacing,         // ImVec2    ItemSpacing
        ImGuiStyleVar_ItemInnerSpacing,    // ImVec2    ItemInnerSpacing
        ImGuiStyleVar_IndentSpacing,       // float     IndentSpacing
        ImGuiStyleVar_CellPadding,         // ImVec2    CellPadding
        ImGuiStyleVar_ScrollbarSize,       // float     ScrollbarSize
        ImGuiStyleVar_ScrollbarRounding,   // float     ScrollbarRounding
        ImGuiStyleVar_GrabMinSize,         // float     GrabMinSize
        ImGuiStyleVar_GrabRounding,        // float     GrabRounding
        ImGuiStyleVar_TabRounding,         // float     TabRounding
        ImGuiStyleVar_TabBarBorderSize,    // float     TabBarBorderSize
        ImGuiStyleVar_ButtonTextAlign,     // ImVec2    ButtonTextAlign
        ImGuiStyleVar_SelectableTextAlign, // ImVec2    SelectableTextAlign
        ImGuiStyleVar_SeparatorTextBorderSize,// float  SeparatorTextBorderSize
        ImGuiStyleVar_SeparatorTextAlign,  // ImVec2    SeparatorTextAlign
        ImGuiStyleVar_SeparatorTextPadding,// ImVec2    SeparatorTextPadding
        ImGuiStyleVar_DockingSeparatorSize,// float     DockingSeparatorSize
        ImGuiStyleVar_COUNT,
    };
    
    extern("libjoyecs", "je_gui_push_style_real")
        public func PushStyleReal(style: StyleVar, val: real)=> void;
    extern("libjoyecs", "je_gui_push_style_vec2")
        public func PushStyleVec2(style: StyleVar, val: ImVec2)=> void;
        
    extern("libjoyecs", "je_gui_pop_style_var")
        public func PopStyleVar(n: int)=> void;
        
    extern("libjoyecs", "je_gui_set_window_font_scale")
        public func SetWindowFontScale(factor: real)=> void;
        
    extern("libjoyecs", "je_gui_dummy")
        public func Dummy(sz: ImVec2)=> void;
        
    using CodeEditorContext = gchandle
    {
        public enum PaletteIndex
        {
            Default,
            Keyword,
            Number,
            String,
            CharLiteral,
            Punctuation,
            Preprocessor,
            Identifier,
            KnownIdentifier,
            Type,
            PreprocIdentifier,
            Comment,
            MultiLineComment,
            Background,
            Cursor,
            Selection,
            ErrorMarker,
            Breakpoint,
            LineNumber,
            CurrentLineFill,
            CurrentLineFillInactive,
            CurrentLineEdge,
            Max,
        };
        using LanguageDefinition = gchandle
        {
            extern("libjoyecs", "je_gui_code_editor_language_definition_create")
                public func create(name: string)=> LanguageDefinition;
                
            extern("libjoyecs", "je_gui_code_editor_language_definition_add_keyword")
                public func AddKeyword(
                    self: LanguageDefinition, keyword: string)=> void;
                    
            extern("libjoyecs", "je_gui_code_editor_language_definition_add_identifier")
                public func AddIdentifier(
                    self: LanguageDefinition,
                    ident: string,
                    declare: string,
                    row: int,
                    col: int)=> void;
                    
            extern("libjoyecs", "je_gui_code_editor_language_definition_add_token_regex")
                public func AddTokenRegex(
                    self: LanguageDefinition,
                    regex: string,
                    pidx: PaletteIndex)=> void;
                    
            extern("libjoyecs", "je_gui_code_editor_language_definition_set_mlcomment")
                public func SetMultilineComment(
                    self: LanguageDefinition, begin: string, end: string)=> void;
                    
            extern("libjoyecs", "je_gui_code_editor_language_definition_set_slcomment")
                public func SetSingleLineComment(
                    self: LanguageDefinition, text: string)=> void;
                    
            extern("libjoyecs", "je_gui_code_editor_language_definition_set_case_sensitive")
                public func SetCaseSensitive(
                    self: LanguageDefinition, able: bool)=> void;
                    
            extern("libjoyecs", "je_gui_code_editor_language_definition_set_auto_indentation")
                public func SetAutoIndentation(
                    self: LanguageDefinition, able: bool)=> void;
                    
            extern("libjoyecs", "je_gui_code_editor_language_definition_set_preproc_char")
                public func SetPreprocChar(
                    self: LanguageDefinition, ch: cchar)=> void;
        }
        
        extern("libjoyecs", "je_gui_code_editor_create")
            public func create()=> CodeEditorContext;
            
        extern("libjoyecs", "je_gui_code_editor_get_text")
            public func GetText(self: CodeEditorContext)=> string;
        extern("libjoyecs", "je_gui_code_editor_set_text")
            public func SetText(self: CodeEditorContext, text: string)=> void;
            
        extern("libjoyecs", "je_gui_code_editor_set_language_definition")
            public func SetLanguageDefinition(self: CodeEditorContext, ldef: LanguageDefinition)=> void;
            
        extern("libjoyecs", "je_gui_code_editor_undoable")
            public func CanUndo(self: CodeEditorContext)=> bool;
        extern("libjoyecs", "je_gui_code_editor_redoable")
            public func CanRedo(self: CodeEditorContext)=> bool;
            
        extern("libjoyecs", "je_gui_code_editor_undo")
            public func Undo(self: CodeEditorContext)=> void;
        extern("libjoyecs", "je_gui_code_editor_redo")
            public func Redo(self: CodeEditorContext)=> void;
            
        extern("libjoyecs", "je_gui_code_editor_get_cursor_pos")
            public func GetCursorPosition(self: CodeEditorContext)=> (int, int);
        extern("libjoyecs", "je_gui_code_editor_set_cursor_pos")
            public func SetCursorPosition(self: CodeEditorContext, pos: (int, int))=> void;
            
        extern("libjoyecs", "je_gui_code_editor_insert_text")
            public func InsertText(self: CodeEditorContext, text: string)=> void;
            
        extern("libjoyecs", "je_gui_code_editor_copy")
            public func Copy(self: CodeEditorContext)=> void;
        extern("libjoyecs", "je_gui_code_editor_cut")
            public func Cut(self: CodeEditorContext)=> void;
        extern("libjoyecs", "je_gui_code_editor_paste")
            public func Paste(self: CodeEditorContext)=> void;
        extern("libjoyecs", "je_gui_code_editor_delete")
            public func Delete(self: CodeEditorContext)=> void;
    }
    extern("libjoyecs", "je_gui_code_editor_show")
        public func CodeEditor(ctx: CodeEditorContext, label: string)=> void;
    extern("libjoyecs", "je_gui_code_editor_show_size")
        public func CodeEditorSize(ctx: CodeEditorContext, label: string, sz: ImVec2, board: bool)=> void;
        
    namespace node_editor
    {
        using EditorContext = gchandle
        {
            public func close(self: EditorContext)
            {
                return self: gchandle->close;
            }
        }
        
        public using NodeId = int;
        public using PinId = int;
        public using LinkId = int;
        
        extern("libjoyecs", "je_gui_node_editor_context_create")
            public func CreateContext()=> EditorContext;
            
        extern("libjoyecs", "je_gui_node_editor_begin")
            public func Begin(label: string, ctx: EditorContext)=> void;
            
        extern("libjoyecs", "je_gui_node_editor_end")
            public func End()=> void;
            
        extern("libjoyecs", "je_gui_node_editor_begin_node")
            public func BeginNode(id: NodeId)=> void;
            
        extern("libjoyecs", "je_gui_node_editor_end_node")
            public func EndNode()=> void;
            
        extern("libjoyecs", "je_gui_node_editor_begin_input_pin")
            public func BeginInputPin(id: PinId)=> void;
            
        extern("libjoyecs", "je_gui_node_editor_begin_output_pin")
            public func BeginOutputPin(id: PinId)=> void;
            
        extern("libjoyecs", "je_gui_node_editor_end_pin")
            public func EndPin()=> void;
            
        extern("libjoyecs", "je_gui_node_editor_pin_pivot_rect")
            public func PinPivotRect(a: ImVec2, b: ImVec2)=> void;
            
        extern("libjoyecs", "je_gui_node_editor_pin_rect")
            public func PinRect(a: ImVec2, b: ImVec2)=> void;
            
        extern("libjoyecs", "je_gui_node_editor_link")
            public func Link(linkid: LinkId, output_pinid: PinId, input_pinid: PinId, color: Color32RGBA, board: real)=> void;
            
        extern("libjoyecs", "je_gui_node_editor_begin_create")
            public func BeginCreate(color: Color32RGBA, board: real)=> bool;
            
        extern("libjoyecs", "je_gui_node_editor_end_create")
            public func EndCreate()=> void;
            
        extern("libjoyecs", "je_gui_node_editor_begin_delete")
            public func BeginDelete()=> bool;
            
        extern("libjoyecs", "je_gui_node_editor_end_delete")
            public func EndDelete()=> void;
            
        extern("libjoyecs", "je_gui_node_editor_accept_new_item")
            public func AcceptNewItem()=> bool;
            
        extern("libjoyecs", "je_gui_node_editor_reject_new_item")
            public func RejectNewItem()=> void;
            
        extern("libjoyecs", "je_gui_node_editor_accept_new_item_color")
            public func AcceptNewItemColor(color: Color32RGBA, board: real)=> bool;
            
        extern("libjoyecs", "je_gui_node_editor_reject_new_item_color")
            public func RejectNewItemColor(color: Color32RGBA, board: real)=> void;
            
        extern("libjoyecs", "je_gui_node_editor_accept_deleted_item")
            public func AcceptDeletedItem()=> bool;
            
        extern("libjoyecs", "je_gui_node_editor_reject_deleted_item")
            public func RejectDeletedItem()=> void;
            
        extern("libjoyecs", "je_gui_node_editor_query_new_link")
            public func QueryNewLink()=> option<(PinId, PinId)>;
            
        extern("libjoyecs", "je_gui_node_editor_query_new_node")
            public func QueryNewNode()=> option<PinId>;
            
        extern("libjoyecs", "je_gui_node_editor_query_deleted_node")
            public func QueryDeletedNode()=> option<NodeId>;
            
        extern("libjoyecs", "je_gui_node_editor_query_deleted_link")
            public func QueryDeletedLink()=> option<LinkId>;
            
        public enum StyleColor
        {
            StyleColor_Bg,
            StyleColor_Grid,
            StyleColor_NodeBg,
            StyleColor_NodeBorder,
            StyleColor_HovNodeBorder,
            StyleColor_SelNodeBorder,
            StyleColor_NodeSelRect,
            StyleColor_NodeSelRectBorder,
            StyleColor_HovLinkBorder,
            StyleColor_SelLinkBorder,
            StyleColor_HighlightLinkBorder,
            StyleColor_LinkSelRect,
            StyleColor_LinkSelRectBorder,
            StyleColor_PinRect,
            StyleColor_PinRectBorder,
            StyleColor_Flow,
            StyleColor_FlowMarker,
            StyleColor_GroupBg,
            StyleColor_GroupBorder,
            
            StyleColor_Count,
        }
        
        extern("libjoyecs", "je_gui_node_editor_push_style_color")
            public func PushStyleColor(style: StyleColor, color: Color32RGBA)=> void;
            
        extern("libjoyecs", "je_gui_node_editor_pop_style_color")
            public func PopStyleColor(n: int)=> void;
            
        extern("libjoyecs", "je_gui_node_editor_delete_node")
            public func DeleteNode(id: NodeId)=> bool;
            
        extern("libjoyecs", "je_gui_node_editor_get_node_position")
            public func GetNodePosition(id: NodeId)=> (real, real);
            
        extern("libjoyecs", "je_gui_node_editor_set_node_position")
            public func SetNodePosition(id: NodeId, pos: (real, real))=> void;
            
        extern("libjoyecs", "je_gui_node_editor_delete_link")
            public func DeleteLink(id: LinkId)=> bool;
            
        extern("libjoyecs", "je_gui_node_editor_get_hovered_node")
            public func GetHoveredNode()=> option<NodeId>;
            
        extern("libjoyecs", "je_gui_node_editor_get_hovered_pin")
            public func GetHoveredPin()=> option<PinId>;
            
        extern("libjoyecs", "je_gui_node_editor_get_hovered_link")
            public func GetHoveredLink()=> option<LinkId>;
            
        extern("libjoyecs", "je_gui_node_editor_is_node_selected")
            public func IsNodeSelected()=> option<LinkId>;
            
        extern("libjoyecs", "je_gui_node_editor_canvas_to_screen")
            public func CanvasToScreen(pos: (real, real))=> (real, real);
            
        extern("libjoyecs", "je_gui_node_editor_screen_to_canvas")
            public func ScreenToCanvas(pos: (real, real))=> (real, real);
            
        extern("libjoyecs", "je_gui_node_editor_suspend")
            public func Suspend()=> void;
            
        extern("libjoyecs", "je_gui_node_editor_resume")
            public func Resume()=> void;
    }
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    extern("libjoyecs", "je_gui_launch", slow)
        public func launch_coroutine(coloop: ()=> void)=> void;
        
    namespace unsafe
    {
        extern("libjoyecs", "je_gui_stop_all_work")
            public func shutdown()=> void;
    }
    
    public func launch(gui_func: ()=> bool)=> void
    {
        return launch_coroutine(func(){
                while (gui_func())
                    std::yield();
            });
    }
    
    namespace input
    {
        extern("libjoyecs", "je_gui_get_input_state")
            public func keystate(kcode: ImGuiKey)=> (bool, bool);
    }
    
    extern("libjoyecs", "je_gui_register_exit_callback")
        public func register_exit_callback(callback: ()=> bool)=> void;
        
    extern("libjoyecs", "je_gui_unregister_exit_callback")
        public func unregister_exit_callback()=> void;
        
    extern("libjoyecs", "je_gui_set_font")
        public func set_font(font: option<string>, latin_font: option<string>, size: int)=> void;
}

import woo::std;

import pkg::woshader;
import pkg::interface;
import pkg::iterator;
import pkg::worst;
import pkg::buffer;

namespace je::shader
{
    public let NEAREST = woshader::Sampler2D::filter::NEAREST;
    public let LINEAR = woshader::Sampler2D::filter::LINEAR;
    public let CLAMP = woshader::Sampler2D::wrap::CLAMP;
    public let REPEAT = woshader::Sampler2D::wrap::REPEAT;
    
    public let OFF = ZConfig::OFF;
    public let NEVER = ZConfig::NEVER;
    public let LESS = ZConfig::LESS;
    public let EQUAL = ZConfig::EQUAL;
    public let GREATER = ZConfig::GREATER;
    public let LESS_EQUAL = ZConfig::LESS_EQUAL;
    public let NOT_EQUAL = ZConfig::NOT_EQUAL;
    public let GREATER_EQUAL = ZConfig::GREATER_EQUAL;
    public let ALWAYS = ZConfig::ALWAYS;
    
    public let DISABLE = GConfig::DISABLE;
    public let ENABLE = GConfig::ENABLE;
    
    public let ADD = BlendEquation::ADD;
    public let SUBTRACT = BlendEquation::SUBTRACT;
    public let REVERSE_SUBTRACT = BlendEquation::REVERSE_SUBTRACT;
    public let MIN = BlendEquation::MIN;
    public let MAX = BlendEquation::MAX;
    
    public let ZERO = BlendConfig::ZERO;
    public let ONE = BlendConfig::ONE;
    public let SRC_COLOR = BlendConfig::SRC_COLOR;
    public let SRC_ALPHA = BlendConfig::SRC_ALPHA;
    public let ONE_MINUS_SRC_ALPHA = BlendConfig::ONE_MINUS_SRC_ALPHA;
    public let ONE_MINUS_SRC_COLOR = BlendConfig::ONE_MINUS_SRC_COLOR;
    public let DST_COLOR = BlendConfig::DST_COLOR;
    public let DST_ALPHA = BlendConfig::DST_ALPHA;
    public let ONE_MINUS_DST_ALPHA = BlendConfig::ONE_MINUS_DST_ALPHA;
    public let ONE_MINUS_DST_COLOR = BlendConfig::ONE_MINUS_DST_COLOR;
    
    public let NONE = CullConfig::NONE;
    public let FRONT = CullConfig::FRONT;
    public let BACK = CullConfig::BACK;
    
    enum ZConfig
    {
        OFF = 0,
        NEVER,
        LESS,       /* DEFAULT */
        EQUAL,
        LESS_EQUAL,
        GREATER,
        NOT_EQUAL,
        GREATER_EQUAL,
        ALWAYS,
    }
    enum GConfig
    {
        DISABLE = 0,
        ENABLE,
    }
    enum BlendEquation
    {
        ADD = 0,      /* DEFAULT */
        SUBTRACT,
        REVERSE_SUBTRACT,
        MIN,
        MAX,
    }
    enum BlendConfig
    {
        ZERO = 0,       /* DEFAULT SRC = ONE, DST = ZERO (DISABLE BLEND.) */
        ONE,
        
        SRC_COLOR,
        SRC_ALPHA,
        
        ONE_MINUS_SRC_ALPHA,
        ONE_MINUS_SRC_COLOR,
        
        DST_COLOR,
        DST_ALPHA,
        
        ONE_MINUS_DST_ALPHA,
        ONE_MINUS_DST_COLOR,
    }
    enum CullConfig
    {
        NONE = 0,       /* DEFAULT */
        FRONT,
        BACK,
    }
    
    using ShaderConfig = struct{
        shared: mut bool,
        ztest     : mut ZConfig,
        zwrite    : mut GConfig,
        blend_equation: mut BlendEquation,
        blend_src : mut BlendConfig,
        blend_dst : mut BlendConfig,
        cull      : mut CullConfig,
    };
    let configs = ShaderConfig
    {
        shared = mut false,
        ztest = mut LESS,
        zwrite = mut ENABLE,
        blend_equation = mut ADD,
        blend_src = mut ONE,
        blend_dst = mut ZERO,
        cull = mut NONE,
    };
    
    public func SHARED(enable: bool)
    {
        shader::configs.shared = enable;
    }
    public func ZTEST(zconfig: ZConfig)
    {
        shader::configs.ztest = zconfig;
    }
    public func ZWRITE(zwrite: GConfig)
    {
        shader::configs.zwrite = zwrite;
    }
    public func BLEND_EQUATION(equation: BlendEquation)
    {
        shader::configs.blend_equation = equation;
    }
    public func BLEND(src: BlendConfig, dst: BlendConfig)
    {
        shader::configs.blend_src = src;
        shader::configs.blend_dst = dst;
    }
    public func CULL(cull: CullConfig)
    {
        shader::configs.cull = cull;
    }
    
    using HLSLForGlslang = struct{
        generated_vertex_src: mut option<string>,
        generated_fragment_src: mut option<string>,
        
        vertex_in_layout: vec<woshader::Type>,
        samplers: vec<woshader::Sampler2D>,
        texture_passes: vec<(string, int /* pass */, int /* sampler id */)>,
        uniform_variables: vec<(string, woshader::Type, woshader::ShaderValueImm)>,
        uniform_blocks: vec<(string, int)>,
        
        alphatest: mut bool,
    }
    {
        using woshader;
        
        public func create()=> HLSLForGlslang
            where require!(HLSLForGlslang: IShaderGenerator);
        {
            return HLSLForGlslang{
                generated_vertex_src = mut option::none,
                generated_fragment_src = mut option::none,
                
                vertex_in_layout = []mut,
                samplers = []mut,
                texture_passes = []mut,
                uniform_variables = []mut,
                uniform_blocks = []mut,
                
                alphatest = mut false,
            };
        }
        public func get_texture_info_by_pass(self: HLSLForGlslang, pass: int)
        {
            let fnd = self.texture_passes->find_if(\(_, p, _) = p == pass;);
            return fnd->>\idx = self.texture_passes[idx];;
        }
        public func get_texture_info_by_name(self: HLSLForGlslang, uname: string)
        {
            let fnd = self.texture_passes->find_if(\(n, _, _) = n == uname;);
            return fnd->>\idx = self.texture_passes[idx];;
        }
        public func pre_generate(
            _: HLSLForGlslang, c: ShaderGeneratorContext)=> void
        {
            // Add an empty line to pervent predef in glslang failed.
            c->append_line("// Generated by HLSLForGlslang.");
        }
        func append_spirv_attrib(c: ShaderGeneratorContext, attrib: string)
        {
            c->append_line("#ifdef GLSLANG_HLSL_TO_SPIRV");
            c->append_line(F"    [[{attrib}]]");
            c->append_line("#endif");
        }
        func get_type_name_with_type(type: Type)
        {
            if (type == Type::Float)
                return "float";
            else if (type == Type::Float2)
                return "float2";
            else if (type == Type::Float3)
                return "float3";
            else if (type == Type::Float4)
                return "float4";
            else if (type == Type::Float2x2)
                return "float2x2";
            else if (type == Type::Float3x3)
                return "float3x3";
            else if (type == Type::Float4x4)
                return "float4x4";
            else if (type == Type::Integer)
                return "int";
            else if (type == Type::Integer2)
                return "int2";
            else if (type == Type::Integer3)
                return "int3";
            else if (type == Type::Integer4)
                return "int4";
            else if (type == Type::Texture2D)
                return "Texture2D";
            else if (type == Type::Structure)
                return "struct";
            else
                return std::panic("unsupported type");
        }
        
        public func generate_struct_declare(
            _: HLSLForGlslang, c: ShaderGeneratorContext, struct_decl: StructureDefine)=> void
        {
            c->append_line(F"struct {struct_decl.name} \{");
            for (let (field_name, field) : struct_decl->get_ordered_fields)
            {
                let mut hlsl_type_name = get_type_name_with_type(field.type);
                if (hlsl_type_name == "struct")
                    hlsl_type_name = field.struct_type->unwrap.name;
                    
                c->append_line(F"    {hlsl_type_name}{
                    field.array_elem_count->>\v = "[" + v: string + "]";->or("")} {field_name};");
            }
            c->append_line("};");
        }
        public func generate_uniform_declare(
            self: HLSLForGlslang, c: ShaderGeneratorContext, uniforms: UniformVariableRecord)=> void
        {
            // Declare samplers
            let sorted_samplers = uniforms.samplers->unmapping
                |> std::sort(\(_, a), (_, b) = a < b;);
                
            for (let (sampler, id) : sorted_samplers)
            {
                assert(id == self.samplers->len);
                self.samplers->add(sampler);
                
                append_spirv_attrib(c, F"vk::binding({id}, 3)");
                c->append_line(F"SamplerState _s{id}: register(s{id});");
            }
            
            // Declare uniform variables
            //if (uniforms.defined_uniforms->iter |> iterator::count_if(\(_, uniform_var) = uniform_var.used;) > 0)
            
            let uniform_textures = []mut: vec<mut (texture2d::base, string)>;
            append_spirv_attrib(c, "vk::binding(0, 0)");
            c->append_line("cbuffer SHADER_UNIFORM: register(b0) {");
            for (let (name, uniform_var) : uniforms.defined_uniforms
                -> unmapping |> std::sort(
                    func((_, a), (_, b))
                    {
                        if (a.type == b.type)
                            return a.index < b.index;
                        return a.type < b.type;
                    }))
            {
                if (uniform_var.type == Type::Texture2D)
                {
                    match (uniform_var.default_value)
                    {
                        Texture2D(b)?
                            uniform_textures->add(mut (b, name));
                        _?
                            std::panic("Texture2D uniform must have default value.");
                    }
                }
                else
                {
                    self.uniform_variables->add((name, uniform_var.type, uniform_var.default_value));
                    
                    let mut hlsl_type_name = get_type_name_with_type(uniform_var.type);
                    assert_message(
                        hlsl_type_name != "struct",
                        F"Uniform variable `{name}` has unsupported type.");
                        
                    c->append_line(F"    {hlsl_type_name} {name};");
                }
            }
            c->append_line("};");
            
            std::sort_in_place(uniform_textures, \a, b = a[0].0 < b[0].0;);
            for (let ((pass, sampler), name): uniform_textures)
            {
                let sampler_id = sorted_samplers->find_if(\(s, _) = std::is_same(s, sampler);)->unwrap;
                self.texture_passes->add((name, pass, sampler_id));
                
                append_spirv_attrib(c, F"vk::binding({pass}, 2)");
                c->append_line(F"Texture2D {name}: register(t{pass});");
            }
        }
        public func generate_uniform_block_declare(
            self: HLSLForGlslang, c: ShaderGeneratorContext, uniform_block: UniformBlock)=> void
        {
            append_spirv_attrib(c, F"vk::binding({uniform_block.binding}, 1)");
            
            let uniform_block_name = F"UNIFORM_BLOCK_{uniform_block.binding}";
            
            c->append_line(F"cbuffer {uniform_block_name}: register(b{uniform_block.binding + 1}) \{");
            for (let (_, field) : uniform_block->get_sorted_fields)
            {
                let mut hlsl_type_name = get_type_name_with_type(field.type);
                if (hlsl_type_name == "struct")
                    hlsl_type_name = field.struct_type->unwrap.name;
                    
                c->append_line(F"    {hlsl_type_name}{
                    field.array_elem_count->>\v = "[" + v: string + "]";->or("")} {field.name};");
            }
            c->append_line("};");
            self.uniform_blocks->add((uniform_block_name, uniform_block.binding));
        }
        enum function_type
        {
            NORMAL,
            VERTEX,
            FRAGMENT,
        }
        func apply_eval_shader_imm<T>(
            self: HLSLForGlslang,
            c: ShaderGeneratorContext,
            typename: string,
            vname: string,
            v: T,
            ftype: function_type)
        {
            do self;
            do c;
            do typename;
            do vname;
            do ftype;
            
            if (v is float::base)
                return ShaderGeneratorContext::EvalResult::Direct(v as real: string);
            else if (v is float2::base)
            {
                let (xv, yv) = v as (real, real);
                return ShaderGeneratorContext::EvalResult::Direct(
                    F"float2({xv}, {yv})");
            }
            else if (v is float3::base)
            {
                let (xv, yv, zv) = v as (real, real, real);
                return ShaderGeneratorContext::EvalResult::Direct(
                    F"float3({xv}, {yv}, {zv})");
            }
            else if (v is float4::base)
            {
                let (xv, yv, zv, wv) = v as (real, real, real, real);
                return ShaderGeneratorContext::EvalResult::Direct(
                    F"float4({xv}, {yv}, {zv}, {wv})");
            }
            else if (v is float2x2::base)
            {
                return ShaderGeneratorContext::EvalResult::Direct(
                    F"float2x2({v[0][0]}, {v[0][1]}, {v[1][0]}, {v[1][1]})");
            }
            else if (v is float3x3::base)
            {
                return ShaderGeneratorContext::EvalResult::Direct(
                    F"float3x3({v[0][0]}, {v[0][1]}, {v[0][2]}, "
                        + F"{v[1][0]}, {v[1][1]}, {v[1][2]}, "
                        + F"{v[2][0]}, {v[2][1]}, {v[2][2]})");
            }
            else if (v is float4x4::base)
            {
                return ShaderGeneratorContext::EvalResult::Direct(
                    F"float4x4({v[0][0]}, {v[0][1]}, {v[0][2]}, {v[0][3]}, "
                        + F"{v[1][0]}, {v[1][1]}, {v[1][2]}, {v[1][3]}, "
                        + F"{v[2][0]}, {v[2][1]}, {v[2][2]}, {v[2][3]}, "
                        + F"{v[3][0]}, {v[3][1]}, {v[3][2]}, {v[3][3]})");
            }
            else if (v is integer::base)
                return ShaderGeneratorContext::EvalResult::Direct((v as int): string);
            else if (v is integer2::base)
            {
                let (xv, yv) = v as (int, int);
                return ShaderGeneratorContext::EvalResult::Direct(
                    F"int2({xv}, {yv})");
            }
            else if (v is integer3::base)
            {
                let (xv, yv, zv) = v as (int, int, int);
                return ShaderGeneratorContext::EvalResult::Direct(
                    F"int3({xv}, {yv}, {zv})");
            }
            else if (v is integer4::base)
            {
                let (xv, yv, zv, wv) = v as (int, int, int, int);
                return ShaderGeneratorContext::EvalResult::Direct(
                    F"int4({xv}, {yv}, {zv}, {wv})");
            }
            else if (v is texture2d::base)
            {
                return ShaderGeneratorContext::EvalResult::Direct(
                    self->get_texture_info_by_pass(v.0)->unwrap.0);
            }
            else
                return std::panic("Unsupported imm type");
        }
        func get_texture_binded_sampler_expr(self: HLSLForGlslang, sv: ShaderValue)
        {
            match (sv)
            {
                Texture2D(tv)?
                {
                    match (tv)
                    {
                        Imm((_, sampler2d))?
                            return_value! F"_s{self.samplers->find(sampler2d)->unwrap}";
                        ShaderIn(inid)?
                            return_value! F"_a{inid}_sampler";
                        Uniform(uname)?
                            return_value! F"_s{self->get_texture_info_by_name(uname)->unwrap.2}";
                        _?
                            std::panic("Unacceptable texture2d formal.");
                    }
                }
                _?;
            }
            throw!;
        }
        func apply_eval_shader_operate(
            self: HLSLForGlslang,
            c: ShaderGeneratorContext,
            typename: string,
            vname: string,
            op: ShaderOperate,
            ftype: function_type)=> ShaderGeneratorContext::EvalResult
        {
            match (op)
            {
                builtin_call((builtin_func, args))?
                {
                    if (builtin_func == BuiltinFunc::Operator_Add
                        ||builtin_func == BuiltinFunc::Operator_Sub
                        ||builtin_func == BuiltinFunc::Operator_Mul
                        ||builtin_func == BuiltinFunc::Operator_Div
                        ||builtin_func == BuiltinFunc::Operator_Mod)
                    {
                        static let OPERATOR_NAMES = {
                            [BuiltinFunc::Operator_Add] = "+",
                            [BuiltinFunc::Operator_Sub] = "-",
                            [BuiltinFunc::Operator_Mul] = "*",
                            [BuiltinFunc::Operator_Div] = "/",
                            [BuiltinFunc::Operator_Mod] = "%",
                        };
                        
                        if (args->len != 2)
                            return std::panic("Binary operator needs 2 arguments.");
                            
                        let lhs = self->eval(c, args[0], ftype);
                        let rhs = self->eval(c, args[1], ftype);
                        let op_name = OPERATOR_NAMES[builtin_func];
                        
                        return ShaderGeneratorContext::EvalResult::Decl(
                            F"{typename} {vname} = {lhs} {op_name} {rhs};");
                    }
                    else if (builtin_func == BuiltinFunc::Operate_Alphatest)
                    {
                        self.alphatest = true;
                        
                        let v = self->eval(c, args[0], ftype);
                        return ShaderGeneratorContext::EvalResult::Decl(
                            F"{typename} {vname} = {v};\nif ({vname}.a <= 0.0) discard;");
                    }
                    else if (builtin_func == BuiltinFunc::Operate_Negative)
                    {
                        let v = self->eval(c, args[0], ftype);
                        return ShaderGeneratorContext::EvalResult::Direct(
                            F"- {v}");
                    }
                    else if (builtin_func == BuiltinFunc::Operate_Tex2D)
                    {
                        let tex = self->eval(c, args[0], ftype);
                        let uv = self->eval(c, args[1], ftype);
                        
                        let sampler = self->get_texture_binded_sampler_expr(args[0])->unwrap;
                        return ShaderGeneratorContext::EvalResult::Decl(
                            F"{typename} {vname} = {tex}.Sample({sampler}, {uv});");
                    }
                    else
                    {
                        static let BUILTIN_FUNC_NAMES = {
                            [BuiltinFunc::Operator_Matrix_Mul] = "mul",
                            [BuiltinFunc::Operator_Make_Float2] = "float2",
                            [BuiltinFunc::Operator_Make_Float3] = "float3",
                            [BuiltinFunc::Operator_Make_Float4] = "float4",
                            [BuiltinFunc::Operator_Make_Integer2] = "int2",
                            [BuiltinFunc::Operator_Make_Integer3] = "int3",
                            [BuiltinFunc::Operator_Make_Integer4] = "int4",
                            [BuiltinFunc::Operator_Make_Float2x2] = "float2x2",
                            [BuiltinFunc::Operator_Make_Float3x3] = "float3x3",
                            [BuiltinFunc::Operator_Make_Float4x4] = "float4x4",
                            [BuiltinFunc::Operate_Step] = "step",
                            [BuiltinFunc::Operate_Lerp] = "lerp",
                            [BuiltinFunc::Operate_Sin] = "sin",
                            [BuiltinFunc::Operate_Cos] = "cos",
                            [BuiltinFunc::Operate_Tan] = "tan",
                            [BuiltinFunc::Operate_Sinh] = "sinh",
                            [BuiltinFunc::Operate_Cosh] = "cosh",
                            [BuiltinFunc::Operate_Tanh] = "tanh",
                            [BuiltinFunc::Operate_Asin] = "asin",
                            [BuiltinFunc::Operate_Acos] = "acos",
                            [BuiltinFunc::Operate_Atan] = "atan",
                            [BuiltinFunc::Operate_Atan2] = "atan2",
                            [BuiltinFunc::Operate_Abs] = "abs",
                            [BuiltinFunc::Operate_Sign] = "sign",
                            [BuiltinFunc::Operate_Pow] = "pow",
                            [BuiltinFunc::Operate_Exp] = "exp",
                            [BuiltinFunc::Operate_Max] = "max",
                            [BuiltinFunc::Operate_Min] = "min",
                            [BuiltinFunc::Operate_Clamp] = "clamp",
                            [BuiltinFunc::Operate_Floor] = "floor",
                            [BuiltinFunc::Operate_Ceil] = "ceil",
                            [BuiltinFunc::Operate_Fract] = "fract",
                            [BuiltinFunc::Operate_Sqrt] = "sqrt",
                            [BuiltinFunc::Operate_Normalize] = "normalize",
                            [BuiltinFunc::Operate_Dot] = "dot",
                            [BuiltinFunc::Operate_Cross] = "cross",
                            [BuiltinFunc::Operate_Length] = "length",
                            [BuiltinFunc::Operate_Distance] = "distance",
                            [BuiltinFunc::Operate_Loge] = "log",
                            [BuiltinFunc::Operate_Log2] = "log2",
                            [BuiltinFunc::Operate_Log10] = "log10",
                            [BuiltinFunc::Operate_Ddx] = "ddx",
                            [BuiltinFunc::Operate_Ddy] = "ddy",
                        };
                        
                        let arglist = args->iter
                            |> iterator::map(\arg = self->eval(c, arg, ftype);)
                            |> iterator::reduce(\l, r = l + ", " + r;)
                            -> or("");
                            
                        let mut func_name = BUILTIN_FUNC_NAMES[builtin_func];
                        if (args->len == 1 &&(builtin_func == BuiltinFunc::Operator_Make_Float2x2
                                || builtin_func == BuiltinFunc::Operator_Make_Float3x3
                                || builtin_func == BuiltinFunc::Operator_Make_Float4x4))
                        {
                            func_name = F"({func_name})";
                        }
                        
                        return ShaderGeneratorContext::EvalResult::Decl(
                            F"{typename} {vname} = {func_name}({arglist});");
                    }
                }
                user_call((fname, args))?
                {
                    let arglist = args->iter
                        |> iterator::map(
                            \arg = self->eval(c, arg, ftype)
                                + self->get_texture_binded_sampler_expr(arg)->map_or(\v = F", {v}";, "")
                                ;)
                        |> iterator::reduce(\l, r = l + ", " + r;)
                        -> or("");
                        
                    c->use_function(fname);
                    
                    return ShaderGeneratorContext::EvalResult::Decl(
                        F"{typename} {vname} = {fname}({arglist});");
                }
                index((sv, index))?
                {
                    return ShaderGeneratorContext::EvalResult::Direct(
                        F"{self->eval(c, sv, ftype)}.{index}");
                }
                indexn((sv, index))?
                {
                    return ShaderGeneratorContext::EvalResult::Direct(
                        F"{self->eval(c, sv, ftype)}[{self->eval(c, index, ftype)}]");
                }
            }
        }
        func apply_eval_typed_shader_value<T>(
            self: HLSLForGlslang,
            c: ShaderGeneratorContext,
            typename: string,
            vname: string,
            v: T,
            ftype: function_type)=> ShaderGeneratorContext::EvalResult
        {
            match (v)
            {
                Imm(imm)? return self->apply_eval_shader_imm(c, typename, vname, imm, ftype);
                Operate(op)? return self->apply_eval_shader_operate(c, typename, vname, op, ftype);
                Uniform(uname)? return ShaderGeneratorContext::EvalResult::Direct(uname);
                ShaderIn(idx)?
                {
                    if (ftype == function_type::VERTEX)
                        return ShaderGeneratorContext::EvalResult::Direct(F"_vin._v{idx}");
                    else if (ftype == function_type::FRAGMENT)
                        return ShaderGeneratorContext::EvalResult::Direct(F"_v2f._v{idx}");
                    return ShaderGeneratorContext::EvalResult::Direct(F"_a{idx}");
                }
            }
        }
        func apply_eval_shader_value(
            self: HLSLForGlslang,
            c: ShaderGeneratorContext,
            vname: string,
            v: ShaderValue,
            ftype: function_type)=> ShaderGeneratorContext::EvalResult
        {
            match (v)
            {
                Float(f)? return self->apply_eval_typed_shader_value(c, "float", vname, f, ftype);
                Float2(f)? return self->apply_eval_typed_shader_value(c, "float2", vname, f, ftype);
                Float3(f)? return self->apply_eval_typed_shader_value(c, "float3", vname, f, ftype);
                Float4(f)? return self->apply_eval_typed_shader_value(c, "float4", vname, f, ftype);
                Float2x2(f)? return self->apply_eval_typed_shader_value(c, "float2x2", vname, f, ftype);
                Float3x3(f)? return self->apply_eval_typed_shader_value(c, "float3x3", vname, f, ftype);
                Float4x4(f)? return self->apply_eval_typed_shader_value(c, "float4x4", vname, f, ftype);
                Int(i)? return self->apply_eval_typed_shader_value(c, "int", vname, i, ftype);
                Int2(i)? return self->apply_eval_typed_shader_value(c, "int2", vname, i, ftype);
                Int3(i)? return self->apply_eval_typed_shader_value(c, "int3", vname, i, ftype);
                Int4(i)? return self->apply_eval_typed_shader_value(c, "int4", vname, i, ftype);
                Texture2D(t)? return self->apply_eval_typed_shader_value(c, "Texture2D", vname, t, ftype);
                Struct(s)? return self->apply_eval_typed_shader_value(c, "struct", vname, s, ftype);
            }
        }
        public func eval(
            self: HLSLForGlslang,
            c: ShaderGeneratorContext,
            v: ShaderValue,
            ftype: function_type)=> string
        {
            return c->eval(
                v,
                func(vname)
                {
                    return self->apply_eval_shader_value(c, vname, v, ftype);
                });
        }
        public func generate_vertex_in_struct(
            self: HLSLForGlslang, c: ShaderGeneratorContext, vin: ShaderIOBlock)=> void
        {
            c->append_line("struct WOSHADER_VERTEX_IN {");
            
            let mut i_count = 0;
            let mut f_count = 0;
            let mut f2_count = 0;
            let mut f34_count = 0;
            
            for (let (idx, field): vin.shader_ins->iter |> iterator::enumerate)
            {
                let t = field->get_type;
                self.vertex_in_layout->add(t);
                
                let hlsl_type_name = get_type_name_with_type(t);
                
                let mut mark = "";
                
                if (t == Type::Integer
                    || t == Type::Integer2
                    || t == Type::Integer3
                    || t == Type::Integer4)
                {
                    mark = F"BLENDINDICES{i_count}";
                    i_count += 1;
                }
                else if (t == Type::Float)
                {
                    mark = F"BLENDWEIGHT{f_count}";
                    f_count += 1;
                }
                else if (t == Type::Float2)
                {
                    mark = F"TEXCOORD{f2_count}";
                    f2_count += 1;
                }
                else if (t == Type::Float3
                    || t == Type::Float4)
                {
                    if (f34_count == 0)
                        mark = "POSITION0";
                    else if (f34_count == 1)
                        mark = "NORMAL0";
                    else if (f34_count == 2)
                        mark = "TANGENT0";
                    else
                        mark = F"COLOR{f34_count - 3}";
                    f34_count += 1;
                }
                else
                    std::panic(F"Unsupported vertex input type {t}");
                    
                append_spirv_attrib(c, F"vk::location({idx})");
                c->append_line(F"    {hlsl_type_name} _v{idx}: {mark};");
            }
            c->append_line("};");
        }
        public func generate_vertex_out_struct(
            _: HLSLForGlslang, c: ShaderGeneratorContext, vout: ShaderIOBlock)=> void
        {
            c->append_line("struct WOSHADER_V2F {");
            
            let mut i_count = 0;
            let mut f_count = 0;
            let mut f2_count = 0;
            let mut f34_count = 0;
            
            c->append_line("    float4 OUT_POSITION: SV_POSITION;");
            for (let (idx, field): vout.shader_ins->iter |> iterator::enumerate)
            {
                let t = field->get_type;
                let hlsl_type_name = get_type_name_with_type(t);
                
                let mut mark = "";
                
                if (t == Type::Integer
                    || t == Type::Integer2
                    || t == Type::Integer3
                    || t == Type::Integer4)
                {
                    mark = F"BLENDINDICES{i_count}";
                    i_count += 1;
                }
                else if (t == Type::Float)
                {
                    mark = F"BLENDWEIGHT{f_count}";
                    f_count += 1;
                }
                else if (t == Type::Float2)
                {
                    mark = F"TEXCOORD{f2_count}";
                    f2_count += 1;
                }
                else if (t == Type::Float3
                    || t == Type::Float4)
                {
                    if (f34_count == 0)
                        mark = "POSITION0";
                    else
                        mark = F"COLOR{f34_count - 1}";
                    f34_count += 1;
                }
                else
                    std::panic(F"Unsupported vertex input type {t}");
                    
                c->append_line(F"    {hlsl_type_name} _v{idx}: {mark};");
            }
            c->append_line("};");
        }
        public func generate_fragment_out_struct(
            _: HLSLForGlslang, c: ShaderGeneratorContext, fout: ShaderIOBlock)=> void
        {
            c->append_line("struct WOSHADER_FRAGMENT_OUT {");
            for (let (idx, field): fout.shader_ins->iter |> iterator::enumerate)
            {
                let t = field->get_type;
                let hlsl_type_name = get_type_name_with_type(t);
                
                c->append_line(F"    {hlsl_type_name} _v{idx}: SV_TARGET{idx};");
            }
            c->append_line("};");
        }
        public func generate_function(
            self: HLSLForGlslang, c: ShaderGeneratorContext, f: ShaderFunction)=> void
        {
            let func_ret_type = f.return_value->get_type;
            let hlsl_ret_type_name = get_type_name_with_type(func_ret_type);
            
            let paramlist = f.arguments.shader_ins->iter
                |> iterator::enumerate
                |> iterator::map(
                    func((idx, sv)){
                        let t = sv->get_type;
                        let mut pdecl = get_type_name_with_type(t) + F" _a{idx}";
                        
                        if (t == Type::Texture2D)
                            pdecl += F", SamplerState _a{idx}_sampler";
                            
                        return pdecl;
                    })
                |> iterator::reduce(\l, r = l + ", " + r;)
                -> or("")
                ;
                
            c->append_line(F"{hlsl_ret_type_name} {f.name}({paramlist})\{");
            
            let result = self->eval(c, f.return_value, function_type::NORMAL);
            c->append_line(F"    return {result};");
            c->append_line("}");
        }
        public func generate_vertex_main(
            self: HLSLForGlslang, c: ShaderGeneratorContext, vouts: array<ShaderValue>)=> void
        {
            c->append_line("WOSHADER_V2F vertex_main(WOSHADER_VERTEX_IN _vin){");
            
            let vout_vals = vouts->>\sv = self->eval(c, sv, function_type::VERTEX);;
            
            c->append_line("    WOSHADER_V2F _v2f;");
            
            if (!vout_vals->empty)
                c->append_line(F"    _v2f.OUT_POSITION = {vout_vals[0]} * JE_NDC_SCALE;");
                
            for (let (idx, vout_val) : vout_vals->iter |> iterator::enumerate)
                c->append_line(F"    _v2f._v{idx} = {vout_val};");
                
            c->append_line("    return _v2f;");
            c->append_line("}");
        }
        public func generate_fragment_main(
            self: HLSLForGlslang, c: ShaderGeneratorContext, fouts: array<ShaderValue>)=> void
        {
            c->append_line("WOSHADER_FRAGMENT_OUT fragment_main(WOSHADER_V2F _v2f){");
            
            let fout_vals = fouts->>\sv = self->eval(c, sv, function_type::FRAGMENT);;
            
            c->append_line("    WOSHADER_FRAGMENT_OUT _fout;");
            
            for (let (idx, fout_val) : fout_vals->iter |> iterator::enumerate)
                c->append_line(F"    _fout._v{idx} = {fout_val};");
                
            c->append_line("    return _fout;");
            c->append_line("}");
        }
        
        public func combine(
            self: HLSLForGlslang,
            global: ShaderGeneratorContext,
            functions: map<string, ShaderGeneratorContext>,
            vertex: ShaderGeneratorContext,
            fragment: ShaderGeneratorContext)=> void
        {
            let vertex_src = buffer::builder::create();
            let fragment_src = buffer::builder::create();
            
            vertex_src->appendbuilder(
                global.generated_codes,
                0,
                global.generated_codes->len);
            fragment_src->appendbuilder(
                global.generated_codes,
                0,
                global.generated_codes->len);
                
            func fetch_used_functions(
                f: ShaderGeneratorContext,
                functions: map<string, ShaderGeneratorContext>,
                used: map<string, void>,
                ordered: vec<ShaderGeneratorContext>)=> vec<ShaderGeneratorContext>
            {
                for (let (name, _) : f.used_function_names)
                {
                    let ff = functions[name];
                    
                    if (used->contains(name))
                    {
                        let idx = ordered->find(ff)->unwrap;
                        assert(ordered->remove(idx));
                        
                        ordered->insert(0, ff);
                        continue;
                    }
                    
                    ordered->insert(0, ff);
                    used->set(name, do nil);
                    
                    do fetch_used_functions(ff, functions, used, ordered);
                }
                return ordered;
            }
            
            let vertex_used_functions =
                fetch_used_functions(vertex, functions, {}mut, []mut);
            let fragment_used_functions =
                fetch_used_functions(fragment, functions, {}mut, []mut);
                
            for (let ff : vertex_used_functions->iter)
                vertex_src->appendbuilder(ff.generated_codes, 0, ff.generated_codes->len);
                
            for (let ff : fragment_used_functions->iter)
                fragment_src->appendbuilder(ff.generated_codes, 0, ff.generated_codes->len);
                
            vertex_src->appendbuilder(
                vertex.generated_codes,
                0,
                vertex.generated_codes->len);
                
            fragment_src->appendbuilder(
                fragment.generated_codes,
                0,
                fragment.generated_codes->len);
                
            self.generated_vertex_src = option::value(
                vertex_src->readbuffer(vertex_src->len): string);
            self.generated_fragment_src = option::value(
                fragment_src->readbuffer(fragment_src->len): string);
        }
    }
    
    extern func generate_shader()
    {
        extern("libjoyecs", "jeecs_shader_wrap_result_pack")
            func _wraped_shader(
                vertex_source: string,
                fragment_source: string,
                vertex_in_layout: array<woshader::Type>,
                samplers: array<woshader::Sampler2D>,
                texture_passes: array<(string, int /* pass */, int /* sampler id */)>,
                uniform_variables: array<(string, woshader::Type, woshader::ShaderValueImm)>,
                uniform_blocks: array<(string, int)>,
                config: ShaderConfig)=> gchandle;
                
        let generator = je::shader::HLSLForGlslang::create();
        
        woshader::ShaderParseGlobalContext::generate(generator);
        
        return _wraped_shader(
            generator.generated_vertex_src->unwrap,
            generator.generated_fragment_src->unwrap,
            generator.vertex_in_layout->unsafe::asarray,
            generator.samplers->unsafe::asarray,
            generator.texture_passes->unsafe::asarray,
            generator.uniform_variables->unsafe::asarray,
            generator.uniform_blocks->unsafe::asarray,
            configs,
        );
    }
    
    WOSHADER_UNIFORM_BLOCK!(0)
    {
        JE_V    : woshader::float4x4,
        JE_P    : woshader::float4x4,
        JE_VP   : woshader::float4x4,
        
        JE_TIME : woshader::float4,
    };
    
    // Default uniform
    WOSHADER_UNIFORM!
        public let JE_M = woshader::float4x4::unit;
    WOSHADER_UNIFORM!
        public let JE_MVP = woshader::float4x4::unit;
    WOSHADER_UNIFORM!
        public let JE_MV = woshader::float4x4::unit;
    WOSHADER_UNIFORM!
        public let JE_LOCAL_SCALE = woshader::vec3!(1., 1., 1.);
    WOSHADER_UNIFORM!
        public let JE_UV_TILING = woshader::vec2!(1., 1.);
    WOSHADER_UNIFORM!
        public let JE_UV_OFFSET = woshader::vec2!(0., 0.);
    WOSHADER_UNIFORM!
        public let JE_COLOR = woshader::vec4!(1., 1., 1., 1.);
    WOSHADER_UNIFORM!
        public let JE_NDC_SCALE = woshader::vec4!(1., 1., 1., 1.);
        
    WOSHADER_FUNCTION!
        public func uvtrans(
            uv: woshader::float2,
            tiling: woshader::float2,
            offset: woshader::float2)
        {
            return (uv + offset) * tiling;
        }
        
    public func movement(m: woshader::float4x4)
    {
        return woshader::vec3!(
            m->woshader::col(0)->woshader::w,
            m->woshader::col(1)->woshader::w,
            m->woshader::col(2)->woshader::w);
    }
}

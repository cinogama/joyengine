import woo::std;

import je::gui;

import pkg::node_editor;
import pkg::guid;
import pkg::iterator;
import pkg::try;
import pkg::worst;

import statements;

using je::gui;

namespace jeapi
{
    namespace statements
    {
        using GraphEditor = struct{
            graph_context: GraphContext,
            node_context: node_editor::EditorContext,
            
            allocated_id: mut int,
            generated_node_id_for_node: map<guid::GUID, NodeEditState>,
            generated_pin_id_for_iopin: map<guid::GUID, node_editor::PinId>,
            generated_link_id_for_2_iopin: map<string, (node_editor::LinkId, guid::GUID, guid::GUID)>,
            
            total_tree_nodes: NodeTree,
            query_input_type_nodes: map<string, NodeTree>,
            query_output_type_nodes: map<string, NodeTree>,
            query_flow_input_type_nodes: map<string, NodeTree>,
            query_flow_output_type_nodes: map<string, NodeTree>,
            
            // 接下来这些是编辑时的状态，一团乱麻~ 每帧更新
            hovered_pin_iostate: mut option<node_editor::Graph::IOState>,
            mouse_on_canvas_pos: mut (real, real),
            
            mouse_on_node: mut option<guid::GUID>,
            creating_by_dragging_from_pin: mut option<guid::GUID>,
            fast_create_node_context_menu_has_opened: mut bool,
            mouse_on_canvas_pos_when_context_menu_before_opened: mut (real, real),
        }
        {
            using NodeTree = struct{
                tree: map<string, NodeTreeNode>,
            }
            {
                union NodeTreeNode
                {
                    Node(string),
                    SubTree(NodeTree),
                }
                
                public func create(names: array<string>)
                {
                    let self = NodeTree{
                        tree = {}mut,
                    };
                    
                    walk_names@
                        for (let name : names)
                        {
                            let name_path = name->split("/") |> iterator::collect;
                            let mut current = self.tree;
                            
                            for (let part : name_path->iter |> iterator::take(name_path->len - 1))
                            {
                                let next = current->get_or_set_do(
                                    part,
                                    \= NodeTreeNode::SubTree(NodeTree{tree = {}mut}););
                                    
                                match (next)
                                {
                                    SubTree(d)? current = d.tree;
                                    Node(_)?
                                        // 冲突了，无法创建树
                                        break walk_names;
                                }
                            }
                            current->set(
                                name_path->unwrap_back,
                                NodeTreeNode::Node(name));
                        }
                        
                    return self;
                }
            }
            
            func reset_edit_state_pre_edit(self: GraphEditor)
            {
                self.hovered_pin_iostate = option::none;
            }
            func reset_edit_state_after_edit_if_context_menu_closed(self: GraphEditor)
            {
                self.mouse_on_node = option::none;
                self.creating_by_dragging_from_pin = option::none;
                self.fast_create_node_context_menu_has_opened = false;
                self.mouse_on_canvas_pos_when_context_menu_before_opened = self.mouse_on_canvas_pos;
            }
            
            using NodeEditState = struct{
                _resync_position_to_editor: mut bool,
                position: mut (real, real),
                id: node_editor::NodeId,
            }
            {
                func create(editor: GraphEditor)
                {
                    return NodeEditState{
                        _resync_position_to_editor = mut false,
                        position = mut (0.0, 0.0),
                        id = editor->allocate_id:<node_editor::NodeId>(),
                    };
                }
                func set_position(self: NodeEditState, pos: (real, real))
                {
                    self.position = pos;
                    self._resync_position_to_editor = true;
                }
            }
            
            public func create(graph_context: GraphContext)
            {
                return GraphEditor{
                    graph_context = graph_context,
                    node_context = node_editor::CreateContext(),
                    
                    allocated_id = mut 0,
                    generated_node_id_for_node = {}mut,
                    generated_pin_id_for_iopin = {}mut,
                    generated_link_id_for_2_iopin = {}mut,
                    
                    total_tree_nodes = NodeTree::create(
                        graph_context->get_node_types->get_node_type_names()),
                    query_input_type_nodes = {}mut,
                    query_output_type_nodes = {}mut,
                    query_flow_input_type_nodes = {}mut,
                    query_flow_output_type_nodes = {}mut,
                    
                    hovered_pin_iostate = mut option::none,
                    mouse_on_canvas_pos = mut (0.0, 0.0),
                    
                    mouse_on_node = mut option::none,
                    creating_by_dragging_from_pin = mut option::none,
                    fast_create_node_context_menu_has_opened = mut false,
                    mouse_on_canvas_pos_when_context_menu_before_opened = mut (0.0, 0.0),
                };
            }
            func allocate_id<Id>(self: GraphEditor)
                where 0: Id is Id;
            {
                return (self.allocated_id +:= 1): Id;
            }
            func get_node(self: GraphEditor, node_id: guid::GUID)
            {
                return self.generated_node_id_for_node->get_or_set_do(
                    node_id,
                    \= NodeEditState::create(self););
            }
            func get_pinid(self: GraphEditor, iopin_id: guid::GUID)
            {
                return self.generated_pin_id_for_iopin->get_or_set_do(
                    iopin_id,
                    \= self->allocate_id:<node_editor::PinId>(););
            }
            func get_linkid(self: GraphEditor, out_iopin_id: guid::GUID, in_iopin_id: guid::GUID)
            {
                let link_key =
                    out_iopin_id < in_iopin_id
                        ? F"{out_iopin_id}->{in_iopin_id}"
                        | F"{in_iopin_id}->{out_iopin_id}";
                        
                return self.generated_link_id_for_2_iopin->get_or_set_do(
                    link_key,
                    \= (self->allocate_id:<node_editor::LinkId>(), out_iopin_id, in_iopin_id);).0;
            }
            
            func find_io_uid(self: GraphEditor, pin_id: node_editor::PinId)
            {
                return self.generated_pin_id_for_iopin
                    ->find_if(\_, v = v == pin_id;);
            }
            func find_node_uid(self: GraphEditor, node_id: node_editor::NodeId)
            {
                return self.generated_node_id_for_node
                    ->find_if(\_, v = v.id == node_id;);
            }
            func find_link_uids(self: GraphEditor, link_id: node_editor::LinkId)
            {
                try! key = self.generated_link_id_for_2_iopin
                    ->find_if(\_, (v, _, _) = v == link_id;);
                    
                let (_, auid, buid) = self.generated_link_id_for_2_iopin[key];
                return_value! (auid, buid);
            }
            
            /////////////////////
            
            let DEFAULT_NODE_COLOR = 0xFF444444;
            let DEFAULT_NODE_DESCRIPTION = "";
            
            func i32_to_color32(color: int)
            {
                let a = color->band(0xFF);
                let b = color->bshr(8)->band(0xFF);
                let g = color->bshr(16)->band(0xFF);
                let r = color->bshr(24)->band(0xFF);
                return (r, g, b, a);
            }
            func draw_pin(self: GraphEditor, iostate: node_editor::Graph::IOState)
            {
                // TODO: Set color.
                
                Dummy((20., 20.));
                // TODO: 此处绘制图片
                
                let (lt, rb) = GetItemRect();
                let c = ((lt.0 + rb.0) / 2., (lt.1 + rb.1) / 2.);
                
                if (IsItemHovered())
                    self.hovered_pin_iostate = option::value(iostate);
                    
                return (lt, rb, c);
            }
            func edit_eval_node(self: GraphEditor, node: node_editor::Graph::INodeCollection)
            {
                {
                    BeginGroup();
                    defer EndGroup();
                    
                    for (let (name, iostate, iinput): node.inputs)
                    {
                        let (lt, rb, c) = draw_pin(self, iostate);
                        SameLine();
                        Text(name);
                        
                        node_editor::BeginInputPin(self->get_pinid(iostate.uid));
                        node_editor::PinPivotRect(c, c);
                        node_editor::PinRect(lt, rb);
                        node_editor::EndPin();
                        
                        iinput->edit();
                    }
                }
                SameLine();
                Dummy((1., 20.));
                SameLine();
                {
                    BeginGroup();
                    defer EndGroup();
                    
                    for (let (name, iostate) : node.outputs)
                    {
                        Text(name);
                        SameLine();
                        let (lt, rb, c) = draw_pin(self, iostate);
                        
                        node_editor::BeginOutputPin(self->get_pinid(iostate.uid));
                        node_editor::PinPivotRect(c, c);
                        node_editor::PinRect(lt, rb);
                        node_editor::EndPin();
                    }
                }
            }
            func edit_flow_node(self: GraphEditor, node: node_editor::Graph::IFlowNodeCollection)
            {
                {
                    BeginGroup();
                    defer EndGroup();
                    
                    for (let (name, iostate, _): node.flowinputs)
                    {
                        let (lt, rb, c) = draw_pin(self, iostate);
                        SameLine();
                        Text(name);
                        
                        node_editor::BeginInputPin(self->get_pinid(iostate.uid));
                        node_editor::PinPivotRect(c, c);
                        node_editor::PinRect(lt, rb);
                        node_editor::EndPin();
                    }
                    
                    Dummy((1., 10.));
                    
                    for (let (name, iostate, iinput): node.inputs)
                    {
                        let (lt, rb, c) = draw_pin(self, iostate);
                        SameLine();
                        Text(name);
                        
                        node_editor::BeginInputPin(self->get_pinid(iostate.uid));
                        node_editor::PinPivotRect(c, c);
                        node_editor::PinRect(lt, rb);
                        node_editor::EndPin();
                        
                        iinput->edit();
                    }
                }
                SameLine();
                Dummy((1., 20.));
                SameLine();
                {
                    BeginGroup();
                    defer EndGroup();
                    
                    for (let (name, iostate) : node.flowoutputs)
                    {
                        Text(name);
                        SameLine();
                        let (lt, rb, c) = draw_pin(self, iostate);
                        
                        node_editor::BeginOutputPin(self->get_pinid(iostate.uid));
                        node_editor::PinPivotRect(c, c);
                        node_editor::PinRect(lt, rb);
                        node_editor::EndPin();
                    }
                }
            }
            func edit_node<T>(self: GraphEditor, nuid: guid::GUID, node: T)
                where
                node is node_editor::Graph::INodeCollection
                || node is node_editor::Graph::IFlowNodeCollection
                ;
            {
                let edit_node = self->get_node(nuid);
                {
                    node_editor::PushStyleColor(
                        node_editor::StyleColor::StyleColor_NodeBg,
                        i32_to_color32(node.color->or(DEFAULT_NODE_COLOR)));
                    defer node_editor::PopStyleColor(1);
                    
                    node_editor::BeginNode(edit_node.id);
                    defer node_editor::EndNode();
                    
                    Text(node.name);
                    TextDisabled(node.description->or(DEFAULT_NODE_DESCRIPTION));
                    
                    if (node is node_editor::Graph::INodeCollection)
                        self->edit_eval_node(node);
                    else
                        self->edit_flow_node(node);
                }
                if (IsMouseHoveringRect(GetItemRect()...))
                    self.mouse_on_node = option::value(nuid);
                    
                if (edit_node._resync_position_to_editor)
                {
                    node_editor::SetNodePosition(
                        edit_node.id,
                        edit_node.position);
                    edit_node._resync_position_to_editor = false;
                }
                else
                    edit_node.position = node_editor::GetNodePosition(edit_node.id);
            }
        }
        
        namespace gui
        {
            func draw_link(
                editor_context: GraphEditor,
                auid: guid::GUID,
                buid: guid::GUID,
                a: node_editor::PinId,
                b: node_editor::PinId)
            {
                let linkid = editor_context->get_linkid(auid, buid);
                let color = GraphEditor::i32_to_color32(
                    editor_context.graph_context->query_io_state(auid)->unwrap.typecolor);
                    
                node_editor::Link(linkid, a, b, color, 2.);
            }
            func query_new_node(editor_context: GraphEditor)
            {
                match (node_editor::QueryNewNode())
                {
                    value(pinid)?
                        if (node_editor::AcceptNewItem())
                        {
                            editor_context.creating_by_dragging_from_pin =
                                editor_context->find_io_uid(pinid);
                        }
                    none?;
                }
            }
            func query_new_link(editor_context: GraphEditor)
            {
                match (node_editor::QueryNewLink())
                {
                    value((mut a, mut b))?
                    {
                        do try!
                        {
                            try! auid = editor_context->find_io_uid(a);
                            try! buid = editor_context->find_io_uid(b);
                            
                            if (node_editor::AcceptNewItem())
                            {
                                if (editor_context.graph_context->connect_uid(auid, buid)->or(false))
                                    draw_link(editor_context, auid, buid, a, b);
                            }
                            
                            return_value!;
                            
                        } catch! {
                            node_editor::RejectNewItemColor((255, 0, 0, 255), 2.);
                        };
                    }
                    none?;
                }
            }
            func query_delete_nodes(editor_context: GraphEditor)
            {
                for(;;)
                    match (node_editor::QueryDeletedNode())
                    {
                        none? break;
                        value(nodeid)?
                        {
                            do try!
                            {
                                try! nuid = editor_context->find_node_uid(nodeid);
                                
                                if (node_editor::AcceptDeletedItem())
                                    do editor_context.graph_context->remove_node_uid(nuid);
                                    
                                return_value!;
                                
                            } catch! {
                                node_editor::RejectDeletedItem();
                            };
                        }
                    }
            }
            func query_delete_links(editor_context: GraphEditor)
            {
                for (;;)
                    match (node_editor::QueryDeletedLink())
                    {
                        none? break;
                        value(linkid)?
                            do try!
                            {
                                if (node_editor::AcceptDeletedItem())
                                {
                                    try! (auid, buid) = editor_context->find_link_uids(linkid);
                                    editor_context.graph_context->disconnect_uid(auid, buid);
                                }
                                
                                return_value!;
                            };
                    }
            }
            func update_new_node_and_link(editor_context: GraphEditor)
            {
                let creating = node_editor::BeginCreate((0, 255, 255, 255), 2.);
                defer node_editor::EndCreate();
                if (creating)
                {
                    query_new_node(editor_context);
                    query_new_link(editor_context);
                }
            }
            func update_delete_node_and_link(editor_context: GraphEditor)
            {
                let deleting = node_editor::BeginDelete();
                defer node_editor::EndDelete();
                if (deleting)
                {
                    query_delete_nodes(editor_context);
                    query_delete_links(editor_context);
                }
            }
            func create_node_menu_context(editor_context: GraphEditor, nodes: GraphEditor::NodeTree)=> void
            {
                for (let (name, node) : nodes.tree)
                {
                    match (node)
                    {
                        Node(name)?
                            if (MenuItem(name))
                            {
                                match (editor_context.graph_context->create_node_with_name(name))
                                {
                                    none?;
                                    value(node_uid)?
                                    {
                                        editor_context->get_node(node_uid)->set_position(
                                            editor_context.mouse_on_canvas_pos_when_context_menu_before_opened);
                                    }
                                }
                            }
                        SubTree(subtree)?
                        {
                            if (BeginMenu(name))
                            {
                                defer EndMenu();
                                create_node_menu_context(editor_context, subtree);
                            }
                        }
                    }
                }
            }
            public func show_context_menu(editor_context: GraphEditor)
            {
                match (editor_context.creating_by_dragging_from_pin)
                {
                    none?;
                    value(_)?
                        if (editor_context.fast_create_node_context_menu_has_opened == false)
                        {
                            editor_context.fast_create_node_context_menu_has_opened = true;
                            OpenPopup("NodeEditorCreateContextMenu");
                        }
                }
                
                if (BeginPopup("NodeEditorCreateContextMenu"))
                {
                    defer EndPopup();
                    create_node_menu_context(editor_context, editor_context.total_tree_nodes);
                }
                else if (BeginPopupContextItemLabel("NodeEditorMainContextMenu"))
                {
                    defer EndPopup();
                    if (BeginMenu("新节点..."))
                    {
                        defer EndMenu();
                        create_node_menu_context(editor_context, editor_context.total_tree_nodes);
                    }
                    
                    match (editor_context.mouse_on_node)
                    {
                        none?;
                        value(node_uid)?
                        {
                            Separator();
                            
                            if (MenuItem("删除节点"))
                            {
                                do editor_context.graph_context->remove_node_uid(node_uid);
                            }
                            if (MenuItem("复制"))
                            {
                                do editor_context.graph_context->clone_node_uid(node_uid)
                                    ->> \cloned_node_uid =
                                        editor_context->get_node(cloned_node_uid)->set_position(
                                            editor_context.mouse_on_canvas_pos_when_context_menu_before_opened);
                                        ;
                                ;
                            }
                        }
                    }
                }
                else
                {
                    editor_context->reset_edit_state_after_edit_if_context_menu_closed();
                }
            }
            public func Edit(label: string, editor_context: GraphEditor)
            {
                let mouse_pos_in_viewport = GetMousePos();
                
                editor_context->reset_edit_state_pre_edit();
                {
                    node_editor::Begin(label, editor_context.node_context);
                    defer node_editor::End();
                    
                    editor_context.mouse_on_canvas_pos =
                        node_editor::ScreenToCanvas(mouse_pos_in_viewport);
                        
                    PushStyleColor(ImGuiCol::ImGuiCol_Text, (255, 255, 255, 255));
                    defer PopStyleColor(1);
                    
                    for (let (nuid, node) : editor_context.graph_context->walk_eval_nodes)
                        editor_context->edit_node(nuid, node);
                        
                    for (let (nuid, node) : editor_context.graph_context->walk_flow_nodes)
                        editor_context->edit_node(nuid, node);
                        
                    for (let (outlink, inlink) : editor_context.graph_context->walk_all_link)
                    {
                        let a = editor_context->get_pinid(outlink);
                        let b = editor_context->get_pinid(inlink);
                        
                        draw_link(editor_context, outlink, inlink, a, b);
                    }
                    update_new_node_and_link(editor_context);
                    update_delete_node_and_link(editor_context);
                }
                
                // TODO: 在此展开编辑菜单
                show_context_menu(editor_context);
                
                // 如果鼠标悬浮在某个引脚上，显示类型提示
                match (editor_context.hovered_pin_iostate)
                {
                    none?;
                    value(hovered_iostate)?
                    {
                        if (BeginTooltip())
                        {
                            defer EndTooltip();
                            Text(hovered_iostate.typename);
                        }
                    }
                }
            }
        }
    }
}

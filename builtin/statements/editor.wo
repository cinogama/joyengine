import woo::std;

import je;
import je::gui;

import pkg::node_editor;
import pkg::guid;
import pkg::iterator;
import pkg::try;
import pkg::worst;
import pkg::math;

import statements;
import runtime;

using je::gui;

namespace jeapi
{
    namespace statements
    {
        using GraphEditor = struct{
            graph_context: GraphContext,
            node_context: node_editor::EditorContext,
            
            allocated_id: mut int,
            generated_node_id_for_node: map<guid::GUID, NodeEditState>,
            generated_pin_id_for_iopin: map<guid::GUID, node_editor::PinId>,
            generated_link_id_for_2_iopin: map<string, (node_editor::LinkId, guid::GUID, guid::GUID)>,
            
            total_tree_nodes: NodeTree,
            query_input_type_nodes: map<string, NodeTree>,
            query_output_type_nodes: map<string, NodeTree>,
            query_flow_input_type_nodes: map<string, NodeTree>,
            query_flow_output_type_nodes: map<string, NodeTree>,
            
            input_pin_image: option<je::graphic::texture>,
            output_pin_image: option<je::graphic::texture>,
            flow_pin_image: option<je::graphic::texture>,
            
            // 接下来这些是编辑时的状态，一团乱麻~ 每帧更新
            try_linking_from_io_typename: mut option<string>,
            
            hovered_pin_iostate: mut option<node_editor::Graph::IOState>,
            mouse_on_canvas_pos: mut (real, real),
            
            context_menu_shown: mut bool,
            mouse_on_node: mut option<guid::GUID>,
            creating_by_dragging_from_pin: mut option<guid::GUID>,
            fast_create_node_context_menu_has_opened: mut bool,
            mouse_on_canvas_pos_when_context_menu_before_opened: mut (real, real),
        }
        {
            public func save_extra_data(self: GraphEditor)
            {
                let result = {}mut: map<string, mut array<real>>;
                
                for (let (uid, state) : self.generated_node_id_for_node)
                {
                    if (self.graph_context->query_eval_node_uid(uid)->is_value
                        || self.graph_context->query_flow_node_uid(uid)->is_value)
                        result[uid: string] = [state.position.0, state.position.1];
                }
                return result: dynamic;
            }
            
            using NodeTree = struct{
                tree: map<string, NodeTreeNode>,
            }
            {
                union NodeTreeNode
                {
                    Node(string),
                    SubTree(NodeTree),
                }
                
                public func create(names: array<string>)
                {
                    let self = NodeTree{
                        tree = {}mut,
                    };
                    
                    walk_names@
                        for (let name : names)
                        {
                            let name_path = name->split("/") |> iterator::collect;
                            let mut current = self.tree;
                            
                            for (let part : name_path->iter |> iterator::take(name_path->len - 1))
                            {
                                let next = current->get_or_set_do(
                                    part,
                                    \= NodeTreeNode::SubTree(NodeTree{tree = {}mut}););
                                    
                                match (next)
                                {
                                    SubTree(d)? current = d.tree;
                                    Node(_)?
                                        // 冲突了，无法创建树
                                        break walk_names;
                                }
                            }
                            current->set(
                                name_path->unwrap_back,
                                NodeTreeNode::Node(name));
                        }
                        
                    return self;
                }
            }
            func query_iostate_portable_node_tree(self: GraphEditor, iostate: node_editor::Graph::IOState)
            {
                if (iostate.kind == node_editor::Graph::IOState::IOKind::Input)
                {
                    return self.query_output_type_nodes->get_or_set_do(
                        iostate.typename,
                        \=
                            NodeTree::create(
                                self.graph_context->query_node_type_with_output_type(
                                    iostate.typename))
                            ;
                        );
                }
                else if (iostate.kind == node_editor::Graph::IOState::IOKind::Output)
                {
                    return self.query_input_type_nodes->get_or_set_do(
                        iostate.typename,
                        \=
                            NodeTree::create(
                                self.graph_context->query_node_type_with_input_type(
                                    iostate.typename))
                            ;
                        );
                }
                else if (iostate.kind == node_editor::Graph::IOState::IOKind::InputFlow)
                {
                    return self.query_flow_output_type_nodes->get_or_set_do(
                        iostate.typename,
                        \=
                            NodeTree::create(
                                self.graph_context->query_node_type_with_flowoutput_type(
                                    iostate.typename))
                            ;
                        );
                }
                else if (iostate.kind == node_editor::Graph::IOState::IOKind::OutputFlow)
                {
                    return self.query_flow_input_type_nodes->get_or_set_do(
                        iostate.typename,
                        \=
                            NodeTree::create(
                                self.graph_context->query_node_type_with_flowinput_type(
                                    iostate.typename))
                            ;
                        );
                }
                return std::panic("Unreachable");
            }
            func reset_edit_state_pre_edit(self: GraphEditor)
            {
                self.hovered_pin_iostate = option::none;
            }
            func reset_edit_state_after_edit_if_context_menu_closed(self: GraphEditor)
            {
                self.context_menu_shown = false;
                self.mouse_on_node = option::none;
                self.creating_by_dragging_from_pin = option::none;
                self.fast_create_node_context_menu_has_opened = false;
                self.mouse_on_canvas_pos_when_context_menu_before_opened = self.mouse_on_canvas_pos;
            }
            
            using NodeEditState = struct{
                _resync_position_to_editor: mut bool,
                position: mut (real, real),
                id: node_editor::NodeId,
            }
            {
                func create(editor: GraphEditor)
                {
                    return NodeEditState{
                        _resync_position_to_editor = mut false,
                        position = mut (0.0, 0.0),
                        id = editor->allocate_id:<node_editor::NodeId>(),
                    };
                }
                func set_position(self: NodeEditState, pos: (real, real))
                {
                    self.position = pos;
                    self._resync_position_to_editor = true;
                }
            }
            
            public func create(graph_context: GraphContext, extra_data: option<dynamic>)
            {
                let self = GraphEditor{
                    graph_context = graph_context,
                    node_context = node_editor::CreateContext(),
                    
                    allocated_id = mut 0,
                    generated_node_id_for_node = {}mut,
                    generated_pin_id_for_iopin = {}mut,
                    generated_link_id_for_2_iopin = {}mut,
                    
                    total_tree_nodes = NodeTree::create(
                        graph_context->get_node_types->get_node_type_names()),
                    query_input_type_nodes = {}mut,
                    query_output_type_nodes = {}mut,
                    query_flow_input_type_nodes = {}mut,
                    query_flow_output_type_nodes = {}mut,
                    
                    input_pin_image = je::graphic::texture::load(option::none, "!/builtin/icon/InputPin.png"),
                    output_pin_image = je::graphic::texture::load(option::none, "!/builtin/icon/OutputPin.png"),
                    flow_pin_image = je::graphic::texture::load(option::none, "!/builtin/icon/FlowPin.png"),
                    
                    try_linking_from_io_typename = mut option::none,
                    
                    hovered_pin_iostate = mut option::none,
                    mouse_on_canvas_pos = mut (0.0, 0.0),
                    
                    context_menu_shown = mut false,
                    mouse_on_node = mut option::none,
                    creating_by_dragging_from_pin = mut option::none,
                    fast_create_node_context_menu_has_opened = mut false,
                    mouse_on_canvas_pos_when_context_menu_before_opened = mut (0.0, 0.0),
                };
                
                match (extra_data=>>\d = d->trycast:<dict<string, array<real>>>;)
                {
                    none?;
                    value(dat)?
                    {
                        for (let (uidstr, pos) : dat)
                        {
                            self->get_node(uidstr: guid::GUID)->set_position(
                                (pos->get_or(0, 0.), pos->get_or(1, 0.)));
                        }
                    }
                }
                
                return self;
            }
            func allocate_id<Id>(self: GraphEditor)
                where 0: Id is Id;
            {
                return (self.allocated_id +:= 1): Id;
            }
            func get_node(self: GraphEditor, node_id: guid::GUID)
            {
                return self.generated_node_id_for_node->get_or_set_do(
                    node_id,
                    \= NodeEditState::create(self););
            }
            func get_pinid(self: GraphEditor, iopin_id: guid::GUID)
            {
                return self.generated_pin_id_for_iopin->get_or_set_do(
                    iopin_id,
                    \= self->allocate_id:<node_editor::PinId>(););
            }
            func get_linkid(self: GraphEditor, out_iopin_id: guid::GUID, in_iopin_id: guid::GUID)
            {
                let link_key =
                    out_iopin_id < in_iopin_id
                        ? F"{out_iopin_id}->{in_iopin_id}"
                        | F"{in_iopin_id}->{out_iopin_id}";
                        
                return self.generated_link_id_for_2_iopin->get_or_set_do(
                    link_key,
                    \= (self->allocate_id:<node_editor::LinkId>(), out_iopin_id, in_iopin_id);).0;
            }
            
            func find_io_uid(self: GraphEditor, pin_id: node_editor::PinId)
            {
                return self.generated_pin_id_for_iopin
                    ->find_if(\_, v = v == pin_id;);
            }
            func find_node_uid(self: GraphEditor, node_id: node_editor::NodeId)
            {
                return self.generated_node_id_for_node
                    ->find_if(\_, v = v.id == node_id;);
            }
            func find_link_uids(self: GraphEditor, link_id: node_editor::LinkId)
            {
                try! key = self.generated_link_id_for_2_iopin
                    ->find_if(\_, (v, _, _) = v == link_id;);
                    
                let (_, auid, buid) = self.generated_link_id_for_2_iopin[key];
                return_value! (auid, buid);
            }
            
            /////////////////////
            
            let DEFAULT_NODE_COLOR = 0xFF444444;
            let DEFAULT_NODE_DESCRIPTION = "";
            
            func i32_to_color32(color: int)
            {
                let a = color->band(0xFF);
                let b = color->bshr(8)->band(0xFF);
                let g = color->bshr(16)->band(0xFF);
                let r = color->bshr(24)->band(0xFF);
                return (r, g, b, a);
            }
            func draw_pin(self: GraphEditor, iostate: node_editor::Graph::IOState)
            {
                let mut shown_image = option::none: option<je::graphic::texture>;
                if (iostate.kind == node_editor::Graph::IOState::IOKind::Input)
                    shown_image = self.input_pin_image;
                else if (iostate.kind == node_editor::Graph::IOState::IOKind::Output)
                    shown_image = self.output_pin_image;
                else
                    shown_image = self.flow_pin_image;
                    
                let mut alpha_scale = 1.0: real;
                match (self.try_linking_from_io_typename)
                {
                    value(name)?
                        if (name != iostate.typename)
                            // Hide image.
                            alpha_scale = 0.1;
                    none?;
                }
                
                match (shown_image)
                {
                    none?
                        Dummy((20., 20.));
                    value(img)?
                    {
                        let (r, g, b, a) = i32_to_color32(iostate.typecolor);
                        ImageSizeColor(img, 20., 20., (r, g, b, (a: real * alpha_scale): int));
                    }
                }
                
                let (lt, rb) = GetItemRect();
                let c = ((lt.0 + rb.0) / 2., (lt.1 + rb.1) / 2.);
                
                if (IsItemHovered())
                    self.hovered_pin_iostate = option::value(iostate);
                    
                return (lt, rb, c);
            }
            func edit_eval_node(self: GraphEditor, node: node_editor::Graph::INodeCollection, nuid: guid::GUID)
            {
                {
                    BeginGroup();
                    defer EndGroup();
                    
                    for (let (name, iostate, iinput): node.inputs)
                    {
                        let (lt, rb, c) = draw_pin(self, iostate);
                        SameLine();
                        Text(name);
                        
                        node_editor::BeginInputPin(self->get_pinid(iostate.uid));
                        node_editor::PinPivotRect(c, c);
                        node_editor::PinRect(lt, rb);
                        node_editor::EndPin();
                        
                        if (self.graph_context->query_link_to_uid(iostate.uid)->empty())
                            iinput->edit();
                    }
                }
                SameLine();
                Dummy((1., 20.));
                SameLine();
                {
                    BeginGroup();
                    defer EndGroup();
                    
                    for (let (name, iostate) : node.outputs)
                    {
                        Text(name);
                        SameLine();
                        let (lt, rb, c) = draw_pin(self, iostate);
                        
                        node_editor::BeginOutputPin(self->get_pinid(iostate.uid));
                        node_editor::PinPivotRect(c, c);
                        node_editor::PinRect(lt, rb);
                        node_editor::EndPin();
                    }
                }
                node.node->edit(nuid);
            }
            func edit_flow_node(self: GraphEditor, node: node_editor::Graph::IFlowNodeCollection, nuid: guid::GUID)
            {
                {
                    BeginGroup();
                    defer EndGroup();
                    
                    for (let (name, iostate, _): node.flowinputs)
                    {
                        let (lt, rb, c) = draw_pin(self, iostate);
                        SameLine();
                        Text(name);
                        
                        node_editor::BeginInputPin(self->get_pinid(iostate.uid));
                        node_editor::PinPivotRect(c, c);
                        node_editor::PinRect(lt, rb);
                        node_editor::EndPin();
                    }
                    
                    Dummy((1., 10.));
                    
                    for (let (name, iostate, iinput): node.inputs)
                    {
                        let (lt, rb, c) = draw_pin(self, iostate);
                        SameLine();
                        Text(name);
                        
                        node_editor::BeginInputPin(self->get_pinid(iostate.uid));
                        node_editor::PinPivotRect(c, c);
                        node_editor::PinRect(lt, rb);
                        node_editor::EndPin();
                        
                        if (self.graph_context->query_link_to_uid(iostate.uid)->empty())
                            iinput->edit();
                    }
                }
                SameLine();
                Dummy((1., 20.));
                SameLine();
                {
                    BeginGroup();
                    defer EndGroup();
                    
                    for (let (name, iostate) : node.flowoutputs)
                    {
                        Text(name);
                        SameLine();
                        let (lt, rb, c) = draw_pin(self, iostate);
                        
                        node_editor::BeginOutputPin(self->get_pinid(iostate.uid));
                        node_editor::PinPivotRect(c, c);
                        node_editor::PinRect(lt, rb);
                        node_editor::EndPin();
                    }
                }
                node.flownode->edit(nuid);
            }
            func edit_node<T>(self: GraphEditor, nuid: guid::GUID, node: T)
                where
                node is node_editor::Graph::INodeCollection
                || node is node_editor::Graph::IFlowNodeCollection
                ;
            {
                let edit_node = self->get_node(nuid);
                {
                    let mut color_high_light_factor =
                        RuntimeDebugger::check_node_active(nuid)
                            ? 1.5 + 0.5 * math::sin(5. * std::time())
                            | 1.0;
                            
                    let (r, g, b, a) =
                        i32_to_color32(node.color->or(DEFAULT_NODE_COLOR));
                        
                    node_editor::PushStyleColor(
                        node_editor::StyleColor::StyleColor_NodeBg,
                        (
                            (r: real * color_high_light_factor): int,
                            (g: real * color_high_light_factor): int,
                            (b: real * color_high_light_factor): int,
                            (a: real * color_high_light_factor): int,
                        ));
                    defer node_editor::PopStyleColor(1);
                    
                    node_editor::BeginNode(edit_node.id);
                    defer node_editor::EndNode();
                    
                    Text(node.name);
                    TextDisabled(node.description->or(DEFAULT_NODE_DESCRIPTION));
                    
                    if (node is node_editor::Graph::INodeCollection)
                        self->edit_eval_node(node, nuid);
                    else
                        self->edit_flow_node(node, nuid);
                }
                if (IsMouseHoveringRect(GetItemRect()...) && ! self.context_menu_shown)
                    self.mouse_on_node = option::value(nuid);
                    
                if (edit_node._resync_position_to_editor)
                {
                    node_editor::SetNodePosition(
                        edit_node.id,
                        edit_node.position);
                    edit_node._resync_position_to_editor = false;
                }
                else
                    edit_node.position = node_editor::GetNodePosition(edit_node.id);
            }
        }
        
        namespace gui
        {
            func draw_link(
                editor_context: GraphEditor,
                auid: guid::GUID,
                buid: guid::GUID,
                apin: node_editor::PinId,
                bpin: node_editor::PinId)
            {
                let linkid = editor_context->get_linkid(auid, buid);
                
                let mut alpha_scale = 1.;
                let iostate = editor_context.graph_context->query_iostate(auid)->unwrap;
                
                let (r, g, b, a) = GraphEditor::i32_to_color32(
                    iostate.typecolor);
                    
                match (editor_context.try_linking_from_io_typename)
                {
                    value(name)?
                        if (name != iostate.typename)
                            alpha_scale = 0.1;
                    none?;
                }
                
                node_editor::Link(linkid, apin, bpin, (r, g, b, (a: real * alpha_scale): int), 2.);
            }
            func query_new_node(editor_context: GraphEditor)
            {
                match (node_editor::QueryNewNode())
                {
                    value(pinid)?
                    {
                        match (editor_context->find_io_uid(pinid)
                            =>> \iouid = editor_context.graph_context->query_iostate(iouid);)
                        {
                            none?;
                            value(iostate)?
                            {
                                editor_context.try_linking_from_io_typename =
                                    option::value(iostate.typename);
                            }
                        }
                        
                        if (node_editor::AcceptNewItem())
                        {
                            editor_context.creating_by_dragging_from_pin =
                                editor_context->find_io_uid(pinid);
                        }
                    }
                    none?;
                }
            }
            func query_new_link(editor_context: GraphEditor)
            {
                match (node_editor::QueryNewLink())
                {
                    value((mut a, mut b))?
                    {
                        do try!
                        {
                            try! auid = editor_context->find_io_uid(a);
                            try! buid = editor_context->find_io_uid(b);
                            
                            try! aiostate = editor_context.graph_context->query_iostate(auid);
                            try! biostate = editor_context.graph_context->query_iostate(buid);
                            
                            if (aiostate.nuid == biostate.nuid)
                                throw!;
                                
                            if (node_editor::AcceptNewItem())
                            {
                                if (editor_context.graph_context->connect_uid(auid, buid)->or(false))
                                    draw_link(editor_context, auid, buid, a, b);
                            }
                            
                            return_value!;
                            
                        } catch! {
                            node_editor::RejectNewItemColor((255, 0, 0, 255), 2.);
                        };
                    }
                    none?;
                }
            }
            func query_delete_nodes(editor_context: GraphEditor)
            {
                for(;;)
                    match (node_editor::QueryDeletedNode())
                    {
                        none? break;
                        value(nodeid)?
                        {
                            do try!
                            {
                                try! nuid = editor_context->find_node_uid(nodeid);
                                
                                if (node_editor::AcceptDeletedItem())
                                    do editor_context.graph_context->remove_node_uid(nuid);
                                    
                                return_value!;
                                
                            } catch! {
                                node_editor::RejectDeletedItem();
                            };
                        }
                    }
            }
            func query_delete_links(editor_context: GraphEditor)
            {
                for (;;)
                    match (node_editor::QueryDeletedLink())
                    {
                        none? break;
                        value(linkid)?
                            do try!
                            {
                                if (node_editor::AcceptDeletedItem())
                                {
                                    try! (auid, buid) = editor_context->find_link_uids(linkid);
                                    editor_context.graph_context->disconnect_uid(auid, buid);
                                }
                                
                                return_value!;
                            };
                    }
            }
            func update_new_node_and_link(editor_context: GraphEditor)
            {
                let creating = node_editor::BeginCreate((0, 255, 255, 255), 2.);
                defer node_editor::EndCreate();
                
                editor_context.try_linking_from_io_typename = option::none;
                if (creating)
                {
                    query_new_node(editor_context);
                    query_new_link(editor_context);
                }
            }
            func update_delete_node_and_link(editor_context: GraphEditor)
            {
                let deleting = node_editor::BeginDelete();
                defer node_editor::EndDelete();
                if (deleting)
                {
                    query_delete_nodes(editor_context);
                    query_delete_links(editor_context);
                }
            }
            func create_node_menu_context(
                editor_context: GraphEditor, nodes: GraphEditor::NodeTree)=> option<guid::GUID>
            {
                if (nodes.tree->len == 0)
                {
                    do MenuItemEnabled("(无可用节点)", false);
                    return option::none;
                }
                
                let mut result = option::none: option<guid::GUID>;
                for (let (name, node) : nodes.tree)
                {
                    match (node)
                    {
                        Node(name)?
                            if (MenuItem(name))
                            {
                                match (editor_context.graph_context->create_node_with_name(name))
                                {
                                    none?;
                                    value(node_uid)?
                                    {
                                        let node_edit_state =
                                            editor_context->get_node(node_uid);
                                        node_edit_state->set_position(
                                            editor_context.mouse_on_canvas_pos_when_context_menu_before_opened);
                                            
                                        result = option::value(node_uid);
                                    }
                                }
                            }
                        SubTree(subtree)?
                        {
                            if (BeginMenu(name))
                            {
                                defer EndMenu();
                                match (create_node_menu_context(editor_context, subtree))
                                {
                                    none?;
                                    value(node_edit_state)?
                                        result = option::value(node_edit_state);
                                }
                            }
                        }
                    }
                }
                return result;
            }
            func fast_create_link_with_pin(
                editor_context: GraphEditor, nuid: guid::GUID, piostate: node_editor::Graph::IOState)
            {
                if (piostate.kind == node_editor::Graph::IOState::IOKind::Input)
                {
                    // 只有 EvalNode 才有 Output
                    try! outputs = editor_context.graph_context->query_eval_node_uid(nuid)
                        ->> \n = n.outputs;
                        ;
                    try! (_, o_iostate) = outputs->iter |> iterator::find(\(_, iostate) = iostate.typename == piostate.typename;);
                    
                    return editor_context.graph_context->connect_uid(
                        o_iostate.uid,
                        piostate.uid);
                }
                else if (piostate.kind == node_editor::Graph::IOState::IOKind::Output)
                {
                    try! inputs = editor_context.graph_context->query_eval_node_uid(nuid)
                        ->> \n = n.inputs;
                        -> or_bind(\=
                                editor_context.graph_context->query_flow_node_uid(nuid)
                                    ->> \n = n.inputs;
                                ;);
                                
                    try! (_, i_iostate, _) = inputs->iter |> iterator::find(\(_, iostate, _) = iostate.typename == piostate.typename;);
                    
                    return editor_context.graph_context->connect_uid(
                        i_iostate.uid,
                        piostate.uid);
                }
                else if (piostate.kind == node_editor::Graph::IOState::IOKind::InputFlow)
                {
                    try! flowoutputs = editor_context.graph_context->query_flow_node_uid(nuid)
                        ->> \n = n.flowoutputs;
                        ;
                    try! (_, o_iostate) = flowoutputs->iter |> iterator::find(\(_, iostate) = iostate.typename == piostate.typename;);
                    
                    return editor_context.graph_context->connect_uid(
                        o_iostate.uid,
                        piostate.uid);
                }
                else if (piostate.kind == node_editor::Graph::IOState::IOKind::OutputFlow)
                {
                    try! flowinputs = editor_context.graph_context->query_flow_node_uid(nuid)
                        ->> \n = n.flowinputs;
                        ;
                    try! (_, i_iostate, _) = flowinputs->iter |> iterator::find(\(_, iostate, _) = iostate.typename == piostate.typename;);
                    
                    return editor_context.graph_context->connect_uid(
                        i_iostate.uid,
                        piostate.uid);
                }
                return std::panic("Unreachable");
            }
            func show_context_menu(editor_context: GraphEditor)
            {
                static let mut right_mouse_down_time = 0.,
                mut mouse_down_pos = (0., 0.);
                
                if (IsMouseClicked(ImGuiMouseButton::ImGuiMouseButton_Right))
                {
                    right_mouse_down_time = std::time();
                    mouse_down_pos = GetMousePos();
                }
                
                if (IsItemHovered() && IsMouseReleased(ImGuiMouseButton::ImGuiMouseButton_Right))
                {
                    if (std::time() - right_mouse_down_time < 0.2)
                    {
                        let (mx, my) = GetMousePos();
                        if (math::abs(mx - mouse_down_pos.0) < 5.
                            && math::abs(my - mouse_down_pos.1) < 5.)
                        {
                            OpenPopup("NodeEditorMainContextMenu");
                        }
                    }
                }
                
                match (editor_context.creating_by_dragging_from_pin)
                {
                    none?;
                    value(_)?
                        if (editor_context.fast_create_node_context_menu_has_opened == false)
                        {
                            editor_context.fast_create_node_context_menu_has_opened = true;
                            OpenPopup("NodeEditorCreateContextMenu");
                        }
                }
                
                if (BeginPopup("NodeEditorCreateContextMenu"))
                {
                    defer EndPopup();
                    
                    editor_context.context_menu_shown = true;
                    match (editor_context.creating_by_dragging_from_pin
                        =>> \pin_uid = editor_context.graph_context->query_iostate(pin_uid);)
                    {
                        none?;
                        value(iostate)?
                        {
                            match (create_node_menu_context(
                                    editor_context, editor_context->query_iostate_portable_node_tree(iostate)))
                            {
                                none?;
                                value(created_nuid)?
                                    // 寻找第一个可行的节点怼进去；
                                    do fast_create_link_with_pin(
                                        editor_context,
                                        created_nuid,
                                        iostate);
                            }
                        }
                    }
                }
                
                else if (BeginPopup("NodeEditorMainContextMenu"))
                {
                    defer EndPopup();
                    
                    editor_context.context_menu_shown = true;
                    if (BeginMenu("新节点..."))
                    {
                        defer EndMenu();
                        do create_node_menu_context(editor_context, editor_context.total_tree_nodes);
                    }
                    
                    match (editor_context.mouse_on_node)
                    {
                        none?;
                        value(node_uid)?
                        {
                            Separator();
                            
                            if (MenuItem("删除节点"))
                            {
                                do editor_context.graph_context->remove_node_uid(node_uid);
                            }
                            if (MenuItem("复制"))
                            {
                                do editor_context.graph_context->clone_node_uid(node_uid)
                                    ->> \cloned_node_uid =
                                        editor_context->get_node(cloned_node_uid)->set_position(
                                            editor_context.mouse_on_canvas_pos_when_context_menu_before_opened);
                                        ;
                                ;
                            }
                            if (MenuItem(F"复制GUID {node_uid}"))
                            {
                                SetClipboardText(node_uid: string);
                            }
                        }
                    }
                }
                else
                {
                    editor_context->reset_edit_state_after_edit_if_context_menu_closed();
                }
            }
            public func Edit(label: string, editor_context: GraphEditor)
            {
                let mouse_pos_in_viewport = GetMousePos();
                
                editor_context->reset_edit_state_pre_edit();
                {
                    node_editor::Begin(label, editor_context.node_context);
                    defer node_editor::End();
                    
                    editor_context.mouse_on_canvas_pos =
                        node_editor::ScreenToCanvas(mouse_pos_in_viewport);
                        
                    PushStyleColor(ImGuiCol::ImGuiCol_Text, (255, 255, 255, 255));
                    defer PopStyleColor(1);
                    
                    for (let (nuid, node) : editor_context.graph_context->walk_eval_nodes)
                        editor_context->edit_node(nuid, node);
                        
                    for (let (nuid, node) : editor_context.graph_context->walk_flow_nodes)
                        editor_context->edit_node(nuid, node);
                        
                    for (let (outlink, inlink) : editor_context.graph_context->walk_all_link)
                    {
                        let a = editor_context->get_pinid(outlink);
                        let b = editor_context->get_pinid(inlink);
                        
                        draw_link(editor_context, outlink, inlink, a, b);
                    }
                    update_new_node_and_link(editor_context);
                    update_delete_node_and_link(editor_context);
                }
                
                // 在此展开编辑菜单
                show_context_menu(editor_context);
                
                // 如果鼠标悬浮在某个引脚上，显示类型提示
                match (editor_context.hovered_pin_iostate)
                {
                    none?;
                    value(hovered_iostate)?
                    {
                        if (BeginTooltip())
                        {
                            defer EndTooltip();
                            Text(hovered_iostate.typename);
                        }
                    }
                }
            }
        }
    }
}

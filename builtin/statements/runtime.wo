import woo::std;

import je;

import pkg::async;
import pkg::try;
import pkg::vm;
import pkg::buffer;
import pkg::fsys;
import pkg::node_editor;
import pkg::interface;
import pkg::guid;
import pkg::singleton;

import builtin::statements;

namespace jeapi
{
    namespace statements
    {
        using RuntimeDebugger = struct{
            graph: GraphContext,
            entered_nodes: map<guid::GUID, int>,
        }
        {
            using DebuggerCollection = struct{
                global_entered_nodes: map<guid::GUID, int>,
            }
            {
                let instance = singleton::create(
                    "je::statements::runtime::jeapi::statements::RuntimeDebugger::DebuggerCollection",
                    0x7FFF_FFFF_FFFF_FFFF,
                    \= DebuggerCollection{global_entered_nodes = {}mut};);
            }
            
            public func hook(graph: GraphContext)
                where require!(RuntimeDebugger: node_editor::IGraphDebugger);
            {
                let debugger = RuntimeDebugger{
                    graph = graph,
                    entered_nodes = {}mut: map<guid::GUID, int>,
                };
                
                graph->register_debugger(debugger);
                return debugger;
            }
            public func unhook(self: RuntimeDebugger)
            {
                DebuggerCollection::instance->apply(
                    func(c: DebuggerCollection)
                    {
                        for (let (nuid, count) : self.entered_nodes)
                        {
                            c.global_entered_nodes->set(
                                nuid,
                                c.global_entered_nodes->get_or(nuid, 0) - count);
                        }
                    });
                self.graph->unregister_debugger();
            }
            
            public func enter_node(self: RuntimeDebugger, nuid: guid::GUID)
            {
                self.entered_nodes->set(
                    nuid, self.entered_nodes->get_or(nuid, 0) + 1);
                DebuggerCollection::instance->apply(
                    func(c: DebuggerCollection)
                    {
                        c.global_entered_nodes->set(
                            nuid, c.global_entered_nodes->get_or(nuid, 0) + 1);
                    });
            }
            public func leave_node(self: RuntimeDebugger, nuid: guid::GUID)
            {
                self.entered_nodes->set(
                    nuid, self.entered_nodes->get_or(nuid, 1) - 1);
                DebuggerCollection::instance->apply(
                    func(c: DebuggerCollection)
                    {
                        c.global_entered_nodes->set(
                            nuid, c.global_entered_nodes->get_or(nuid, 1) - 1);
                    });
            }

            public func check_node_active(nuid: guid::GUID)=> bool
            {
                let is_active = DebuggerCollection::instance->apply(
                    func(c: DebuggerCollection)
                    {
                        return c.global_entered_nodes->get_or(nuid, 0) > 0;
                    });
                return is_active;
            }
        }
        
        using Runtime = struct{
            vm_state: vm,
            workflow_path: string,
        }
        {
            public func create(workflow_path: string)
            {
                let rumtime_path = workflow_path + "/runtime.wo";
                // 在编辑器环境下，使用 @/ 目录会导致相对路径导入出现一些问题
                // 获取实际路径给 VM 使用以确保导入顺利执行。
                let fact_runtime_path = rumtime_path->begin_with("@/")
                    ? fsys::workpath()->to_string() + rumtime_path->sub(1)
                    | rumtime_path;
                    
                try! runtime_content = je::file::readall(rumtime_path)
                    -> ok_or(F"无法读取 Workflow 运行时文件 {rumtime_path}");
                try! vm_instance = vm::create(
                    fact_runtime_path, runtime_content: buffer);
                    
                try! _ = vm_instance->run()
                    -> ok_or(F"初始化 Workflow `{workflow_path}` 的运行时失败");
                    
                return_ok! Runtime{
                    vm_state = vm_instance,
                    workflow_path = workflow_path,
                };
            }
            public func launch(self: Runtime, entry_name: string, graph_name: string, ...)
            {
                let graph_path = self.workflow_path + F"/{graph_name}.je4workflow";
                
                let args = ...;
                return okay <| try!
                {
                    try! graph_data = je::file::readall(graph_path)
                        -> ok_or(F"无法读取的图文件 {graph_path}");
                        
                    try! d = self.vm_state->invoke(
                        "jeapi::statements::dispatch",
                        [entry_name: dynamic, graph_data: dynamic]->connect(args))
                    -> ok_or(F"调用Workflow `{self.workflow_path}` 的入口函数失败");
                    
                    return d-> unsafe::cast:<option<async<void>>>
                        -> ok_or(F"无法找到入口 `{entry_name}`");
                } catch! e {
                    je::logerr(F"发起 Workflow `{self.workflow_path}` 失败: {e}");
                };
            }
        }
        
        static let registered_dispathchers = {}mut: map<string, (GraphContext, ...)=> async<void>>;
        public func register_dispatcher(f: (GraphContext, ...)=> async<void>, name: string)
        {
            if (registered_dispathchers->contains(name))
                std::panic(F"Dispatcher 名称 {name} 已被注册");
                
            registered_dispathchers->set(name, f);
        }
        extern func dispatch(name: string, graph_data: string, ...)=> option<async<void>>
        {
            let (graph, _) = load_graph_and_extra_data(graph_data)
                ->ok_or("无法解析图数据")
                ->unwrap;
                                
            try! f = registered_dispathchers->get(name);
            return_value! f(graph, ......);
        }
    }
}

import je;

import pkg::worst;
import pkg::try;

import builtin::api::serialize::main;

using je;

namespace jeapi::loader
{
    using chunkloader = struct{
        m_mx: je::rmutex,

        m_chunks: dict<int, dict<int, chunk>>,
        m_world: je::world,
    }
    {
        func _get_located_path(path: string)
        {
            return path->subto(0, path->rfind("/") + 1);
        }

        using chunk = struct{
            m_cached_layers: dict<int, layer>,
            m_world: je::world,
        }
        {
            union load_state
            {
                wait,
                loaded(je::entity),
                failed,
            }

            using layer = struct{
                m_size: int,
                m_path: string,
                m_state: mut load_state,
                m_walkable: array<bool>,
            }
            {
                alias InstanceEntityCallbackT = (graphic::texture, array<bool>)=> option<entity>;

                func create(chunk_layer_path: string)
                {
                    match (file::readall(chunk_layer_path)
                        =>> \dat = dat->dict::deserialize;)
                    {
                    value(dat)?
                    {
                        try! sz = dat->get("size": dynamic)=>> \v = v->trycast:<int>;;
                        try! tex = dat->get("texture": dynamic)=>> \v = v->trycast:<string>;;
                        try! wkable = dat->get("walkable": dynamic)
                            =>> \v = v->trycast:<array<dynamic>>;
                            ->> \v = v
                                ->> \e = e->valor(false);
                                ;
                            ;

                        let parent_path = _get_located_path(chunk_layer_path);

                        return value(layer{
                            m_size = sz,
                            m_path = parent_path + tex,
                            m_state = mut load_state::wait,
                            m_walkable = wkable,
                        });
                    }
                    none? return none;
                    }
                }
                func close(self: layer)
                {
                    self->unload;
                }
                
                func instance(self: layer, u: option<universe>, callback: InstanceEntityCallbackT)
                {
                    match (self.m_state)
                    {
                    wait?
                    {
                        match (graphic::texture::load(u, self.m_path)=>> \t = callback(t, self.m_walkable);)
                        {
                        value(e)?
                            self.m_state = load_state::loaded(e);
                        none?
                            self.m_state = load_state::failed;
                        }
                    }
                    _?;
                    }
                }
                func unload(self: layer)
                {
                    match (self.m_state)
                    {
                    loaded(e)?
                    {
                        self.m_state = load_state::wait;
                        e->close();
                    }
                    _?;
                    }
                }
            }

            func create(w: je::world, chunk_path: string)
            {
                match (file::readall(chunk_path)
                    =>> \dat = dat->dict::deserialize;
                    =>> \dat = dat->get("layers": dynamic);
                    =>> \dat = dat->trycast:<dict<dynamic, dynamic>>;)
                {
                value(dat)?
                {
                    let parent_path = _get_located_path(chunk_path);
                    let result = {}mut: map<int, layer>;

                    for (let layer_id, layer_path : dat)
                    {
                        do try::exec(
                            func()
                            {
                                try! id = layer_id->trycast:<int>;
                                try! path = layer_path->trycast:<string>;

                                try! layer = layer::create(parent_path + path);

                                result->set(id, layer);

                                return option::value(do nil);
                            })->
                        catch(func(_)
                            {
                            });
                    }

                    return option::value(
                        chunk{
                            m_cached_layers = result->unsafe::asdict,
                            m_world = w,
                        });
                    
                }
                none?
                    return none;
                }
            }
            func close(self: chunk)
            {
                for (let _, l : self.m_cached_layers)
                    l->close();
            }

            public func instance(self: chunk, callback: layer::InstanceEntityCallbackT)
            {
                let u = option::value(self.m_world->get_universe());

                for (let _, l : self.m_cached_layers)
                    l->instance(u, callback);
            }
            public func unload(self: chunk)
            {
                for (let _, l : self.m_cached_layers)
                    l->unload();
            }
        }

        public func create(w: je::world, path: string)
        {
            let parent_path = path->subto(0, path->rfind("/") + 1);
            match (file::readall(path)=>>\dat = dat->dict::deserialize;)
            {
            value(dat)?
            {
                let result = {}mut: map<int, dict<int, chunk>>;

                return 
                    try::exec(
                        func()
                        {
                            for (let dx, dv : dat)
                            {
                                try! x = dx->trycast:<int>;
                                try! v = dv->trycast:<dict<dynamic, dynamic>>;

                                let chunk_line = {}mut: map<int, chunk>;

                                for (let dy, cpath : v)
                                {
                                    do try::exec(
                                        func()
                                        {
                                            try! y = dy->trycast:<int>;
                                            try! path = cpath->trycast:<string>;
                                            try! newchunk = chunk::create(w, parent_path + path);

                                            chunk_line->set(y, newchunk);

                                            return option::value(do nil);
                                        })
                                    -> catch(func(_)
                                        {
                                        });
                                }

                                result->set(x, chunk_line->unsafe::asdict);
                            }

                            return option::value(
                                chunkloader{
                                    m_mx = rmutex::create(),
                                    m_chunks = result->unsafe::asdict,
                                    m_world = w,
                                });

                        })-> 
                    catch(func(_)
                        {
                            for (let _, cs : result)
                                for (let _, c : cs)
                                    c->close();
                        });
            }
            none?
                return option::none;
            }
        }
        func lock_do<T>(self: chunkloader, job: ()=> T)
        {
            self.m_mx->lock();
            let ret = job();
            self.m_mx->unlock();
            return ret;
        }
        public func close(self: chunkloader)
        {
            for (let _, cs : self.m_chunks)
                for (let _, c : cs)
                    c->close;
        }
        public func get_chunk(self: chunkloader, x: int, y: int)
        {
            return self->lock_do(func()
            {
                return self.m_chunks->get(x)=>> \ys = ys->get(y);;
            });
        }
    }
}
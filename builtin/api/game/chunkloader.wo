import je;
import pkg::worst;
import builtin::api::serialize::main;

using je;

namespace jeapi::loader
{
    using chunkloader = struct{
        m_mx: je::rmutex,

        m_loaded_chunks: dict<int, dict<int, chunk>>,
        m_world: je::world,
    }
    {
        func _get_located_path(path: string)
        {
            return path->subto(0, path->rfind("/") + 1);
        }

        using chunk = struct{
            m_cached_layers: dict<int, layer>,
        }
        {
            union load_state
            {
                wait(string),
                loaded(je::entity),
                failed,
            }

            using layer = struct{
                m_size: int,
                m_state: mut load_state,
                m_walkable: array<bool>,
            }
            {
                public func create(chunk_layer_path: string)
                {
                    match (file::readall(chunk_layer_path)
                        =>> \dat = dat->dict::deserialize;)
                    {
                    value(dat)?
                    {
                        try! sz = dat->get("size": dynamic)=>> \v = v->trycast:<int>;;
                        try! tex = dat->get("texture": dynamic)=>> \v = v->trycast:<string>;;
                        try! wkable = dat->get("walkable": dynamic)
                            =>> \v = v->trycast:<array<dynamic>>;
                            ->> \v = v
                                ->> \e = e->valor(false);
                                ;
                            ;

                        let parent_path = _get_located_path(chunk_layer_path);

                        return value(layer{
                            m_size = sz,
                            m_state = need_load(parent_path + tex),
                            m_walkable = wkable,
                        });
                    }
                    none? return none;
                    }

                    return layer{
                        m_size = texture,
                        m_state = load_state::wait(tex),
                        m_walkable = wkable,
                    };
                }
                public func close(self: layer)
                {
                    match (self.m_state)
                    {
                    loaded(e)? e->close();
                    _?;
                    }
                }
            }

            public func create(chunk_path: string)
            {
                match (file::readall(chunk_path)
                    =>> \dat = dat->dict::deserialize;
                    =>> \dat = dat->get("layers": dynamic);
                    =>> \dat = dat->trycast:<dict<dynamic, dynamic>>;)
                {
                value(dat)?
                {
                    let parent_path = _get_located_path(chunk_path);
                    let result = {}mut: map<int, layer>;

                    return try::exec(
                        func()
                        {
                            for (let layer_id, layer_path : dat)
                            {
                                try! id = layer_id->trycast:<int>;
                                try! path = layer_path->trycast:<string>;

                                result->set(id, layer::create(parent_path + path));
                            }

                            return option::value(
                                chunk{
                                    m_cached_layers = result->unsafe::asdict,
                                });
                        })->
                        catch (func(_)
                        {
                            // 如果区块加载失败，此处要把已经加载进来的关掉
                            for (let _, l : result)
                                l->close();
                        });
                    
                }
                none?
                    return none;
                }
            }
        }

        public func create(w: je::world, path: string)
        {
            let parent_path = path->subto(0, path->rfind("/") + 1);
            match (file::readall(path)=>>\dat = dat->dict::deserialize;)
            {
            value(dat)?
            {
                let chunk_list = {}mut: map<int, dict<int, chunk>>;
                for (let x, v : dat)
                {
                    if (x is int == false || v is dict<dynamic, dynamic> == false)
                        // 损坏的区块文件
                        return result::err(F"损坏的区块文件: {path}");
                    
                    let chunk_line = {}mut: map<int, chunk>;
                    for (let y, cpath : v as dict<dynamic, dynamic>)
                    {
                        if (y is int == false || cpath is string == false)
                            // 损坏的区块文件
                            return result::err(F"损坏的区块文件: {path}");
                        
                        chunk_line->set(
                            y as int,
                            chunk::create(
                                w, x as int, y as int, parent_path + cpath as string));                    
                    }
                    chunk_list->set(x as int, chunk_line->unsafe::asdict);
                }
                return result::ok(chunkloader{
                        m_mx = je::rmutex::create(),
                        m_loaded_chunks = chunk_list->unsafe::asdict,
                    });
            }
            none?
                return result::err(F"无法打开区块文件: {path}");
            }
        }
        func lock_do<T>(self: chunkloader, job: ()=> T)
        {
            self.m_mx->lock();
            let ret = job();
            self.m_mx->unlock();
            return ret;
        }
        public func load(self: chunkloader, reaload: bool, x: int, y: int, callback: (je::world, int, int, int, graphic::texture)=> option<je::entity>)
        {
            self->lock_do(func()
            {
                match (self.m_loaded_chunks->get(x)=>>\cs = cs->get(y);)
                {
                value(c)?
                    c->load(reaload, callback);
                none?;
                }
            });
        }
        public func close(self: chunkloader)
        {
            for (let _, cs : self.m_loaded_chunks)
                for (let _, c : cs)
                    c->unload;
        }
        public func get_chunk(self: chunkloader, x: int, y: int)
        {
            return self->lock_do(func()
            {
                return self.m_loaded_chunks->get(x)->get(y);
            });
        }
    }
}
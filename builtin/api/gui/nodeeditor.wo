import je;
import je::gui;

import pkg::interface;
import pkg::iterator;
import pkg::worst;
import pkg::try;

using je;
using je::gui;
using je::gui::node_editor;

namespace jeapi::gui
{
    using node_editor = struct{
        title: string,
        context: node_editor::EditorContext,

        links: map<LinkId, (PinId, PinId)>,
        nodes: map<NodeId, _Node>,
        inputpins: map<PinId, _InputPin>,
        outputpins: map<PinId, _OutputPin>,
        producers: map<PinId, _Producer>,

        allocated_id: mut int,

        __current_node_id: mut option<NodeId>,
        __allocating_producers: mut option<vec<_Producer>>,
        __allocating_input_nodes: mut option<vec<_InputPin>>,
        __allocating_output_nodes: mut option<vec<_OutputPin>>,

        context_menu_open_flag: mut bool,
        _last_hoverd_node: mut option<NodeId>,
        _last_hoverd_link: mut option<LinkId>,
        _last_hoverd_pin: mut option<PinId>,

        input_port_texture: option<je::graphic::texture>,
        output_port_texture: option<je::graphic::texture>,

        node_info_dic: mut option<_NodeInfoDict>,
        node_info_flat_dic: mut option<dict<string, _NodeInfo>>,
        context_menu: mut option<()=> void>,

        executing_jobs: vec<()=> void>,
    }
    {
        interface! IProducer
        {
            public func reset(self: IProducer)=> void; // 重置迭代器状态
            public func finished(self: IProducer)=> bool; // 检测迭代是否结束
            public func tostring(self: IProducer)=> string;
            public func parse(self: IProducer, dat: string)=> void;
            public func edit(self: IProducer, tag: string)=> void;
        }

        interface! ITyped
        {
            public func tostring(self: ITyped)=> string;
            public func parse(self: ITyped, value: string)=> void;
            public func edit(self: ITyped, tag: string)=> void;
            public func typename(self: ITyped)=> string;
            public func maxoutput(self: ITyped)=> int;
            public func color(self: ITyped)=> (int, int, int, int);

            require Self::create is ()=> Self;
        }

        interface! INode
        {
            public func name(self: INode)=> string;
            public func color(self: INode)=> (int, int, int, int);
            public func onUpdate(self: INode, editor: node_editor, tag: string)=> void;
            public func onDelete(self: INode, editor: node_editor)=> bool;
            public func onEval(self: INode, editor: node_editor)=> bool;
            public func tostring(self: INode)=> string;
            public func parse(self: INode, value: string)=> void;

            require Self::create is (node_editor)=> Self;
        }
        namespace INode
        {
            public let creator<T> = \e: node_editor = INode::create(T::create(e));;
        }

        public alias NodeDict = dict<string, NodeDictItem>;
        public union NodeDictItem
        {
            Node((node_editor)=>INode),
            Dict(NodeDict),
        }
        using _NodeInfo = struct
        {
            name: string,
            input_types: array<string>,
            output_types: array<string>,
            generator: (node_editor)=>INode,
        };

        alias _NodeInfoDict = dict<string, _NodeInfoDictItem>;
        union _NodeInfoDictItem
        {
            Node(_NodeInfo),
            Dict(_NodeInfoDict),
        }
        using _Producer = struct{
            id: PinId,
            producer: IProducer,
            name: string,
        }
        {
            func update(self: _Producer)
            {
                gui::Text(self.name);

                gui::PushStyleColor(ImGuiCol::ImGuiCol_Text, (0, 0, 0, 255));
                self.producer->edit(F"##{self.name}");
                gui::PopStyleColor(1);
            }
        }
        using _InputPin = struct
        {
            id: PinId,
            nodeid: NodeId,
            typeval: ITyped,
            name: string,
            linked_pin: mut option<PinId>,
        }
        {
            func update(self: _InputPin, context: node_editor)
            {
                match (context.input_port_texture)
                {
                value(img)? ImageSizeColor(img, 20., 20., self.typeval->color);
                none? Dummy((20., 20.));
                }
                
                let (lt, rb) = GetItemRect();
                let c = ((lt.0 + rb.0) / 2., (lt.1 + rb.1) / 2.);

                SameLine();

                gui::Text(self.name);                

                BeginInputPin(self.id);
                PinPivotRect(c, c);
                PinRect(lt, rb);                
                
                EndPin();

                if (self.linked_pin->has == false)
                {
                    gui::PushStyleColor(ImGuiCol::ImGuiCol_Text, (0, 0, 0, 255));
                    self.typeval->edit(F"##{self.name}[{self.id}]");
                    gui::PopStyleColor(1);
                }
            }
        }
        using _OutputPin = struct
        {
            id: PinId,
            nodeid: NodeId,
            typeval: ITyped,
            name: string,
            linked_pins: vec<PinId>,
        }
        {
            func update(self: _OutputPin, context: node_editor)
            {
                gui::Text(self.name); 
                SameLine();

                match (context.output_port_texture)
                {
                value(img)? ImageSizeColor(img, 20., 20., self.typeval->color);
                none? Dummy((20., 20.));
                }
                let (lt, rb) = GetItemRect();
                let c = ((lt.0 + rb.0) / 2., (lt.1 + rb.1) / 2.);

                BeginOutputPin(self.id);

                PinPivotRect(c, c);
                PinRect(lt, rb);
              
                EndPin();
            }
        }

        using Input<T> = struct
        {
            val: T,
            pin: _InputPin,
            context: node_editor,
        }
        {
            func create<T>(val: T, pin: _InputPin, ctx: node_editor)
                where require!(T: ITyped);
            {
                return Input
                {
                    val = val,
                    pin = pin,
                    context = ctx,
                };
            }
            public func eval<T>(self: Input<T>)=> T
            {
                match (self.pin.linked_pin)
                {
                value(linked_output)?
                    {
                        let outpin = self.context.outputpins[linked_output];
                        self.val->parse(outpin.typeval->tostring());
                    }
                none?;
                }
                return self.val;
            }
        }

        using _Node = struct
        {
            id: NodeId,
            instance: INode,

            producers: array<_Producer>,
            inputs: array<_InputPin>,
            outputs: array<_OutputPin>,

            position: mut (real, real),

            evaled: mut bool,
        }
        {
            func update(self: _Node, editor: node_editor)
            {
                node_editor::PushStyleColor(StyleColor::StyleColor_NodeBg, self.instance->color());
                BeginNode(self.id);
                Text(self.instance->name());

                BeginGroup();
                for (let pp : self.producers)
                {
                    pp->update();
                }
                for (let ip : self.inputs)
                {
                    ip->update(editor);
                }
                EndGroup();
                SameLine();
                Dummy((1., 20.));
                SameLine();
                BeginGroup();
                for (let op : self.outputs)
                {
                    op->update(editor);
                }
                EndGroup();

                gui::PushStyleColor(ImGuiCol::ImGuiCol_Text, (0, 0, 0, 255));
                self.instance->onUpdate(editor, F"##{self.instance->name()}[{self.id}]");
                gui::PopStyleColor(1);

                EndNode();
                node_editor::PopStyleColor(1);

                self.position = GetNodePosition(self.id);
            }
            public func dump_data(self: _Node)
            {
                return {
                    ["type"] = self.instance->name(): dynamic,
                    ["producers"] = self.producers->>\p = p.producer->tostring();: dynamic,
                    ["inputs"] = self.inputs->>\i = i.typeval->tostring();: dynamic,
                    ["data"] = self.instance->tostring(): dynamic,
                }->serialize()->val;
            }
        }

        func _get_all_link_of(self: node_editor, pinid: PinId)=> array<LinkId>
        {
            let mut result = []mut: vec<LinkId>;
            for (let (lid, (aid, bid)) : self.links)
            {
                if (aid == pinid || bid == pinid)
                {
                    result->add(lid);
                }
            }
            return result->unsafe::asarray;
        }
        func _check_linked(self: node_editor, a: PinId, b: PinId)=> bool
        {
            for (let (_, (aid, bid)) : self.links)
            {
                if (aid == a && bid == b)
                    return true;
            }
            return false;
        }
        func _draw_link(self: node_editor, linkid: LinkId, a: PinId, b: PinId)
        {
            let c = self.inputpins[a].typeval->color();
            Link(linkid, a, b, c, 2.);
        }
        func _generate_node_impl(self: node_editor, generator: (node_editor)=>INode)
        {
            let new_id = self->alloc_id:<NodeId>();

            self.__current_node_id = option::value(new_id);
            self.__allocating_producers = option::value([]mut);
            self.__allocating_input_nodes = option::value([]mut);
            self.__allocating_output_nodes = option::value([]mut);

            let node = _Node{
                id = new_id,
                instance = INode::create(generator(self)),
                producers = self.__allocating_producers->val->unsafe::asarray,
                inputs = self.__allocating_input_nodes->val->unsafe::asarray,
                outputs = self.__allocating_output_nodes->val->unsafe::asarray,

                position = mut (0., 0.),

                evaled = mut false,
            };

            self.__current_node_id = option::none;
            self.__allocating_producers = option::none;
            self.__allocating_input_nodes = option::none;
            self.__allocating_output_nodes = option::none;

            return node;
        }
        func _generate_node_dict_item(self: node_editor, item: NodeDictItem, out_flat_map: map<string, _NodeInfo>)
            => _NodeInfoDictItem
        {
            match (item)
            {
            Node(generator)?
            {
                let ninstance = self->_generate_node_impl(generator);
                let info = _NodeInfo{
                        name = ninstance.instance->name(),
                        input_types = ninstance.inputs->>\i = i.typeval->typename();,
                        output_types = ninstance.outputs->>\o = o.typeval->typename();,
                        generator = generator,
                    };
                out_flat_map->set(info.name, info);
                return _NodeInfoDictItem::Node(info);
            }
            Dict(d)?
            {
                return _NodeInfoDictItem::Dict(self->_generate_node_dict(d, out_flat_map));
            }
            }
        }
        func _generate_node_dict(self: node_editor, nodedict: NodeDict, out_flat_map: map<string, _NodeInfo>)
            => _NodeInfoDict
        {
            let result = {}mut: map<string, _NodeInfoDictItem>;
            for (let (name, item) : nodedict)
            {
                result->set(name, self->_generate_node_dict_item(item, out_flat_map));
            }
            return result->unsafe::asdict;
        }
        public func _restore_and_create_node(self: node_editor, data: string)
        {
            return try!
            {
                try! dat = data->dict::deserialize();
                try! node_type = dat->get("type": dynamic)=>>\v = v->trycast:<string>;;
                try! node_data = dat->get("data": dynamic)=>>\v = v->trycast:<string>;;
                try! mode_info = self.node_info_flat_dic=>>\d = d->get(node_type);;
                let inputs = dat->get("inputs": dynamic)
                    -> valor([]: dynamic)
                    -> valor([]: array<string>)
                    ;
                let producers = dat->get("producers": dynamic)
                    -> valor([]: dynamic)
                    -> valor([]: array<string>)
                    ;

                let node = self->_generate_node_impl(mode_info.generator);
                node.instance->parse(node_data);
                for (let (idx, val): inputs->iter |> iterator::enumerate)
                {
                    do node.inputs->get(idx)->>\tval = tval.typeval->parse(val);;
                }
                for (let (idx, val): producers->iter |> iterator::enumerate)
                {
                    do node.producers->get(idx)->>\tval = tval.producer->parse(val);;
                }
                expected_value! node;
            };
        }
        using NodeDump = struct {
            nodes: array<(string, array<PinId>, array<PinId>, (real, real))>,
            links: array<(PinId, PinId)>,
        }
        {
            alias NodeDumpData = dict<string, array<array<dynamic>>>;
            public func dump(self: NodeDump)=> NodeDumpData
            {
                return {
                    ["nodes"] = self.nodes->>\dat = [dat.0: dynamic, dat.1: dynamic, dat.2: dynamic, [(dat.3).0, (dat.3).1]: dynamic];,
                    ["links"] = self.links->>\dat = [dat.0: dynamic, dat.1: dynamic];,
                };
            }
            public func restore(dat: NodeDumpData)=> option<NodeDump>
            {
                return try!
                {
                    try! nodes = dat->get("nodes");
                    try! links = dat->get("links");

                    let result_nodes = []mut: vec<(string, array<PinId>, array<PinId>, (real, real))>;
                    let result_links = []mut: vec<(PinId, PinId)>;
                    for (let dat: nodes)
                    {
                        do try!
                        {
                            try! node_data = dat->get(0)=>>\dat = dat->trycast:<string>;;
                            try! inputs = dat->get(1)=>> \dat = dat->trycast:<array<int>>;;
                            try! outputs = dat->get(2)=>> \dat = dat->trycast:<array<int>>;;
                            try! pos = dat->get(3)=>> \dat = dat->trycast:<array<real>>;;

                            result_nodes->add(
                                (
                                    node_data, 
                                    inputs->>\id = id: PinId;, 
                                    outputs->>\id = id: PinId;, 
                                    (pos[0], pos[1])
                                ));

                            expected_value!;
                        };
                    }
                    for (let dat: links)
                    {
                        do try!
                        {
                            try! aid = dat->get(0)=>>\dat = dat->trycast:<int>;;
                            try! bid = dat->get(1)=>>\dat = dat->trycast:<int>;;
                            result_links->add((aid: PinId, bid: PinId));

                            expected_value!;
                        };
                    }
                    expected_value! NodeDump{
                        nodes = result_nodes->unsafe::asarray,
                        links = result_links->unsafe::asarray,
                    };
                };
            }
        }
        public func restore(self: node_editor, dump: NodeDump)
        {
            let in_pin_id_map = {}mut: map<PinId, PinId>;
            let out_pin_id_map = {}mut: map<PinId, PinId>;

            for (let (node_data, inputs, outputs, pos) : dump.nodes)
            {
                do try!
                {
                    try! node = self->_restore_and_create_node(node_data);
                    for (let (idx, old_pinid) : inputs->iter |> iterator::enumerate)
                    {
                        do node.inputs->get(idx)
                            ->> \new_pinid = in_pin_id_map->set(old_pinid, new_pinid.id);
                            ;
                    }
                    for (let (idx, old_pinid) : outputs->iter |> iterator::enumerate)
                    {
                        do node.outputs->get(idx)
                            ->> \new_pinid = out_pin_id_map->set(old_pinid, new_pinid.id);
                            ;
                    }
                    self->_add_node_impl(node);
                    self->execute(func(){
                        SetNodePosition(node.id, pos);
                    });
                    expected_value!;
                };
            }

            for (let (aid, bid) : dump.links)
            {
                let new_aid = in_pin_id_map[aid];
                let new_bid = out_pin_id_map[bid];

                do self->_create_link(
                    self.inputpins[new_aid], self.outputpins[new_bid]);
            }
        }
        public func dump(self: node_editor)=> NodeDump
        {
            let nodes = []mut: vec<(string, array<PinId>, array<PinId>, (real, real))>;
            let links = []mut: vec<(PinId, PinId)>;

            for (let (_, node) : self.nodes)
            {
                let inputs = node.inputs->>\i = i.id;;
                let outputs = node.outputs->>\o = o.id;;
                nodes->add((node->dump_data(), inputs, outputs, node.position));
            }
            for (let (_, (aid, bid)) : self.links)
            {
                links->add((aid, bid));
            }
            return NodeDump{
                nodes = nodes->unsafe::asarray,
                links = links->unsafe::asarray,
            };
        }

        public func create(title: string, nodedict: NodeDict)
        {
            let self = node_editor
            {
                title = title,
                context = node_editor::CreateContext(),

                links = {}mut,
                nodes = {}mut,
                producers = {}mut,
                inputpins = {}mut,
                outputpins = {}mut,

                allocated_id = mut 100,

                __current_node_id = mut option::none,
                __allocating_producers = mut option::none,
                __allocating_input_nodes = mut option::none,
                __allocating_output_nodes = mut option::none,

                context_menu_open_flag = mut false,
                _last_hoverd_node = mut option::none,
                _last_hoverd_link = mut option::none,
                _last_hoverd_pin = mut option::none,

                input_port_texture = je::graphic::texture::load(
                    option::none, "!/builtin/icon/InputPin.png"),
                output_port_texture = je::graphic::texture::load(
                    option::none, "!/builtin/icon/OutputPin.png"),

                node_info_dic = mut option::none,
                node_info_flat_dic = mut option::none,
                context_menu = mut option::none,

                executing_jobs = []mut,
            };

            let flatmap = {}mut: map<string, _NodeInfo>;
            self.node_info_dic = option::value(
                self->_generate_node_dict(nodedict, flatmap));
            self.node_info_flat_dic = option::value(flatmap->unsafe::asdict);

            return self;
        }
        public func bind_context_menu(self: node_editor, menu: ()=> void)
        {
            self.context_menu = option::value(menu);
        }
        public func execute(self: node_editor, job: ()=> void)
        {
            self.executing_jobs->add(job);
        }
        func _create_link(self: node_editor, inpin: _InputPin, outpin: _OutputPin)
        {
             // Only accept one link for input
            for (let lid: self->_get_all_link_of(inpin.id))
                do DeleteLink(lid);
                
            let max_output = inpin.typeval->maxoutput(); 
            if (max_output > 0 && outpin.linked_pins->len() >= max_output)
            {
                // Remove first link
                let first = outpin.linked_pins[0];
                for (let lid: self->_get_all_link_of(first))
                    do DeleteLink(lid);

                do outpin.linked_pins->remove(0);
            }

            let linkid = self->alloc_id:<LinkId>();
            self.links->set(linkid, (inpin.id, outpin.id));

            inpin.linked_pin = option::value(outpin.id);
            outpin.linked_pins->add(inpin.id);

            return linkid;
        }
        func update_create(self: node_editor)
        {
            if (BeginCreate((0, 255, 255, 255), 2.))
            {
                match (QueryNewNode())
                {
                value(_)?
                    if (AcceptNewItem())
                    {
                        std::println("QueryNewNode() get!");   
                    }
                none?;
                }
                match (QueryNewLink())
                {
                value((mut a, mut b))?
                {
                    if (!self.inputpins->contain(a))
                    {
                        let tmp = a;
                        a = b;
                        b = tmp;
                    }

                    let mut accept = false;
                    match (self.inputpins->get(a)
                        =>> \inpin = self.outputpins->get(b)
                            ->> \outpin = (inpin, outpin);
                            ;)
                    {
                    value((inpin, outpin))?
                        {
                            // 此处检查类型
                            // TODO: 成环检测？
                            if (inpin.nodeid != outpin.nodeid &&
                                inpin.typeval->typename() == outpin.typeval->typename() &&
                                self->_check_linked(a, b) == false)
                            {
                                accept = true;
                                
                                if (AcceptNewItem())
                                {
                                    self->_draw_link(
                                        self->_create_link(inpin, outpin), 
                                        inpin.id, 
                                        outpin.id);
                                }
                            }
                        }
                    none?;
                    }
                    if (!accept)
                        RejectNewItemColor((255, 0, 0, 255), 2.);
                }
                none?;
                }
            }
            EndCreate();
        }
        func update_delete(self: node_editor)
        {
            if (BeginDelete())
            {
                for (;;)
                {
                    match (QueryDeletedNode())
                    {
                    value(nid)?
                    {
                        let node = self.nodes[nid];
                        if (node.instance->onDelete(self) && AcceptDeletedItem())
                        {
                            for (let p : node.producers)
                            {
                                do self.producers->remove(p.id);
                            }
                            for (let i : node.inputs)
                            {
                                for (let lid: self->_get_all_link_of(i.id))
                                    do DeleteLink(lid);
                                do self.inputpins->remove(i.id);
                            }
                            for (let o : node.outputs)
                            {
                                for (let lid: self->_get_all_link_of(o.id))
                                    do DeleteLink(lid);
                                do self.outputpins->remove(o.id);
                            }

                            do self.nodes->remove(nid);   
                        }
                        else
                        {
                            RejectDeletedItem();
                        }
                    }
                    none? break;
                    }
                }
                for (;;)
                {
                    match (QueryDeletedLink())
                    {
                    value(lid)?
                    {
                        if (AcceptDeletedItem())
                        {
                            let (aid, bid) = self.links[lid];
                            do self.links->remove(lid);

                            match (self.inputpins->get(aid))
                            {
                            value(inpin)?
                                match (inpin.linked_pin)
                                {
                                value(linked_id)?
                                    if (linked_id == bid)
                                        inpin.linked_pin = option::none;
                                none?;
                                }
                            none?;
                            }
                            //
                            match (self.outputpins->get(bid))
                            {
                            value(outpin)?
                                do outpin.linked_pins->remove(outpin.linked_pins->find(aid));
                            none?;
                            }
                        }
                    }
                    none? break;
                    }
                }
            }
            EndDelete();
        }
        func _menu_show_new_nodes(self: node_editor, d: _NodeInfoDict)
        {
            for (let (name, item) : d)
            {
                match (item)
                {
                Node(info)?
                {
                    if (MenuItem(info.name))
                        self->_add_node_impl(
                            self->_generate_node_impl(info.generator));
                }
                Dict(subd)?
                {
                    if (BeginMenu(name))
                    {
                        self->_menu_show_new_nodes(subd);
                        EndMenu();
                    }
                }
                }
            }
        }
        func _reset_eval_produce_state(_: node_editor, prods: array<_Producer>)
        {
            for (let p : prods)
                p.producer->reset();
        }
        func _reset_eval_node_state(_: node_editor, nodes: array<_Node>)
        {
            for (let n : nodes)
                n.evaled = false;
        }
        func __collect_nodes(self: node_editor, node: _Node, out: vec<_Node>)
        {
            if (out->find(node) == -1)
            {
                for (let inpin : node.inputs)
                {
                    match (inpin.linked_pin)
                    {
                    value(linked_id)?
                    {
                        let outpin = self.outputpins[linked_id];
                        let outnode = self.nodes[outpin.nodeid];
                        self->__collect_nodes(outnode, out);
                    }
                    none?;
                    }
                }
                out->add(node);
            }
        }
        func _collect_nodes(self: node_editor, node: _Node)
        {
            let result = []mut: vec<_Node>;
            self->__collect_nodes(node, result);
            return result->unsafe::asarray;
        }
        func _collect_producers(_: node_editor, nodes: array<_Node>)
        {
            let result = []mut: vec<_Producer>;
            for (let n : nodes)
            {
                for (let p : n.producers)
                    result->add(p);
            }
            return result->unsafe::asarray;
        }
        func _context_menu(self: node_editor, current_hovered: (option<NodeId>, option<LinkId>, option<PinId>))
        {
            if (BeginPopupContextItemLabel("NodeEditorMainContextMenu"))
            {
                if (! self.context_menu_open_flag)
                {
                    self.context_menu_open_flag = true;
                    self._last_hoverd_node = current_hovered.0;
                    self._last_hoverd_link = current_hovered.1;
                    self._last_hoverd_pin = current_hovered.2;
                }

                if (BeginMenu("新节点..."))
                {
                    self->_menu_show_new_nodes(self.node_info_dic->valor({}));
                    EndMenu();
                }
                match (self._last_hoverd_node)
                {
                value(nid)?
                    {
                        Separator();
                        if (MenuItem("复制"))
                        {
                            let node = self.nodes[nid];

                            do self->_restore_and_create_node(node->dump_data())
                                ->> \node = self->_add_node_impl(node);
                                ;
                        }
                        if (MenuItem("对此节点求值"))
                        {
                            let collected_nodes = self->_collect_nodes(self.nodes[nid]);
                            let collected_producers = self->_collect_producers(collected_nodes);

                            self->_reset_eval_produce_state(collected_producers);

                            let check_producers = 
                                \= collected_producers
                                    ->> \p = p.producer->finished();
                                    -> reduce(\l, r = l || r;)
                                    -> valor(true)
                                ;
                            ;

                            for (;;)
                            {
                                self->_reset_eval_node_state(collected_nodes);
                                for (let node: collected_nodes)
                                {
                                    if (! node.evaled)
                                    {
                                        node.evaled = true;
                                        if (! node.instance->onEval(self))
                                            break;
                                    }
                                }

                                if (check_producers())
                                    break;
                            }
                        }
                    }
                none?;
                }

                match (self.context_menu)
                {
                value(menu)? menu();
                none?;
                }

                EndPopup();
            }
            else
            {
                self.context_menu_open_flag = false;
                self._last_hoverd_node = option::none;
                self._last_hoverd_link = option::none;
                self._last_hoverd_pin = option::none;
            }

            match (current_hovered.0=>>\nid = self.nodes->get(nid);)
            {
            value(node)?
                {
                    BeginTooltip();
                    Text(node.instance->name());

                    if (!node.producers->empty() || !node.inputs->empty() || !node.outputs->empty())
                        TextDisabled("上一次求值结果：");

                    if (!node.producers->empty() || !node.inputs->empty())
                    {
                        TextDisabled("输入：");
                        for (let p : node.producers)
                            Text(F"{p.name}: {p.producer->tostring()}");
 
                        for (let p : node.inputs)
                            Text(F"{p.name}: {p.typeval->tostring()}");
                    }
                    if (!node.outputs->empty())
                    {
                        TextDisabled("输出：");
                        for (let p : node.outputs)
                            Text(F"{p.name}: {p.typeval->tostring()}");
                    }

                    EndTooltip();
                }
            none?;
            }
        }
        func _get_current_hoverd(_: node_editor)
        {
            return (
                GetHoveredNode(),
                GetHoveredLink(),
                GetHoveredPin(),
            );
            // _last_hoverd_node: mut option<NodeId>,
            // _last_hoverd_link: mut option<LinkId>,
            // _last_hoverd_pin: mut option<PinId>,
        }
        public func update(self: node_editor)
        {
            node_editor::Begin(self.title, self.context);
            gui::PushStyleColor(ImGuiCol::ImGuiCol_Text, (255, 255, 255, 255));

            for (let (_, n) : self.nodes)
                n->update(self);
     
            // 在此处理链接
            for (let (lid, (aid, bid)) : self.links)
            {
                // TODO: 颜色支持
                self->_draw_link(lid, aid, bid);
            }
            self->update_create();
            self->update_delete();
            
            for (let job : self.executing_jobs)
                job();

            self.executing_jobs->clear();

            gui::PopStyleColor(1);

            let hovered = self->_get_current_hoverd();
            node_editor::End();

            self->_context_menu(hovered);
        }

        func alloc_id<T>(self: node_editor)
            where std::is_same_type:<T, NodeId>
                || std::is_same_type:<T, PinId>
                || std::is_same_type:<T, LinkId>;
        {
            self.allocated_id += 1;
            return self.allocated_id: T;
        }

        public func add_producer<ProducerT>(self: node_editor, name: string)
            where require!(ProducerT: IProducer);
        {
            let producer = ProducerT::create();

            assertmsg(self.__allocating_producers->has,
                "请在节点的create方法中调用此函数.");

            let _producer = _Producer{
                id = self->alloc_id:<PinId>(), 
                producer = IProducer::create(producer),
                name = name,
            };
            self.__allocating_producers->val->add(_producer);

            return producer;
        }
        public func add_input<TypeT>(self: node_editor, name: string)
            where require!(TypeT: ITyped);
        {
            let val = TypeT::create();

            assertmsg(self.__allocating_input_nodes->has,
                "请在节点的create方法中调用此函数.");

            let _pin = _InputPin{
                id = self->alloc_id:<PinId>(), 
                nodeid = self.__current_node_id->val, 
                typeval = ITyped::create(val),
                name = name,
                linked_pin = mut option::none,
            };
            self.__allocating_input_nodes->val->add(_pin);
            return Input::create(val, _pin, self);
        }
        public func add_output<TypeT>(self: node_editor, name: string)
            where require!(TypeT: ITyped);
        {
            let val = TypeT::create();

            assertmsg(self.__allocating_output_nodes->has,
                "请在节点的create方法中调用此函数.");

            let _pin = _OutputPin{ 
                id = self->alloc_id:<PinId>(), 
                nodeid = self.__current_node_id->val, 
                typeval = ITyped::create(val),
                name = name,
                linked_pins = []mut,
            };
            self.__allocating_output_nodes->val->add(_pin);

            return val;
        }
        func _add_node_impl(self: node_editor, node: _Node)
        {
            self.nodes->set(node.id, node);

            for (let _producer : node.producers)
                self.producers->set(_producer.id, _producer);
            for (let _input : node.inputs)
                self.inputpins->set(_input.id, _input);
            for (let _output : node.outputs)
                self.outputpins->set(_output.id, _output);

            self->execute(
                \ = SetNodePosition(node.id, GetMousePos()););
        }
        public func add_node<NodeT>(self: node_editor)
            where require!(NodeT: INode);
        {
            let mut node = mutable::create(option::none: option<NodeT>);

            self->_add_node_impl(
                self->_generate_node_impl(
                    func(e)
                    {
                        let n = NodeT::create(e);
                        node->set(n);

                        return n;
                    }));

            return node->get->val;
        }
    }
}
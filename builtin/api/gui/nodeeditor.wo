import je;
import je::gui;

import pkg::interface;
import pkg::worst;
import pkg::try;

using je;
using je::gui;
using je::gui::node_editor;

namespace jeapi::gui
{
    using node_editor = struct{
        title: string,
        context: node_editor::EditorContext,

        links: map<LinkId, (PinId, PinId)>,
        nodes: map<NodeId, _Node>,
        inputpins: map<PinId, _InputPin>,
        outputpins: map<PinId, _OutputPin>,

        allocated_id: mut int,

        __current_node_id: mut option<NodeId>,
        __allocating_input_nodes: mut option<vec<_InputPin>>,
        __allocating_output_nodes: mut option<vec<_OutputPin>>,

        input_port_texture: option<je::graphic::texture>,
        output_port_texture: option<je::graphic::texture>,

        node_info_dic: mut option<_NodeInfoDict>,
        context_menu: mut option<()=> void>,

        executing_jobs: vec<()=> void>,
        
        context_menu_first_open_mouse: mut option<(real, real)>,
    }
    {
        interface! ITyped
        {
            public func tostring(self: ITyped)=> string;
            public func parse(self: ITyped, value: string)=> void;
            public func edit(self: ITyped, tag: string)=> void;
            public func typename(self: ITyped)=> string;
            public func maxoutput(self: ITyped)=> int;
            public func color(self: ITyped)=> (int, int, int, int);

            require Self::create is ()=> Self;
        }

        interface! INode
        {
            public func name(self: INode)=> string;
            public func onUpdate(self: INode, editor: node_editor, tag: string)=> void;
            public func onDelete(self: INode, editor: node_editor)=> bool;

            require Self::create is (node_editor)=> Self;
        }
        namespace INode
        {
            public let creator<T> = \e: node_editor = INode::create(T::create(e));;
        }

        public alias NodeDict = dict<string, NodeDictItem>;
        public union NodeDictItem
        {
            Node((node_editor)=>INode),
            Dict(NodeDict),
        }
        using _NodeInfo = struct
        {
            name: string,
            input_types: array<string>,
            output_types: array<string>,
            generator: (node_editor)=>INode,
        };

        alias _NodeInfoDict = dict<string, _NodeInfoDictItem>;
        union _NodeInfoDictItem
        {
            Node(_NodeInfo),
            Dict(_NodeInfoDict),
        }

        using _InputPin = struct
        {
            id: PinId,
            nodeid: NodeId,
            typeval: ITyped,
            name: string,
            linked_pin: mut option<PinId>,
        }
        {
            func update(self: _InputPin, context: node_editor)
            {
                match (context.input_port_texture)
                {
                value(img)? ImageSizeColor(img, 20., 20., self.typeval->color);
                none? Dummy((20., 20.));
                }
                
                let (lt, rb) = GetItemRect();
                let c = ((lt.0 + rb.0) / 2., (lt.1 + rb.1) / 2.);

                SameLine();

                gui::Text(self.name);                

                BeginInputPin(self.id);
                PinPivotRect(c, c);
                PinRect(lt, rb);                
                
                EndPin();

                if (self.linked_pin->has == false)
                {
                    gui::PushStyleColor(ImGuiCol::ImGuiCol_Text, (0, 0, 0, 255));
                    self.typeval->edit(F"##{self.name}[{self.id}]");
                    gui::PopStyleColor(1);
                }
            }
        }
        using _OutputPin = struct
        {
            id: PinId,
            nodeid: NodeId,
            typeval: ITyped,
            name: string,
            linked_pins: vec<PinId>,
        }
        {
            func update(self: _OutputPin, context: node_editor)
            {
                gui::Text(self.name); 
                SameLine();

                match (context.output_port_texture)
                {
                value(img)? ImageSizeColor(img, 20., 20., self.typeval->color);
                none? Dummy((20., 20.));
                }
                let (lt, rb) = GetItemRect();
                let c = ((lt.0 + rb.0) / 2., (lt.1 + rb.1) / 2.);

                BeginOutputPin(self.id);

                PinPivotRect(c, c);
                PinRect(lt, rb);
              
                EndPin();
            }
        }

        using Input<T> = struct
        {
            typed: T,
            pin: _InputPin,
        }
        {
            func create<T>(typedval: T, pin: _InputPin)
                where require!(T: ITyped);
            {
                return Input
                {
                    typed = typedval,
                    pin = pin,
                };
            }
        }

        using _Node = struct
        {
            id: NodeId,
            instance: INode,
            inputs: array<_InputPin>,
            outputs: array<_OutputPin>,
        }
        {
            func update(self: _Node, editor: node_editor)
            {
                BeginNode(self.id);
                Text(self.instance->name());

                BeginGroup();
                for (let ip : self.inputs)
                {
                    ip->update(editor);
                }
                EndGroup();
                SameLine();
                Dummy((1., 20.));
                SameLine();
                BeginGroup();
                for (let op : self.outputs)
                {
                    op->update(editor);
                }
                EndGroup();

                gui::PushStyleColor(ImGuiCol::ImGuiCol_Text, (0, 0, 0, 255));
                self.instance->onUpdate(editor, F"##{self.instance->name()}[{self.id}]");
                gui::PopStyleColor(1);

                EndNode();
            }
            
            public func dump_data(self: _Node)
            {
                return {
                    "type": self.instance->name(): dynamic,
                    "datas": self.inputs->>\i = i.typeval->tostring();: dynamic,
                }->serialize();
            }
        }

        func _get_all_link_of(self: node_editor, pinid: PinId)=> array<LinkId>
        {
            let mut result = []mut: vec<LinkId>;
            for (let (lid, (aid, bid)) : self.links)
            {
                if (aid == pinid || bid == pinid)
                {
                    result->add(lid);
                }
            }
            return result->unsafe::asarray;
        }
        func _check_linked(self: node_editor, a: PinId, b: PinId)=> bool
        {
            for (let (_, (aid, bid)) : self.links)
            {
                if (aid == a && bid == b)
                    return true;
            }
            return false;
        }
        func _draw_link(self: node_editor, linkid: LinkId, a: PinId, b: PinId)
        {
            let c = self.inputpins[a].typeval->color();
            Link(linkid, a, b, c, 2.);
        }
        func _generate_node_impl(self: node_editor, generator: (node_editor)=>INode)
        {
            let new_id = self->alloc_id:<NodeId>();

            self.__current_node_id = option::value(new_id);
            self.__allocating_input_nodes = option::value([]mut);
            self.__allocating_output_nodes = option::value([]mut);

            let node = _Node{
                id = new_id,
                instance = INode::create(generator(self)),
                inputs = self.__allocating_input_nodes->val->unsafe::asarray,
                outputs = self.__allocating_output_nodes->val->unsafe::asarray,
            };

            self.__current_node_id = option::none;
            self.__allocating_input_nodes = option::none;
            self.__allocating_output_nodes = option::none;

            return node;
        }
        func _generate_node_dict_item(self: node_editor, item: NodeDictItem)
            => _NodeInfoDictItem
        {
            match (item)
            {
            Node(generator)?
            {
                let ninstance = self->_generate_node_impl(generator);
                return _NodeInfoDictItem::Node(
                    _NodeInfo{
                        name = ninstance.instance->name(),
                        input_types = ninstance.inputs->>\i = i.typeval->typename();,
                        output_types = ninstance.outputs->>\o = o.typeval->typename();,
                        generator = generator,
                    });
            }
            Dict(d)?
            {
                return _NodeInfoDictItem::Dict(self->_generate_node_dict(d));
            }
            }
        }
        func _generate_node_dict(self: node_editor, nodedict: NodeDict)
            => _NodeInfoDict
        {
            let result = {}mut: map<string, _NodeInfoDictItem>;
            for (let (name, item) : nodedict)
            {
                result->set(name, self->_generate_node_dict_item(item));
            }
            return result->unsafe::asdict;
        }
        public func _restore_and_create_node(self: _Node, data: string)
        {
            return try!
            {
                try! dat = data->dict::deserialize();
                try! node_type = dat->get("type": dynamic);
TODO;
                expected_value!;
            };
        }
        public func create(title: string, nodedict: NodeDict)
        {
            let self = node_editor
            {
                title = title,
                context = node_editor::CreateContext(),

                links = {}mut,
                nodes = {}mut,
                inputpins = {}mut,
                outputpins = {}mut,

                allocated_id = mut 100,

                __current_node_id = mut option::none,
                __allocating_input_nodes = mut option::none,
                __allocating_output_nodes = mut option::none,

                input_port_texture = je::graphic::texture::load(
                    option::none, "!/builtin/icon/InputPin.png"),
                output_port_texture = je::graphic::texture::load(
                    option::none, "!/builtin/icon/OutputPin.png"),

                node_info_dic = mut option::none,
                context_menu = mut option::none,

                executing_jobs = []mut,
                context_menu_first_open_mouse = mut option::none,
            };

            self.node_info_dic = option::value(
                self->_generate_node_dict(nodedict));

            return self;
        }
        public func bind_context_menu(self: node_editor, menu: ()=> void)
        {
            self.context_menu = option::value(menu);
        }
        public func execute(self: node_editor, job: ()=> void)
        {
            self.executing_jobs->add(job);
        }
        func update_create(self: node_editor)
        {
            if (BeginCreate((0, 255, 255, 255), 2.))
            {
                match (QueryNewNode())
                {
                value(_)?
                    if (AcceptNewItem())
                    {
                        std::println("QueryNewNode() get!");   
                    }
                none?;
                }
                match (QueryNewLink())
                {
                value((mut a, mut b))?
                {
                    if (!self.inputpins->contain(a))
                    {
                        let tmp = a;
                        a = b;
                        b = tmp;
                    }

                    let mut accept = false;
                    match (self.inputpins->get(a)
                        =>> \innode = self.outputpins->get(b)
                            ->> \outnode = (innode, outnode);
                            ;)
                    {
                    value((innode, outnode))?
                        {
                            // 此处检查类型
                            // TODO: 成环检测？
                            if (innode.nodeid != outnode.nodeid &&
                                innode.typeval->typename() == outnode.typeval->typename() &&
                                self->_check_linked(a, b) == false)
                            {
                                accept = true;
                                
                                if (AcceptNewItem())
                                {
                                    // Only accept one link for input
                                    for (let lid: self->_get_all_link_of(a))
                                        do DeleteLink(lid);
                                        
                                    let max_output = innode.typeval->maxoutput(); 
                                    if (max_output > 0 && outnode.linked_pins->len() >= max_output)
                                    {
                                        // Remove first link
                                        let first = outnode.linked_pins[0];
                                        for (let lid: self->_get_all_link_of(first))
                                            do DeleteLink(lid);

                                        do outnode.linked_pins->remove(0);
                                    }

                                    let linkid = self->alloc_id:<LinkId>();
                                    self.links->set(linkid, (a, b));
                                    self->_draw_link(linkid, a, b);

                                    innode.linked_pin = option::value(b);
                                    outnode.linked_pins->add(a);
                                }
                            }
                        }
                    none?;
                    }
                    if (!accept)
                        RejectNewItemColor((255, 0, 0, 255), 2.);
                }
                none?;
                }
            }
            EndCreate();
        }
        func update_delete(self: node_editor)
        {
            if (BeginDelete())
            {
                for (;;)
                {
                    match (QueryDeletedNode())
                    {
                    value(nid)?
                    {
                        let node = self.nodes[nid];
                        if (node.instance->onDelete(self) && AcceptDeletedItem())
                        {
                            for (let i : node.inputs)
                            {
                                for (let lid: self->_get_all_link_of(i.id))
                                    do DeleteLink(lid);
                            }
                            for (let o : node.outputs)
                            {
                                for (let lid: self->_get_all_link_of(o.id))
                                    do DeleteLink(lid);
                            }

                            do self.nodes->remove(nid);   
                        }
                        else
                        {
                            RejectDeletedItem();
                        }
                    }
                    none? break;
                    }
                }
                for (;;)
                {
                    match (QueryDeletedLink())
                    {
                    value(lid)?
                    {
                        if (AcceptDeletedItem())
                        {
                            let (aid, bid) = self.links[lid];
                            do self.links->remove(lid);

                            let innode = self.inputpins[aid];
                            let outnode = self.outputpins[bid];

                            match (innode.linked_pin)
                            {
                            value(linked_id)?
                                if (linked_id == bid)
                                    innode.linked_pin = option::none;
                            none?;
                            }
                            do outnode.linked_pins->remove(outnode.linked_pins->find(aid));
                        }
                    }
                    none? break;
                    }
                }
            }
            EndDelete();
        }
        func _menu_show_new_nodes(self: node_editor, d: _NodeInfoDict)
        {
            for (let (name, item) : d)
            {
                match (item)
                {
                Node(info)?
                {
                    if (MenuItem(info.name))
                        self->_add_node_impl(
                            self->_generate_node_impl(info.generator));
                }
                Dict(subd)?
                {
                    if (BeginMenu(name))
                    {
                        self->_menu_show_new_nodes(subd);
                        EndMenu();
                    }
                }
                }
            }
        }
        func _context_menu(self: node_editor)
        {
            if (BeginPopupContextItem())
            {
                if (! self.context_menu_first_open_mouse->has)
                    self.context_menu_first_open_mouse = option::value(GetMousePos());

                if (BeginMenu("新节点..."))
                {
                    self->_menu_show_new_nodes(self.node_info_dic->valor({}));
                }
                match (GetHoveredNode())
                {
                value(nid)?
                    {
                        if (MenuItem("复制"))
                        {
                            let node = self.nodes[nid];
                            TODO;
                        }
                    }
                none?;
                }

                match (self.context_menu)
                {
                value(menu)? menu();
                none?;
                }

                EndPopup();
            }
        }
        public func update(self: node_editor)
        {
            node_editor::Begin(self.title, self.context);
            gui::PushStyleColor(ImGuiCol::ImGuiCol_Text, (255, 255, 255, 255));

            for (let (_, n) : self.nodes)
                n->update(self);
     
            // 在此处理链接
            for (let (lid, (aid, bid)) : self.links)
            {
                // TODO: 颜色支持
                self->_draw_link(lid, aid, bid);
            }
            self->update_create();
            self->update_delete();
            
            for (let job : self.executing_jobs)
                job();

            self.executing_jobs->clear();

            gui::PopStyleColor(1);
            node_editor::End();
            
            self->_context_menu();            
        }

        func alloc_id<T>(self: node_editor)
            where std::is_same_type:<T, NodeId>
                || std::is_same_type:<T, PinId>
                || std::is_same_type:<T, LinkId>;
        {
            self.allocated_id += 1;
            return self.allocated_id: T;
        }

        public func add_input<TypeT>(self: node_editor, name: string)
            where require!(TypeT: ITyped);
        {
            let val = TypeT::create();

            assertmsg(self.__allocating_input_nodes->has,
                "请在节点的create方法中调用此函数.");

            let _pin = _InputPin{
                id = self->alloc_id:<PinId>(), 
                nodeid = self.__current_node_id->val, 
                typeval = ITyped::create(val),
                name = name,
                linked_pin = mut option::none,
            };

            self.inputpins->set(_pin.id, _pin);
            self.__allocating_input_nodes->val->add(_pin);
            return Input::create(val, _pin);
        }
        public func add_output<TypeT>(self: node_editor, name: string)
            where require!(TypeT: ITyped);
        {
            let val = TypeT::create();

            assertmsg(self.__allocating_output_nodes->has,
                "请在节点的create方法中调用此函数.");

            let _pin = _OutputPin{ 
                id = self->alloc_id:<PinId>(), 
                nodeid = self.__current_node_id->val, 
                typeval = ITyped::create(val),
                name = name,
                linked_pins = []mut,
            };

            self.outputpins->set(_pin.id, _pin);
            self.__allocating_output_nodes->val->add(_pin);
        }
        func _add_node_impl(self: node_editor, node: _Node)
        {
            self.nodes->set(node.id, node);
            self->execute(
                \ = SetNodePosition(
                    node.id, 
                    self.context_menu_first_open_mouse->valor(
                        GetMousePos()))
                ;);
        }
        public func add_node<NodeT>(self: node_editor)
            where require!(NodeT: INode);
        {
            self->_add_node_impl(
                self->_generate_node_impl(
                    \e = INode::create(NodeT::create(e));));
        }
    }
}
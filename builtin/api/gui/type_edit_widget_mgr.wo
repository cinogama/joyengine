// type_edit_widget_mgr.wo
// 管理类型及对应数据的

import je;
import je::gui;

using je;
using je::gui;

namespace jeapi::gui
{
    public alias TypedEditorMethod = (string/*token*/, je::native_value)=>bool;

    let _registed_editor_methods = {}mut: map<je::typeinfo, TypedEditorMethod>;
    let _custom_component_member_editor = {}mut: map<string, (string)=>option<string>>;

    public func register_custom_editor(typeflag: string, method: (string)=>option<string>)
    {
        if (_custom_component_member_editor->contain(typeflag))
            je::logwarn(F"重复注册的标签：{typeflag}");

        _custom_component_member_editor->set(typeflag, method);
    }
    
    func _str2vec2(str: string)
    {
        let x = mutable::create(0.), y = mutable::create(0.);
        do str->take_token("(")
            =>> \s = s->take_real();
            =>> func(snr){x->set(snr[1]); return snr[0]->take_token(",");}
            =>> \s = s->take_real();
            =>> func(snr){y->set(snr[1]); return snr[0]->take_token(")");}
            ;
        return (x->get, y->get);
    }

    // 直接在这里注册一下得了

    // 1. 注册2D阴影形状
    register_custom_editor("je_light2d_block_shape", func(dat: string)
    {
        using je::gui;

        let mut need_update = false;
        let datas = dat->split(";")
            =>> \dat = arr->len == 2 ? [(arr[0], arr[1])] | []
                where arr = dat->split(":");
            ;

        let length = datas
            ->  forall(\data = data[0] == "size";)
            ->  reduce(\l, _ = l;)
            ->> \data = data[1]: int;
            ->  valor(datas->len)
            ;

        let mut update_str = "size:";

        match (InputInt("size", length))
        {
        value(newsize)?
        {
            need_update = true;
            update_str += (newsize < 0 ? 0 | newsize): string;
        }
        none?
            update_str += length: string;
        }

        update_str += ";";

        for (let index, (layer, factor) : datas->forall(\d = d[0]!="size";))
        {
            Text(F"{layer}:");      
            SameLine();
            let (posx, posy) = _str2vec2(factor);
            let (new_posx, new_posy) = InputFloat2(F"##factor{index}", posx, posy)->valor((posx, posy));

            if (new_posx != posx || new_posy != posy)
                need_update = true;

            update_str += F"{layer}:({new_posx},{new_posy});";
        }
            
        if (need_update)
            return option::value(update_str);
        return option::none;
    });

    register_custom_editor("je_file", func(dat: string)
    {
        using je::gui;
        return jeapi::gui::widget::File("文件", dat == "" ? "<无>" | dat);
    });

    register_custom_editor("je_animation_list", func(dat: string)
    {
        using je::gui;

        let mut need_update = false;
        let size_datas = dat->split(";");
        let size = size_datas->get(0)->valor("0"): int;
        let datas = (size_datas->empty ? [] | size_datas->sub(1))
            ->> \data = data->split("|");
            ;

        let mut update_str = "";

        match (InputInt("size", size))
        {
        value(newsize)?
        {
            need_update = true;
            update_str += (newsize < 0 ? 0 | newsize): string;
        }
        none?
            update_str += size: string;
        }

        update_str += ";";

        for (let i, dat : datas)
        {
            Separator();

            if (dat->len != 3) continue;

            match (jeapi::gui::widget::File(F"动画##{i}", dat[0]))
            {
            value(path)?
                {
                    need_update = true;
                    update_str += path + "|";
                }
            none?
                update_str += dat[0] + "|";
            }

            match (InputText(F"动作##{i}", dat[1]))
            {
            value(act)?
                {
                    need_update = true;
                    update_str += act + "|";
                }
            none?
                update_str += dat[1] + "|";
            }

            match (CheckBox(F"循环##{i}", dat[2] == "true"))
            {
            value(loop)?
                {
                    need_update = true;
                    update_str += (loop ? "true;" | "false;");
                }
            none?
                update_str += dat[2] + ";";
            }
        }

        if (need_update)
            return option::value(update_str);
        return option::none;
    });

    public func register_editor_for_native_value(type: je::typeinfo, method: TypedEditorMethod)
    {
        if (_registed_editor_methods->contain(type))
            std::panic(F"不允许重复添加{type->name}的编辑方法");
            
        _registed_editor_methods->set(type, method);
    }
    public func edit_cur_native_value(tag: string, type: je::typeinfo, native_value: je::native_value)
    {
        let mut result = false;
        do InvisibleButton(F"##{tag}$PADDING", (2., 1.));
        SameLine();
        BeginGroup();
        match (_registed_editor_methods->get(type))
        {
        value(method)?
            result = method(tag, native_value);
        none?
            {
                // 没有注册的特殊控件，使用底层自带的to_string方法处理
                let member_data = native_value->to_string(type);
                if (member_data->beginwith("#"))
                {
                    // 这个member需要特殊处理
                    Text(tag);

                    let spec_method = member_data->subto(1, member_data->findfrom("#", 1) - 1);
                    match (_custom_component_member_editor->get(spec_method))
                    {
                    none?
                        TextDisabled(F"未找到编辑{spec_method}的自定义编辑器");
                    value(method)?
                        do method(member_data->sub(spec_method->len + 2))
                            ->> \update_str = native_value->parse(type, F"#{spec_method}#" + update_str);
                            ;
                    }
                }
                else
                    do InputText(tag, member_data) 
                        ->> \data_str = native_value->parse(type, data_str);;
            }
        }
        EndGroup();

        return result;
    }

    register_editor_for_native_value(je::typeinfo::int, func(tag, nvalue){
        return InputInt(F"##{tag}", nvalue->int)->>\iv = nvalue->set_int(iv);->has;
    });
    register_editor_for_native_value(je::typeinfo::int2, func(tag, nvalue){
        return InputInt2(F"##{tag}", nvalue->int2...)->>\iv2 = nvalue->set_int2(iv2...);->has;
    });
    register_editor_for_native_value(je::typeinfo::float, func(tag, nvalue){
        return InputFloat(F"##{tag}", nvalue->float)->>\fv = nvalue->set_float(fv);->has;
    });
    register_editor_for_native_value(je::typeinfo::float2, func(tag, nvalue){
        return InputFloat2(F"##{tag}", nvalue->float2...)->>\fv2 = nvalue->set_float2(fv2...);->has;
    });
    register_editor_for_native_value(je::typeinfo::float3, func(tag, nvalue){
        return InputFloat3(F"##{tag}", nvalue->float3...)->>\fv3 = nvalue->set_float3(fv3...);->has;
    });
    register_editor_for_native_value(je::typeinfo::float4, func(tag, nvalue){
        return InputFloat4(F"##{tag}", nvalue->float4...)->>\fv4 = nvalue->set_float4(fv4...);->has;
    });
    register_editor_for_native_value(je::typeinfo::quat, func(tag, nvalue){
        return InputFloat3(F"##{tag}", nvalue->euler3...)->>\fv3 = nvalue->set_euler3(fv3...);->has;
    });
    register_editor_for_native_value(je::typeinfo::bool, func(tag, nvalue){
        return CheckBox(F"##{tag}", nvalue->bool)->>\bv = nvalue->set_bool(bv);->has;
    });
}
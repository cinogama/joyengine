import je.tickline;

using je::gui;

namespace editor::Tickline
{
    public using IAction = struct{
        m_unique_tag: string,
        m_abstract_function: ()=> string,
        m_edit_function: ()=> void,
        m_gen_function: ()=> string,
        m_serialize_function: ()=> string,
    }
    {
        let unique_token_type_map = {}mut: map<int, string>;
        let deserialize_functions = {}mut: map<string, (string)=> IAction>;

        public func register_action<ActionT>(unique_token: string)
        {
            assert(! deserialize_functions->contain(unique_token));
            assert(! unique_token_type_map->contain(typeid:< ActionT>));

            deserialize_functions->set(
                unique_token, 
                \seridata = IAction::create(ActionT::deserialize(seridata));
            );
            unique_token_type_map->set(typeid:< ActionT>, unique_token);
        }
        public func deserialize(unique_token: string, data: string)
        {
            return deserialize_functions[unique_token](data);
        }

        public func create<ActionT>(act: ActionT)
        {
            return IAction{
                m_unique_tag = unique_token_type_map[typeid:< ActionT>],
                m_abstract_function = \= act->abstract();,
                m_edit_function = \= act->edit();,
                m_gen_function = \= act->gen();,
                m_serialize_function = \= act->serialize();,
            };
        }
        public func abstract(self: IAction)
        {
            return self.m_abstract_function();
        }
        public func edit(self: IAction)
        {
            self.m_edit_function();
        }
        public func gen(self: IAction)
        {
            return self.m_gen_function();
        }
        public func serialize(self: IAction)
        {
            return self.m_serialize_function();
        }
    }

    public using ActionBlock = struct{
        m_actions: vec<IAction>,
        m_uid: string, // 注意这个uid不用于其他地方，仅用于区分同名gui控件
    }
    {
        public func create()
        {
            return ActionBlock{m_actions = []mut, m_uid = je::uid(),};
        }
        public func edit(self: ActionBlock, depth: int)
        {
            let takeplace = string::create(depth * 3, ' ');
            let mut after_edit_do = \= impure do nil;;

            for (let idx, act : self.m_actions)
            {
                do Selectable(takeplace + act->abstract());
                if (BeginPopupContextItem())
                {
                    if (MenuItem("删除"))
                        after_edit_do = \ = do self.m_actions->remove(idx);;

                    EndPopup();
                }

                act->edit();
            }
            do Selectable(F"{takeplace}@##{self.m_uid}");
            after_edit_do();
        }
        public func gen(self: ActionBlock)
        {
            return self.m_actions
                ->> \iact = iact->gen;
                ->  reduce(\l, r = l + r;)
                ->  valor("")
                ;
        }
        public func serialize(self: ActionBlock)
        {
            return self.m_actions
                ->> \iact = [iact.m_unique_tag, iact->serialize];
                as vec<array<string>>: string;
        }
        public func deserialize(dat: string)
        {
            std::panic("TODO!");
        }
    }
    
    public using Object = struct{
        m_name: mut string,
        m_euid: je::tickline::euid_t,
        m_data: mut string,     // json
        m_actions : ActionBlock,
    }
    {
        public func generate_code(self: Object)
        {
            return F"func(e: je::entity)\{{self.m_actions->gen}\}";
        }
        public func create(e: je::entity)
        {
            return jeapi::serialize::entity(e)
                ->> \dat = Object{
                        m_name = mut e->editor::name,
                        m_euid = je::uid(): je::tickline::euid_t,
                        m_data = mut datjson,
                        m_actions = ActionBlock::create(),
                    }
                    where datjson = dat: string;
                ;
        }
    }
    public using Context = struct {
        m_objects: vec<Object>,
    }
    {
        public func create()
        {
            return Context{
                m_objects = []mut,
            };
        }

        public func create_object(self: Context, e: je::entity)
        {
            return Object::create(e)
                ->> \ob = self.m_objects->add(ob);
                ->  has;
        }

        public func get_object_by_index(self: Context, idx: int)
        {
            return self.m_objects->get(idx);
        }
        public func remove_object_by_index(self: Context, idx: int)
        {
            return self.m_objects->get(idx);
        }

        public func generate_code(self: Context)
        {
            // 用于生成代码
            let mut src = @"
import je;
import je.tickline;
import builtin.tickline.main;

let _entity_logics = {
            "@;
            for (let _, ob : self.m_objects)
            {
                src += F"[{ob.m_euid: string->enstring}: je::tickline::euid_t] = {ob->generate_code},\n";
            }

            src += @"
            };
let _events_mgr_instance = Tickline::Runtime::LayersAndEventsManager::create([]);
            "@;
           
            src += @"
namespace Tickline
{
    extern func Execute()=> bool
    {
        return _events_mgr_instance->execute();
    }
}
je::tickline::engine::init(_entity_logics->unmapping);
            "@;

            return src;
        }
    }
}
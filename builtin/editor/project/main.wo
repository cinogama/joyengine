// project.main
// 用于储存编辑中的项目信息

import je;
import je.gui;

import config;

import builtin.editor.environment.main;
import builtin.api.rend.main;
import builtin.api.gui.form.msg;
import builtin.editor.cpp.main;
import builtin.editor.tools.script_manager;

namespace editor
{
    let  
        DEFAULT_GRAPHIC_SYSTEM_NAME = "Graphic::DefaultGraphicPipelineSystem",
        DEFAULT_EDITOR_SYSTEM_NAME = "Editor::DefaultEditorSystem";

    public using ProjectWorld = struct{
        m_world_instance: je::world,
        m_world_path: string,
        m_runtime_systems: mut array<je::typeinfo>,
    };

    using DebugContext = struct {
        // 想了半天，还是把调试状态摆在这里维护
        m_project: Project,
        m_dumped_editing_worlds: array<dict<string, dynamic>>,
    };

    public using Project = struct{
        m_name: string,    // 项目的名称，不能更改
        m_path: string,    // 项目所在的目录
        m_env: Environment, // 项目环境
        m_configs: map<string, Project::IConfig>, // 配置信息，是的，这是个map，意味着开发者可以自己加点配置项目
        m_worlds: vec<ProjectWorld>,
        m_default_worlds: mut option<je::world>, // 如果项目没有世界，那么创建一个默认的临时世界挂在这里，保证gui能跑
        m_modules: map<string, CxxProject>, 
        
        m_debug_context: mut option<DebugContext>,
    }
    {
        public func make_path_normalize(self: Project, path: string)
        {
            let npath = filesys::normalize(path);
            if (npath->beginwith(self.m_path))
                return "@" + npath->sub(self.m_path->len);
            return npath;
        }
        public func is_debugging(self: Project)
        {
            return self.m_debug_context->has;
        }
        public func stop_debug(self: Project)
        {
            if (! self->is_debugging)
                return result::err("未在调试中");

            assert (self.m_worlds->empty);

            // 关闭所有世界~~
            do self->get_env->get_universe->editor::get_all_worlds
                ->> func(w){
                    if (self.m_default_worlds->val != w)
                        w->close();
                }
                ;
            // 恢复所有世界！
            self->restore_all_world(self.m_debug_context->val.m_dumped_editing_worlds);

            self.m_debug_context = option::none;
            return result::ok(do nil);
        }

        public func start_debug(self: Project)
        {
            if (self->is_debugging)
                return result::err("已经在调试中，不可重复调试");

            let dumpped = self->dump_and_close_all_world();

            if (dumpped->iserr)
                return dumpped->fail;

            let context = DebugContext {
                    m_project = self,
                    m_dumped_editing_worlds = dumpped->unwarp,
                };

            // OK 接下来在当前世界上创建游戏世界，至于在哪个世界渲染……emm
            for (let _, wdat : context.m_dumped_editing_worlds)
            {
                let syss = wdat->getor("runtime_systems", []: dynamic) as array<dynamic>
                    ->connect(
                        wdat->getor("systems", []: dynamic) as array<dynamic>
                    );

                let new_wdat = wdat->tomap;
                new_wdat->set("systems", syss as array<dynamic>: dynamic);

                let w = jeapi::deserialize::world(self->get_env->get_universe, new_wdat->unsafe::cast:<typeof(wdat)>);
                if (wdat->getor("is_editing", false: dynamic) as bool)
                    je::gui::launch(func(){
                        std::yield();
                        jeapi::rend::reset_rend_world(w, self->get_config_graphic_pipeline);                    
                        return false;
                    }, ());
            }
            self.m_debug_context = option::value(context);

            return result::ok(context);
        }

        public func get_module(self: Project, name: string)
        {
            return self.m_modules->get(name);
        }
        public func get_all_modules(self: Project)
        {
            return self.m_modules;
        }
        public func dump_and_close_all_world(self: Project)
        {
            let dump_dats = self.m_worlds->toarray
                =>> \pw = dat->has 
                    ? [dat->val->apply("is_editing", self->get_editing_world
                        ->> \ew = ew == pw.m_world_instance;
                        ->  valor(false) as bool: dynamic)] 
                    | [] 
                    where dat = self->serialize_world(pw.m_world_instance)
                    ;
                ;
            
            if (dump_dats->len != self.m_worlds->len)
                return result::err("有世界序列化失败");

            // OK 关闭全部现存世界
            do self.m_worlds->toarray->> \pw = self->destroy_world(pw.m_world_instance)->unwarp();;
            return result::ok(dump_dats);
        }
        public func restore_all_world(self: Project, dats: array<dict<string, dynamic>>)
        {
            do dats->>\dat = self->deserialize_world(dat);;
        }
        func _create_default_configs(env: Environment)
        {
            using je;
            using je::gui;

            return {
                /* 引擎的默认图形管线 */
                ["JE_PROJECT_GRAPHIC_PIPELINE"] = IConfig::create(Config::create(
                    typeinfo::load(DEFAULT_GRAPHIC_SYSTEM_NAME)->val,
                    func(origin_graphic_pipeline)
                    {
                        let USABLE_GRAPHIC_SYSTEMS = typeinfo::editor::get_all_systems_types()
                                ->  forall(\t = t->name->beginwith("Graphic::"););
                        let USABLE_GRAPHIC_SYSTEM_NAMES =  USABLE_GRAPHIC_SYSTEMS
                                ->> \t = t->name;;

                        return Combo("图形管线", 
                            USABLE_GRAPHIC_SYSTEM_NAMES, 
                            USABLE_GRAPHIC_SYSTEM_NAMES->find(origin_graphic_pipeline->name))
                            =>> \index = USABLE_GRAPHIC_SYSTEMS->get(index);;
                    },
                    func(oldval, newval)
                    {
                        // 移除当前世界中的老渲染管线，换个新的
                        match (world::rend(env->get_universe))
                        {
                        value(current_rend_world)?
                        {
                            current_rend_world->remove_system(oldval);
                            do current_rend_world->add_system(newval);
                        }
                        none?
                            je::logwarn("设置管线时未发现渲染中的世界，跳过更新世界");
                        }
                        
                        return true;
                    },
                    \val = val->name;,
                    \str = typeinfo::load(str);,
                )),
                /* 引擎的默认编辑器系统 */
                ["JE_PROJECT_EDITOR_SYSTEM"] = IConfig::create(Config::create(
                    typeinfo::load(DEFAULT_EDITOR_SYSTEM_NAME)->val,
                    func(origin_editor_system)
                    {
                        let USABLE_EDITOR_SYSTEMS = typeinfo::editor::get_all_systems_types()
                                ->  forall(\t = t->name->beginwith("Editor::"););
                        let USABLE_EDITOR_SYSTEM_NAMES =  USABLE_EDITOR_SYSTEMS
                                ->> \t = t->name;;

                        return Combo("编辑系统", 
                            USABLE_EDITOR_SYSTEM_NAMES, 
                            USABLE_EDITOR_SYSTEM_NAMES->find(origin_editor_system->name))
                            =>> \index = USABLE_EDITOR_SYSTEMS->get(index);;
                    },
                    func(oldval, newval)
                    {
                        // 移除当前世界中的老编辑系统，换个新的
                        match (world::rend(env->get_universe))
                        {
                        value(current_rend_world)?
                        {
                            current_rend_world->remove_system(oldval);
                            do current_rend_world->add_system(newval);
                        }
                        none?
                            je::logwarn("设置编辑系统时未发现渲染中的世界，跳过更新世界");
                        }
                        
                        return true;
                    },
                    \val = val->name;,
                    \str = typeinfo::load(str);,
                )),
                /* 项目的描述信息 */
                ["JE_PROJECT_DESCRIBE"] = IConfig::create(Config::create(
                    "新项目，你可以在这里编辑项目的描述文本",
                    func(origin_text)
                    {
                        Text("项目描述");
                        return InputTextMultilineSize("##项目描述", origin_text, 400., 200.);
                    },
                    \o,n = true;,
                    \val = val;,
                    \str = option::value(str);,
                )),
                ["JE_ENGINE_TIME_SLEEP_SUPPRESSION"] = IConfig::create(Config::create(
                    do nil,
                    func(_create_default_configs)
                    {
                        Text("引擎提前唤醒间隔");
                        let result = InputFloat("##引擎提前唤醒间隔", je::editor::get_sleep_suppression());
                        do result->>\suppression=je::editor::set_sleep_suppression(suppression);;
                        TextDisabled("适当提高此值可以增加执行间隔和帧数的稳定性");
                        return result->>\_=do nil;;
                    },
                    \o,n = true;,
                    \_ = je::editor::get_sleep_suppression(): string;,
                    func (str){
                        je::editor::set_sleep_suppression(str: real);
                        return option::value(do nil);
                    },
                )),
            }mut;
        }
        public func create(name: string, path: string)
        {
            let env = Environment::create();

            let proj = Project{
                m_name = name,
                m_path = filesys::normalize(path),
                m_env = env,
                m_configs = _create_default_configs(env),
                m_worlds = []mut,
                m_default_worlds = mut option::none,
                m_modules = {}mut,
                m_debug_context = mut option::none,
            };

            // 创建完项目后，保证创建一个新世界并开始渲染，否则GUI协程就没法跑了
            proj->_run_default_world;

            tools::update_tool_scripts(proj);

            // TODO: 在这里临时设置一下窗口嘻嘻嘻，之后做完项目加载就删掉
            je::input::set_window_size(1344, 768);
            return proj;
        }
        public func active_module(self: Project, module: CxxProject)
        {
            assert (std::issame(self.m_modules->getorset(module.path, module), module));
        }
        public func load(dat: dict<string, dynamic>)
        {
            let self = create( dat["name"] as string, dat["path"] as string);

            // 先加载配置！这非常重要！
            for (let name, val : dat["configs"] as dict ->> \k, v = (k as string, v as string);)
            {
                if (! self.m_configs->get(name)->> \config = config->parse(val);->valor(false))
                    je::logerr(F"选项 {name} = {val} 未在项目中找到或设置失败");
            }

            // TODO: 加载失败和二进制文件怎么git还需考虑一下
            do dat->get("modules")
                ->> \d = d as array<dynamic> 
                    =>> \p = err->has ? [(p, err->val)] | []
                        where err = CxxProject::load(module_name, self)->error
                            , module_name = p as string
                        ;
                    ;
                ->  valor([])
                ->> \mr = jeapi::gui::form::errmsg("加载失败", F"无法加载 '{mr[0]}'：{mr[1]}"); 
                ;
            

            do dat["worlds"] as array
                ->> \wpath = self->load_world(wpath as string);
                ;

            return self;
        }
        public func save_project(self: Project)
        {
            let dat = {
                ["path"] = self.m_path: dynamic,
                ["name"] = self.m_name: dynamic,
                ["configs"] = self.m_configs->> \k, v = (k, v->tostring());: dynamic,
                ["worlds"] = self.m_worlds->> \pw = pw.m_world_path;: dynamic,
                ["modules"] = self.m_modules->unmapping->>\kv = kv[0];: dynamic,
            };

            // 顺手保存所有世界
            let failed_saving_worlds = self.m_worlds
                ->  toarray
                =>> \pw = saving_success ?  [] | [pw]
                    where saving_success = self->save_world(pw.m_world_instance)
                    ;
                ;
                
            if (failed_saving_worlds->empty == false)
            {
                let failed_file_list = failed_saving_worlds
                    ->> \pw = pw.m_world_path;
                    ->  reduce(\l, r = l + "\n" + r;)
                    ->  val;

                jeapi::gui::form::errmsg("错误", F"项目中的一些世界保存失败:\n{failed_file_list}\n项目保存未能完成");
                return false;
            }
            else if (!filesys::writeall(F"{self.m_path}/project.jeproj4", dat as dict<string, dynamic>: string))
            {
                jeapi::gui::form::errmsg("错误", F"保存项目文件失败");
                return false;
            }
            return true;
        }
        public func close(self: Project)
        {
            self.m_env->close;
        }
        public func wait(self: Project)
        {
            self.m_env->wait;
        }
        public func get_env(self: Project)
        {
            return self.m_env;
        }

        func get_project_world(self: Project, world: je::world)
        {
            return self.m_worlds
                -> forall(\pw = pw.m_world_instance == world;)
                -> get(0);
        }
        func is_project_world(self: Project, world: je::world)
        {
            return self->get_project_world(world)->has;
        }
        public func get_editing_world(self: Project)
        {
            return je::world::rend(self.m_env->get_universe)
                =>> \w = self->is_project_world(w)
                    ? option::value(w)
                    | option::none
                    ;
                ;
        }
        public func validate_world_or_warning(self: Project, world: je::world)
        {
            if (self->is_project_world(world))
                return true;
                
            jeapi::gui::form::errmsg("错误", "请求的世界不存在"); 
            return false;
        }
        public func get_worlds_runtime_systems(self: Project, world: je::world)
        {
            return self->get_project_world(world)->>\pw = pw.m_runtime_systems;;
        }
        public func set_worlds_runtime_systems(self: Project, world: je::world, syss: array<je::typeinfo>)
        {
            return self->get_project_world(world)->>\pw = pw.m_runtime_systems = syss;->has;
        }
        public func reset_editing_world(self: Project, world: je::world)=> result<void, string>
        {
            if (self->is_project_world(world))
            {
                // 将编辑器系统从旧编辑世界中移除，这里要求新编辑世界必须属于项目
                // 但不要求旧编辑世界，因为旧编辑世界可能是默认世界
                let editing_world = self->get_editing_world();

                match (editing_world)
                {
                value(last_edit_world)?
                {
                    if (last_edit_world == world)
                        return result::ok(do nil); // 新老世界相同，跳过更新

                    last_edit_world->remove_system(self->get_config_editor_system);
                }
                none?;
                }
                jeapi::rend::reset_rend_world(world, self->get_config_graphic_pipeline);
                do world->add_system(self->get_config_editor_system);

                return result::ok(do nil);
            }
            return result::err("给定的世界不属于当前项目");
        }

        func _run_default_world(self: Project)
        {
            assert(self.m_worlds->empty);
            assert(self.m_default_worlds->has == false);

            let default_world = self.m_env->create_world;
            jeapi::rend::reset_rend_world(default_world, self->get_config_graphic_pipeline);
            self.m_default_worlds = option::value(default_world);
        }

        public func get_configs(self: Project)
        {
            return self.m_configs;
        }

        public func get_config(self: Project, config_name: string)
        {
            return self.m_configs->get(config_name);
        }

        public func get_config_graphic_pipeline(self: Project)
        {
            return self->get_config("JE_PROJECT_GRAPHIC_PIPELINE")
                ->> \config = config->tostring;
                ->  valor(DEFAULT_GRAPHIC_SYSTEM_NAME)
                ->  je::typeinfo::load
                ->  val;
        }
        public func get_config_editor_system(self: Project)
        {
            return self->get_config("JE_PROJECT_EDITOR_SYSTEM")
                ->> \config = config->tostring;
                ->  valor(DEFAULT_EDITOR_SYSTEM_NAME)
                ->  je::typeinfo::load
                ->  val;
        }

        public func get_all_worlds(self: Project)
        {
            return self.m_worlds->>\pw = pw.m_world_instance;;
        }
        func append_world_to_list(self: Project, world: ProjectWorld)
        {
            self.m_worlds->add(world);

            // 世界编辑器已经做平了这一块
            // do world.m_world_instance->add_system(
            //     je::typeinfo::load("Translation::TranslationUpdatingSystem")->val);

            // 创建默认世界之后，自动顺便创建调试使用的摄像机
            let camera_walker = world.m_world_instance->add_entity([
                // Transform 族组件
                je::typeinfo::load("Transform::LocalPosition")->val,
                je::typeinfo::load("Transform::LocalRotation")->val,
                je::typeinfo::load("Transform::LocalToWorld")->val,
                je::typeinfo::load("Transform::Translation")->val,
                je::typeinfo::load("Transform::Anchor")->val,
                // Editor 族组件
                je::typeinfo::load("Editor::Invisable")->val,
                je::typeinfo::load("Editor::EditorWalker")->val,
            ]);
            // 摄像机，同时负责x轴旋转
            let editor_camera = world.m_world_instance->add_entity([
                // Transform 族组件
                je::typeinfo::load("Transform::LocalRotation")->val,
                je::typeinfo::load("Transform::LocalToParent")->val,
                je::typeinfo::load("Transform::Translation")->val,
                // Editor 族组件
                je::typeinfo::load("Editor::Invisable")->val,
                je::typeinfo::load("Editor::EditorWalker")->val,
                // Camera 族组件
                je::typeinfo::load("Camera::PerspectiveProjection")->val,
                je::typeinfo::load("Camera::Projection")->val,
                je::typeinfo::load("Camera::RendToFramebuffer")->val,
            ]);
            editor_camera->je::editor::apply_camera_framebuf_setting(320, 240);
            do editor_camera->editor::set_parent(camera_walker, true);
    
            // 移动器，这里只创建根实体，具体的轴由编辑器系统生成
            do world.m_world_instance->add_entity([
                // Transform 族组件
                je::typeinfo::load("Transform::LocalPosition")->val,
                je::typeinfo::load("Transform::LocalRotation")->val,
                je::typeinfo::load("Transform::LocalScale")->val,
                je::typeinfo::load("Transform::Anchor")->val,
                je::typeinfo::load("Transform::Translation")->val,
                je::typeinfo::load("Transform::LocalToWorld")->val,
                // Editor 族组件
                je::typeinfo::load("Editor::Invisable")->val,
                je::typeinfo::load("Editor::EntityMoverRoot")->val,
            ]);

            // 有新建世界进来，关掉默认世界（如果有的话）
            match (self.m_default_worlds)
            {
            value(default_world)?
            {
                default_world->close;
                do self.m_default_worlds = option::none;

                // 在此处重置编辑中世界，因为之前在渲染默认世界，
                // 移除默认世界之后，如果没有设置渲染世界，就寄了
                // 必须成功!
                self->reset_editing_world(world.m_world_instance)->unwarp;
            }
            none?
                ;
            }
            return world.m_world_instance;
        }
        public func create_new_world(self: Project, new_world_file_path: string)
        {          
            return self->append_world_to_list(
                ProjectWorld 
                {
                    m_world_instance = self.m_env->create_world,
                    m_world_path = new_world_file_path,
                    m_runtime_systems = mut [],
                });
        }
        public func get_world_path(self: Project, w: je::world)
        {
            return self->get_project_world(w)->> \pw = pw.m_world_path;;
        }
        public func serialize_entity(self: Project, e: je::entity)
        {
            return jeapi::serialize::entity(e);
        }
        public func serialize_world(self: Project, w: je::world)
        {
            return self->get_project_world(w)
                =>> \pw = jeapi::serialize::world(w)->okay
                    ->> \dat = dat->apply("path", pw.m_world_path as string: dynamic);
                    ->> \dat = dat->apply("runtime_systems", pw.m_runtime_systems->>\t=t->name; as array<string>: dynamic);
                    ;
                ;
        }
        public func deserialize_world(self: Project, dat: dict<string, dynamic>)
        {
            return self->append_world_to_list(
                ProjectWorld 
                {
                    m_world_instance = self.m_env->load_world(dat),
                    m_world_path = dat["path"] as string,
                    m_runtime_systems = 
                        mut dat->getor("runtime_systems", []: dynamic) as array
                            =>> \elem = systype->has ? [systype->val] | []
                                where systype = je::typeinfo::load(elem as string);,
                });
        }
        public func save_world(self: Project, w: je::world)
        {
            return self->serialize_world(w)
                ->> \dat = dat->apply("is_editing", self->get_editing_world->>\ew = ew == w;->valor(false) as bool: dynamic);
                ->> \dat = filesys::writeall(dat["path"]: string, dat as dict<string, dynamic>: string);
                ->  valor(false);
        }
        public func load_world(self: Project, file_path: string)
        {
            return filesys::readall(file_path)
                =>> \dat = dat->todict
                    ->> \d = d
                        ->> \k, v = (k as string, v);
                        ;
                    ;
                ->> \dat = self->deserialize_world(dat)
                    ->  func (w)
                        {
                            if (dat->getor("is_editing", false: dynamic) as bool)
                                do self->reset_editing_world(w);
                            return w;
                        }
                    ;
                ;
        }
        
        public func destroy_world(self: Project, world: je::world)=> result<void, string>
        {
            // 使用create_new_world创建的世界，务必使用destroy_world销毁，不应该close
            match (self->get_project_world(world))
            {
            value(w)?
            {
                // 如果当前编辑中的世界就是待删除的世界，那么需要更新新的编辑世界
                let need_update_new_editing_world = 
                    self->get_editing_world->>\rw = rw == world;->valor(false);
               
                // NOTE: 必须在切换完成之后才能从世界列表中移除世界，否则无法正确获取编辑中的世界
                self.m_worlds->remove(self.m_worlds->find(w));

                // 如果还有世界，那么选择第一个作为编辑中世界顶替，否则起用默认世界
                self.m_worlds->get(0)
                    ->> \w = need_update_new_editing_world 
                        ? self->reset_editing_world(w.m_world_instance)->unwarp
                        | nil: void
                        ; // 必须成功
                    ->  or(\= self->_run_default_world;);

                world->close;
                
                return result::ok(do nil);
            }
            none?
                return result::err("期待销毁的世界不存在");
            }
        }
    }
}
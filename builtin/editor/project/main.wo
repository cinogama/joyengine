// project.main
// 用于储存编辑中的项目信息

import je;
import je::gui;

import pkg::try;
import pkg::worst;
import config;

import builtin::editor::environment::main;
import builtin::api::rend::main;
import builtin::api::gui::form::msg;
import builtin::api::gui::form::ask;
import builtin::editor::cpp::main;
import builtin::editor::tools::script_manager;
import builtin::editor::gui::draw_pannel::main;
import builtin::editor::project::towoomgr;

namespace editor
{
    let DEFAULT_EDITOR_SYSTEM_NAME = "Editor::DefaultEditorSystem";

    using ProjectWorld = struct{
        m_world_instance: je::world,
        m_world_path: fsys::path_t,
        m_runtime_systems: mut array<je::typeinfo>,
        m_remark_note: mut string,
    };

    using DebugContext = struct {
        // 想了半天，还是把调试状态摆在这里维护
        m_project: Project,
        m_dumped_editing_worlds: array<dict<string, dynamic>>,
    };

    using Project = struct{
        m_name: string,             // 项目的名称，不能更改
        m_path: fsys::path_t,    // 项目所在的目录
        m_env: Environment,         // 项目环境
        m_configs: map<string, Project::IConfig>, // 配置信息，是的，这是个map，意味着开发者理论上可以自己加点配置项目
        m_worlds: vec<ProjectWorld>,
        m_modules: map<fsys::path_t, CxxProject>, 
        m_editing_world: mut option<je::world>,
        m_debug_context: mut option<DebugContext>,
        m_proj_file_lock: mut option<process::flock>,
        m_towoo_context: ToWooContext,
    }
    {
        public func make_path_normalize(self: Project, path: fsys::path_t)
        {
            let npath = path->tostring;
            if (npath->beginwith(self.m_path->tostring + "/"))
            {
                return "@" + npath->sub(self.m_path->tostring->len);
            }
            return npath;
        }
        public func parse_path_normalize(self: Project, path: string)
        {
            if (path->beginwith("@"))
                return fsys::normalize(self.m_path->tostring + path->sub(1));
            return fsys::normalize(path);
        }
        public func is_debugging(self: Project)
        {
            return self.m_debug_context->has;
        }
        public func create_dump(self: Project, dumpped: array<dict<string, dynamic>>)
        {
            do fsys::mkdir(self.m_path / ".runtime");
            if (! dumpped->serialize
                ->> \dat = fsys::writeall(self.m_path / ".runtime" / "debugcontext.dump", dat);
                ->  valor(false))
            {
                jeapi::gui::form::errmsg("警告", "调试上下文创建失败，这可能导致崩溃无法恢复上次调试状态");
                je::logwarn("调试上下文创建失败，这可能导致崩溃无法恢复上次调试状态");
            }
        }
        public func restore_dump(self: Project)
        {
            match (fsys::readall(self.m_path / ".runtime" / "debugcontext.dump")=>> \dat = dat->array::deserialize;)
            {
            value(dat)?
                jeapi::gui::form::ask("是否恢复", "检查到上次引擎在调试过程中意外退出，是否恢复之前的编辑器状态？",
                    func(opt)
                    {
                        if (opt)
                        {
                            self->close_all_world();
                            self->restore_all_world(dat->>\wdat = wdat as dict<dynamic, dynamic>->>\k, v = (k as string, v);;);
                        }
                    });
            none?;
            }
        }
        public func clear_dump(self: Project)
        {
            do fsys::remove(self.m_path / ".runtime" / "debugcontext.dump");
        }
        public func stop_debug(self: Project)
        {
            if (! self->is_debugging)
                return result::err("未在调试中");

            assert (self.m_worlds->empty);

            // 关闭所有世界~~
            do self->get_env->get_universe->get_all_worlds
                ->> \w = w->close();
                ;

            // 关闭调试上下文，保证恢复上下文时project已经不再处于debug状态
            let dumped_worlds = self.m_debug_context->val.m_dumped_editing_worlds;
            self.m_debug_context = option::none;
            
            // 恢复所有世界！
            self->restore_all_world(dumped_worlds);

            self->clear_dump();

            return result::ok(do nil);
        }

        public func start_debug(self: Project)
        {
            if (self->is_debugging)
                return result::err("已经在调试中，不可重复调试");

            try! dumpped = self->dump_and_close_all_world();

            let context = DebugContext {
                    m_project = self,
                    m_dumped_editing_worlds = dumpped,
                };

            self->create_dump(dumpped);

            // OK 接下来在当前世界上创建游戏世界，至于在哪个世界渲染……emm
            for (let _, wdat : context.m_dumped_editing_worlds)
            {
                let wdat_map = wdat->tomap();
                let syss = wdat_map->getor("runtime_systems", []: dynamic) as array<dynamic>->connect(
                    wdat_map->getor("systems", []: dynamic) as array<dynamic>
                );
                wdat_map->set("systems", syss: dynamic);
                do jeapi::deserialize::world(self->get_env->get_universe, wdat_map->unsafe::cast:< typeof(wdat)>, true);
            }
            self.m_debug_context = option::value(context);

            return result::ok(context);
        }

        public func get_module(self: Project, name: fsys::path_t)
        {
            return self.m_modules->get(name);
        }
        public func get_all_modules(self: Project)
        {
            return self.m_modules;
        }
        public func dump_all_world(self: Project)
        {
            let dump_dats = self.m_worlds->toarray
                =>> \pw = dat->has 
                    ? [dat->val->apply("is_editing", self->get_editing_world
                        ->> \ew = ew == pw.m_world_instance;
                        ->  valor(false) as bool: dynamic)] 
                    | [] 
                    where dat = self->serialize_world(pw.m_world_instance)
                    ;
                ;
            
            if (dump_dats->len != self.m_worlds->len)
                return result::err("有世界序列化失败"); 

            return result::ok(dump_dats);
        }
        public func close_all_world(self: Project)
        {
            // OK 关闭全部现存世界
            do self.m_worlds->toarray->> \pw = self->destroy_world(pw.m_world_instance)->unwarp();;
        }
        public func dump_and_close_all_world(self: Project)
        {
            try! dats = self->dump_all_world();
            do self->close_all_world();
            return result::ok(dats);
        }
        public func restore_all_world(self: Project, dats: array<dict<string, dynamic>>)
        {
            do dats->>\dat = self->deserialize_world(dat);;
        }
        func _create_default_configs(env: Environment)
        {
            using je;
            using je::gui;

            return {
                /* 引擎的默认编辑器系统 */
                ["JE_PROJECT_EDITOR_SYSTEM"] = new! IConfig(new! Config(
                    typeinfo::load(DEFAULT_EDITOR_SYSTEM_NAME)->val,
                    func(origin_editor_system)
                    {
                        let USABLE_EDITOR_SYSTEMS = typeinfo::get_all_systems_types()
                                ->  forall(\t = t->name->beginwith("Editor::"););
                        let USABLE_EDITOR_SYSTEM_NAMES =  USABLE_EDITOR_SYSTEMS
                                ->> \t = t->name;;

                        let result = Combo("编辑系统", 
                            USABLE_EDITOR_SYSTEM_NAMES, 
                            USABLE_EDITOR_SYSTEM_NAMES->find(origin_editor_system->name))
                            =>> \index = USABLE_EDITOR_SYSTEMS->get(index);;
                        TextDisabled("* 重启后生效");
                        return result;
                    },
                    \_,_ = true;,
                    \val = val->name;,
                    \str = typeinfo::load(str);,
                    \_ = "// Editor-system is not needed when export.";,
                )),
                /* 项目的描述信息 */
                ["JE_PROJECT_DESCRIBE"] = new! IConfig(new! Config(
                    "新项目，你可以在这里编辑项目的描述文本",
                    func(origin_text)
                    {
                        Text("项目描述");
                        return InputTextMultilineSize("##项目描述", origin_text, 400., 200.);
                    },
                    \_,_ = true;,
                    \val = val;,
                    \str = option::value(str);,
                    \_ = "// Describe is not needed when export.";,
                )),
                ["JE_ENGINE_TIME_SLEEP_SUPPRESSION"] = new! IConfig(new! Config(
                    do nil,
                    func(_)
                    {
                        Text("引擎提前唤醒间隔");
                        let result = InputFloatFormat("##引擎提前唤醒间隔", je::editor::get_sleep_suppression(), "%.6f");
                        do result->>\suppression=je::editor::set_sleep_suppression(suppression);;
                        TextDisabled("适当提高此值可以增加执行间隔和帧数的稳定性");
                        return result->>\_=do nil;;
                    },
                    \_,_ = true;,
                    \_ = je::editor::get_sleep_suppression(): string;,
                    func (str){
                        je::editor::set_sleep_suppression(str: real);
                        return option::value(do nil);
                    },
                    \_ = F"je::editor::set_sleep_suppression({supp});"
                        where supp = je::editor::get_sleep_suppression()
                    ;,
                )),
                ["JE_GUI_FONT"] = new! IConfig(new! Config(
                    ("@/resource/font/HarmonyOS_Sans_SC_Regular.ttf", 18),
                    func(config)
                    {
                        Text("GUI字体");
                        let (font_path, font_size) = config;

                        let new_font_path = InputText("##fontpath", font_path)->valor(font_path);
                        SameLine();
                        let new_font_size = InputInt("##fontsize", font_size)->valor(font_size);

                        TextDisabled("* 重启后生效");

                        if (font_path != new_font_path || font_size != new_font_size)
                            return option::value((new_font_path, new_font_size));
                        return option::none;
                    },
                    func(_,n){je::gui::set_font(option::value(n[0]), n[1]); return true;},
                    \v = [v[0]: dynamic, v[1]: dynamic]->serialize->val;,
                    func (str){
                        let v = array::deserialize(str)->val;
                        return option::value((v[0] as string, v[1] as int));
                    },
                    \dat = F"je::gui::set_font(option::value({font->enstring}), {size});"
                        where (font, size) = dat
                    ;,
                )),
                ["JE_ENGINE_TIME_MAX_DELTATIME"] = new! IConfig(new! Config(
                    do nil,
                    func(_)
                    {
                        Text("最大差分时间");
                        let result = InputFloatFormat("##最大差分时间", env->get_universe->get_max_deltatime(), "%.6f");
                        do result->>\val= val > 0. ? env->get_universe->set_max_deltatime(val) | nil: void;;
                        TextDisabled("DeltaTime相关函数将不会返回大于此值的差分时间");
                        TextDisabled("* 保证大于 0.0");
                        return result->>\_=do nil;;
                    },
                    \_,_ = true;,
                    \_ = env->get_universe->get_max_deltatime(): string;,
                    func (str){
                        env->get_universe->set_max_deltatime(str: real);
                        return option::value(do nil);
                    },
                    \_ = F"RUNTIME_UNIVERSE->set_max_deltatime({supp});"
                        where supp = env->get_universe->get_max_deltatime()
                    ;,
                )),
            }mut;
        }
        func try_lock_this_project(self: Project)
        {
            match (self.m_proj_file_lock)
            {
            value(flock)?
                return flock->trylock();
            none?
                {
                    let projfile = self.m_path / "project.jeproj4.lock";
                    // 不可以锁定目录
                    if (fsys::isdir(projfile) == true)
                        return false;
                    let flock = new! process::flock(projfile->tostring);
                    let result = flock->>\fl = fl->trylock();->valor(false);
                    if (result)
                    {
                        self.m_proj_file_lock = flock;
                        return true;
                    }
                    return false;
                }
            }
        }
        func unlock_this_project(self: Project)
        {
            match (self.m_proj_file_lock)
            {
            value(flock)? flock->unlock();
            none? je::logerr("未找到项目的文件锁，可能是未能创建或打开文件，请检查权限");
            }
        }
        public func register_editor_widget(self: Project)
        {
            do self;

            jeapi::gui::register_custom_editor("je_light2d_block_shape", func(tag: string, dat: string)
            {
                using je::gui;

                let mut need_update = false;
                let datas = dat->split(";")
                    =>> \dat = arr->len == 2 ? [(arr[0], arr[1])] | []
                        where arr = dat->split(":");
                    ;

                let length = datas
                    ->  forall(\data = data[0] == "size";)
                    ->  reduce(\l, _ = l;)
                    ->> \data = data[1]: int;
                    ->  valor(datas->len)
                    ;

                let mut update_str = "size:";

                match (InputInt(F"size##{tag}", length))
                {
                value(newsize)?
                {
                    need_update = true;
                    update_str += (newsize < 0 ? 0 | newsize): string;
                }
                none?
                    update_str += length: string;
                }

                update_str += ";";

                for (let index, (layer, factor) : datas->forall(\d = d[0]!="size";))
                {
                    Text(F"{layer}:");      
                    SameLine();

                    func _str2vec2(str: string)
                    {
                        let x = mutable::create(0.), y = mutable::create(0.);
                        do str->take_token("(")
                            =>> \s = s->take_real();
                            =>> func(snr){x->set(snr[1]); return snr[0]->take_token(",");}
                            =>> \s = s->take_real();
                            =>> func(snr){y->set(snr[1]); return snr[0]->take_token(")");}
                            ;
                        return (x->get, y->get);
                    }

                    let (posx, posy) = _str2vec2(factor);
                    let (new_posx, new_posy) = InputFloat2(F"##factor{index}_{tag}", posx, posy)->valor((posx, posy));

                    if (new_posx != posx || new_posy != posy)
                        need_update = true;

                    update_str += F"{layer}:({new_posx},{new_posy});";
                }
                    
                if (need_update)
                    return option::value(update_str);
                return option::none;
            });

            jeapi::gui::register_custom_editor("je_file", func(tag: string, dat: string)
            {
                using je::gui;
                return jeapi::gui::widget::File(F"文件##{tag}", dat == "" ? "<无>" | dat, \=do nil;);
            });

            jeapi::gui::register_custom_editor("je_animation_list", func(tag: string, dat: string)
            {
                using je::gui;

                let mut need_update = false;
                let size_datas = dat->split(";");
                let size = size_datas->get(0)->valor("0"): int;
                let datas = (size_datas->empty ? [] | size_datas->sub(1))
                    ->> \data = data->split("|");
                    ;

                let mut update_str = "";

                match (InputInt("size##{tag}", size))
                {
                value(newsize)?
                {
                    need_update = true;
                    update_str += (newsize < 0 ? 0 | newsize): string;
                }
                none?
                    update_str += size: string;
                }

                update_str += ";";

                for (let i, dat : datas)
                {
                    Separator();

                    if (dat->len != 3) continue;

                    match (jeapi::gui::widget::File(F"动画##{i}_{tag}", dat[0], \=do nil;))
                    {
                    value(path)?
                        {
                            need_update = true;
                            update_str += path + "|";
                        }
                    none?
                        update_str += dat[0] + "|";
                    }

                    match (InputText(F"动作##{i}_{tag}", dat[1]))
                    {
                    value(act)?
                        {
                            need_update = true;
                            update_str += act + "|";
                        }
                    none?
                        update_str += dat[1] + "|";
                    }

                    match (CheckBox(F"循环##{i}_{tag}", dat[2] == "true"))
                    {
                    value(loop)?
                        {
                            need_update = true;
                            update_str += (loop ? "true;" | "false;");
                        }
                    none?
                        update_str += dat[2] + ";";
                    }
                }

                if (need_update)
                    return option::value(update_str);
                return option::none;
            });
        }
        public func create(name: string, path: fsys::path_t)
        {
            let env = new! Environment();
            
            assert(fsys::setworkpath(path));

            let proj = Project{
                m_name = name,
                m_path = path,
                m_env = env,
                m_configs = _create_default_configs(env),
                m_worlds = []mut,
                m_modules = {}mut,
                m_debug_context = mut option::none,
                m_editing_world = mut option::none,
                m_proj_file_lock = mut option::none,
                m_towoo_context = new! ToWooContext(path),
            };

            if (proj->try_lock_this_project() == false)
            {
                proj->close();
                return result::err("锁定项目失败，请检查相同项目是否已经重复打开");
            }

            proj->register_editor_widget();

            tools::update_tool_scripts(proj);
            gui::drawpannel::update_and_get_scripts(proj);

            return result::ok(proj);
        }
        public func active_module(self: Project, module: CxxProject)
        {
            assert (std::issame(self.m_modules->getorset(module.path, module), module));
        }
        public func deactive_module(self: Project, module: CxxProject)
        {
            assert (std::issame(self.m_modules->getor(module.path, module), module));
            if (self.m_modules->remove(module.path))
            {
                module->close();
                return true;
            }
            return false;
        }
        public func try_update_towoo(self: Project, fast: bool)
        {
            // 无法愉快处理在调试状态下的情况，简单忽略之
            // TODO: 做平？
            if (self->is_debugging)
                return;
    
            if (fast
                ? self.m_towoo_context->fast_check_for_update 
                | self.m_towoo_context->check_for_update)
            {
                match (self->dump_and_close_all_world())
                {
                ok(dat)?
                    {
                        je::gui::launch(func()
                            {
                                self.m_towoo_context->update();
                                self->restore_all_world(dat);
                                return false;
                            }, ());
                    }
                err(msg)?
                    jeapi::gui::form::errmsg("失败", F"更新towoo系统失败: {msg}");
                }
            }
        }

        public func get_all_towoo_scripts_name_and_path(self: Project)
        {
            return self.m_towoo_context.m_loaded_towoo
                ->  unmapping
                ->> \v = (
                        ToWooContext::pure_component_or_system_name(fsys::purename(v[0])),
                        (v[0], self->make_path_normalize(v[0]))
                        )
                    ;
                ->  mapping
                ;
        }
        public func get_towoo_context(self: Project)
        {
            return self.m_towoo_context;
        }
        public func load(path: fsys::path_t, dat: dict<string, dynamic>)
        {
            try! self = create(dat["name"] as string, path);

            // 先加载配置！这非常重要！
            for (let name, val : dat["configs"] as dict<dynamic, dynamic>->> \k, v = (k as string, v as string);)
            {
                if (! self.m_configs->get(name)->> \config = config->parse(val);->valor(false))
                    je::logerr(F"选项 {name} = {val} 未在项目中找到或设置失败");
            }

            // TODO: 加载失败和二进制文件怎么git还需考虑一下
            do dat->get("modules")
                ->> \d = d as array<dynamic> 
                    =>> \p = err->has ? [(p, err->val)] | []
                        where err = CxxProject::load(module_name, self)->error
                            , module_name = path / p as string
                        ;
                    ;
                ->  valor([])
                ->> \mr = jeapi::gui::form::errmsg("加载失败", F"无法加载 '{mr[0]}'：{mr[1]}"); 
                ;
            
            self.m_towoo_context->update();

            match (fsys::readall(self.m_path / ".runtime" / "world.list")=>> \dat = dat->dict::deserialize;)
            {
            value(dat)?
                    for (let wpath, isediting : dat)
                    {
                        match (self->load_world(self.m_path / wpath as string))
                        {
                        ok(w)?
                            if (isediting as bool) do self->reset_editing_world(w);
                        err(info)?
                            jeapi::gui::form::errmsg("失败", F"无法加载世界 '{wpath as string}': {info}");
                        }
                    }
            none?;
            }

            // 设置style必须等到gui开起来，这里设置，可能图形库尚未启动，就炸了
            // launch出去自动执行
            je::gui::launch(func()
                {
                    do je::file::readall("@/style.config")
                        =>> \style_dat = style_dat->dict::deserialize;
                        ->> \style_dat = style_dat
                            ->> \k, v = (k as int: je::gui::ImGuiCol, v as array<dynamic>->>\e = e: real;);
                            ;
                        ->> \style_dat = jeapi::gui::style::restore_config(style_dat);
                        ;
                    return false;
                }, ());

            self->restore_dump();

            return result::ok(self);
        }
        public func save_project(self: Project)
        {
            let bad_list = self.m_towoo_context->get_bad_scripts
                ->> \p = p->tostring;
                ->  reduce(\l, r = l + "\n" + r;);
            match (bad_list)
            {
            value(badlist)?
                {
                    jeapi::gui::form::errmsg("失败", "ToWoo 有编译失败未解决：\n" + badlist);
                    je::logwarn("ToWoo 有编译失败未解决：\n" + badlist);
                    return false;
                }
            none?;
            }

            let dat = {
                ["name"] = self.m_name: dynamic,
                ["configs"] = self.m_configs->> \k, v = (k, v->tostring());: dynamic,
                ["modules"] = self.m_modules->unmapping->>\kv = kv[0]->tostring->sub(self.m_path->tostring->len);: dynamic,
            };

            // 编辑中的世界保存到 .runtime 目录内
            do fsys::mkdir(self.m_path / ".runtime");

            if (! self.m_worlds
                ->> \pw = (
                        pw.m_world_path->tostring->sub(self.m_path->tostring->len), 
                        self->get_editing_world->>\w = w == pw.m_world_instance;->valor(false))
                    ;
                ->  mapping
                ->  serialize
                ->> \dat = fsys::writeall(self.m_path / ".runtime" / "world.list", dat);
                ->  valor(false))
            {
                jeapi::gui::form::errmsg("失败", "保存编辑中的世界列表失败");
                je::logwarn("保存编辑中的世界列表失败");
                return false;
            }

            // 顺手保存所有世界
            let failed_saving_worlds = self.m_worlds
                ->  toarray
                =>> \pw = saving_success ?  [] | [pw]
                    where saving_success = self->save_world(pw.m_world_instance)
                    ;
                ;
                
            if (failed_saving_worlds->empty == false)
            {
                let failed_file_list = failed_saving_worlds
                    ->> \pw = pw.m_world_path->tostring;
                    ->  reduce(\l, r = l + "\n" + r;)
                    ->  val;

                jeapi::gui::form::errmsg("错误", F"项目中的一些世界保存失败:\n{failed_file_list}\n项目保存未能完成");
                return false;
            }
            else if (!fsys::writeall(self.m_path/"project.jeproj4", dat as dict<string, dynamic>: string))
            {
                jeapi::gui::form::errmsg("错误", F"保存项目文件失败");
                return false;
            }

            self->clear_dump();
            return true;
        }
        public func close(self: Project)
        {  
            // 关闭env, 稍后释放模块
            self.m_env->close;          
            self->unlock_this_project();
        }
        public func free_modules_after_close(self: Project)
        {
            for (let _, m : self.m_modules)
                m->close;
        }
        public func wait(self: Project)
        {
            self.m_env->wait;
        }
        public func get_env(self: Project)
        {
            return self.m_env;
        }

        func get_project_world(self: Project, world: je::world)
        {
            return self.m_worlds
                -> forall(\pw = pw.m_world_instance == world;)
                -> get(0);
        }
        func is_project_world(self: Project, world: je::world)
        {
            return self->get_project_world(world)->has;
        }
        public func get_editing_world(self: Project)
        {
            return self.m_editing_world;
        }
        public func validate_world_or_warning(self: Project, world: je::world)
        {
            if (self->is_project_world(world))
                return true;
                
            jeapi::gui::form::errmsg("错误", "请求的世界不存在"); 
            return false;
        }
        public func get_worlds_runtime_systems(self: Project, world: je::world)
        {
            return self->get_project_world(world)->>\pw = pw.m_runtime_systems;;
        }
        public func set_worlds_runtime_systems(self: Project, world: je::world, syss: array<je::typeinfo>)
        {
            return self->get_project_world(world)->>\pw = pw.m_runtime_systems = syss;->has;
        }
        public func reset_editing_world(self: Project, world: je::world)=> result<void, string>
        {
            if (self->is_project_world(world) || self->is_debugging)
            {
                // 将编辑器系统从旧编辑世界中移除，这里要求新编辑世界必须属于项目
                let editing_world = self->get_editing_world();

                match (editing_world)
                {
                value(last_edit_world)?
                {
                    if (last_edit_world == world)
                        return result::ok(do nil); // 新老世界相同，跳过更新

                    last_edit_world->remove_system(self->get_config_editor_system);
                }
                none?;
                }

                if (self->is_debugging == false)
                    do world->add_system(self->get_config_editor_system);

                self.m_editing_world = option::value(world);
                return result::ok(do nil);
            }
            return result::err("给定的世界不属于当前项目");
        }

        public func get_configs(self: Project)
        {
            return self.m_configs;
        }

        public func get_config(self: Project, config_name: string)
        {
            return self.m_configs->get(config_name);
        }

        public func get_config_editor_system(self: Project)
        {
            return self->get_config("JE_PROJECT_EDITOR_SYSTEM")
                ->> \config = config->tostring;
                ->  valor(DEFAULT_EDITOR_SYSTEM_NAME)
                ->  je::typeinfo::load
                ->  val;
        }

        public func get_all_worlds(self: Project)
        {
            return self.m_worlds->>\pw = pw.m_world_instance;;
        }
        func append_world_to_list(self: Project, world: ProjectWorld)
        {
            self.m_worlds->add(world);

            // 世界编辑器已经做平了这一块
            // do world.m_world_instance->add_system(
            //     je::typeinfo::load("Translation::TranslationUpdatingSystem")->val);

            // 创建默认世界之后，自动顺便创建调试使用的摄像机
            let camera_walker = world.m_world_instance->add_entity([
                // Transform 族组件
                je::typeinfo::load("Transform::LocalPosition")->val,
                je::typeinfo::load("Transform::LocalRotation")->val,
                je::typeinfo::load("Transform::LocalToWorld")->val,
                je::typeinfo::load("Transform::Translation")->val,
                je::typeinfo::load("Transform::Anchor")->val,
                // Editor 族组件
                je::typeinfo::load("Editor::Invisable")->val,
                je::typeinfo::load("Editor::EditorWalker")->val,
            ]);
            // 摄像机，同时负责x轴旋转
            let editor_camera = world.m_world_instance->add_entity([
                // Transform 族组件
                je::typeinfo::load("Transform::LocalRotation")->val,
                je::typeinfo::load("Transform::LocalToParent")->val,
                je::typeinfo::load("Transform::Translation")->val,
                // Editor 族组件
                je::typeinfo::load("Editor::Invisable")->val,
                je::typeinfo::load("Editor::EditorWalker")->val,
                // Camera 族组件
                je::typeinfo::load("Camera::PerspectiveProjection")->val,
                je::typeinfo::load("Camera::Projection")->val,
                je::typeinfo::load("Camera::RendToFramebuffer")->val,
            ]);
            editor_camera->je::editor::apply_camera_framebuf_setting(320, 240);
            do editor_camera->editor::set_parent(camera_walker, true);
    
            // 移动器，这里只创建根实体，具体的轴由编辑器系统生成
            do world.m_world_instance->add_entity([
                // Transform 族组件
                je::typeinfo::load("Transform::LocalPosition")->val,
                je::typeinfo::load("Transform::LocalRotation")->val,
                je::typeinfo::load("Transform::LocalScale")->val,
                je::typeinfo::load("Transform::Anchor")->val,
                je::typeinfo::load("Transform::Translation")->val,
                je::typeinfo::load("Transform::LocalToWorld")->val,
                // Editor 族组件
                je::typeinfo::load("Editor::Invisable")->val,
                je::typeinfo::load("Editor::EntityMoverRoot")->val,
            ]);

            return world.m_world_instance;
        }
        public func create_new_world(self: Project, new_world_file_path: fsys::path_t)
        {          
            return self->append_world_to_list(
                ProjectWorld 
                {
                    m_world_instance = self.m_env->create_world,
                    m_world_path = new_world_file_path,
                    m_runtime_systems = mut [],
                    m_remark_note = mut "",
                });
        }
        public func get_world_path(self: Project, w: je::world)
        {
            return self->get_project_world(w)->> \pw = pw.m_world_path;;
        }
        public func get_world_remark(self: Project, w: je::world)
        {
            return self->get_project_world(w)->> \pw = pw.m_remark_note;;
        }
        public func set_world_remark(self: Project, w: je::world, remark: string)
        {
            return self->get_project_world(w)->> \pw = pw.m_remark_note = remark;->has;
        }
        public func serialize_entity(_: Project, e: je::entity)
        {
            return jeapi::serialize::entity(e, false);
        }
        public func serialize_world(self: Project, w: je::world)
        {
            return self->get_project_world(w)
                =>> \pw = jeapi::serialize::world(w, true)->okay
                    ->> func (dat)
                        {
                            let mdat = dat->tomap;
                            mdat->set("entities", dat["entities"] as array<dynamic>
                                ->  std::sort(
                                        \l, r = 
                                            (l as dict<dynamic, dynamic>->getor("euid": dynamic, 0H: dynamic) as int) 
                                            < 
                                            (r as dict<dynamic, dynamic>->getor("euid": dynamic, 0H: dynamic) as int)
                                        ;
                                    )
                                ->> \edat = edat as dict<dynamic, dynamic>->erase("euid": dynamic);
                                : dynamic);
                            mdat->set("systems", dat["systems"] as array<dynamic>->std::sort(
                                    \l, r = (l as string) < (r as string);
                                ): dynamic);
                            return mdat->unsafe::cast:< typeof(dat) >;
                        }
                    ->> \dat = dat->apply("path", pw.m_world_path->tostring->sub(self.m_path->tostring->len): dynamic);
                    ->> \dat = dat->apply("runtime_systems", pw.m_runtime_systems->>\t=t->name; as array<string>: dynamic);
                    ->> \dat = dat->apply("remark", pw.m_remark_note as string: dynamic);
                    ;
                ;
        }
        public func deserialize_world(self: Project, dat: dict<string, dynamic>)
        {
            let w = self->append_world_to_list(
                ProjectWorld 
                {
                    m_world_instance = self.m_env->load_world(dat),
                    m_world_path = self.m_path / dat["path"] as string,
                    m_runtime_systems = 
                        mut dat->getor("runtime_systems", []: dynamic) as array<dynamic>
                            =>> \elem = systype->has ? [systype->val] | []
                                where systype = je::typeinfo::load(elem as string);,
                    m_remark_note = mut dat->getor("remark", "": dynamic) as string,
                });

            if (dat->getor("is_editing", false: dynamic) as bool)
                do self->reset_editing_world(w);

            return w;
        }
        public func save_world(self: Project, w: je::world)
        {
            return self->serialize_world(w)
                ->> \dat = fsys::writeall(self.m_path / dat["path"]: string, dat as dict<string, dynamic>: string);
                ->  valor(false);
        }
        public func load_world(self: Project, file_path: fsys::path_t)
        {
            // 不允许重复加载相同路径的世界
            if (self.m_worlds->forall(\pworld = pworld.m_world_path == file_path;)->empty)
            {
                match (fsys::readall(file_path)
                    =>> \dat = dict::deserialize(dat)
                        ->> \d = d
                            ->> \k, v = (k as string, v);
                            ;
                        ;
                    ->> \dat = self->deserialize_world(dat);)
                {
                value(w)?
                    return result::ok(w);
                none?
                    return result::err("序列化世界失败");
                }
            }
            return result::err("相同世界已存在");
        }

        public func destroy_world(self: Project, world: je::world)=> result<void, string>
        {
            // 使用create_new_world创建的世界，务必使用destroy_world销毁，不应该close
            match (self->get_project_world(world))
            {
            value(w)?
            {
                // 如果当前编辑中的世界就是待删除的世界，那么需要更新新的编辑世界
                let need_update_new_editing_world = 
                    self->get_editing_world->>\rw = rw == world;->valor(false);
               
                // NOTE: 必须在切换完成之后才能从世界列表中移除世界，否则无法正确获取编辑中的世界
                do self.m_worlds->remove(self.m_worlds->find(w));

                // 如果还有世界，那么选择第一个作为编辑中世界顶替
                self.m_worlds->get(0)
                    ->> \w = need_update_new_editing_world 
                        ? self->reset_editing_world(w.m_world_instance)->unwarp
                        | nil: void
                        ; // 必须成功
                    ->  or(\ = self.m_editing_world = option::none;)
                    ;

                world->close;
                
                return result::ok(do nil);
            }
            none?
                return result::err("期待销毁的世界不存在");
            }
        }
    }
}

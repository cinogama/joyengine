// project.main
// 用于储存编辑中的项目信息

import je;
import je.gui;

import pkg.try;
import config;

import builtin.editor.environment.main;
import builtin.api.rend.main;
import builtin.api.gui.form.msg;
import builtin.editor.cpp.main;
import builtin.editor.tools.script_manager;

namespace editor
{
    let DEFAULT_EDITOR_SYSTEM_NAME = "Editor::DefaultEditorSystem";

    public using ProjectWorld = struct{
        m_world_instance: je::world,
        m_world_path: filesys::path_t,
        m_runtime_systems: mut array<je::typeinfo>,
        m_remark_note: mut string,
    };

    using DebugContext = struct {
        // 想了半天，还是把调试状态摆在这里维护
        m_project: Project,
        m_dumped_editing_worlds: array<dict<string, dynamic>>,
    };

    public using Project = struct{
        m_name: string,             // 项目的名称，不能更改
        m_path: filesys::path_t,    // 项目所在的目录
        m_env: Environment,         // 项目环境
        m_configs: map<string, Project::IConfig>, // 配置信息，是的，这是个map，意味着开发者理论上可以自己加点配置项目
        m_worlds: vec<ProjectWorld>,
        m_modules: map<filesys::path_t, CxxProject>, 
        m_editing_world: mut option<je::world>,
        m_debug_context: mut option<DebugContext>,
    }
    {
        public func make_path_normalize(self: Project, path: filesys::path_t)
        {
            let npath = path->tostring;
            if (npath->beginwith(self.m_path->tostring + "/"))
            {
                return "@" + npath->sub(self.m_path->tostring->len);
            }
            return npath;
        }
        public func parse_path_normalize(self: Project, path: string)
        {
            if (path->beginwith("@"))
                return filesys::normalize(self.m_path->tostring + path->sub(1));
            return filesys::normalize(path);
        }
        public func is_debugging(self: Project)
        {
            return self.m_debug_context->has;
        }
        public func stop_debug(self: Project)
        {
            if (! self->is_debugging)
                return result::err("未在调试中");

            assert (self.m_worlds->empty);

            // 关闭所有世界~~
            do self->get_env->get_universe->editor::get_all_worlds
                ->> \w = w->close();
                ;

            // 恢复所有世界！
            self->restore_all_world(self.m_debug_context->val.m_dumped_editing_worlds);
            self.m_debug_context = option::none;

            return result::ok(do nil);
        }

        public func start_debug(self: Project)
        {
            if (self->is_debugging)
                return result::err("已经在调试中，不可重复调试");

            try! dumpped = self->dump_and_close_all_world();

            let context = DebugContext {
                    m_project = self,
                    m_dumped_editing_worlds = dumpped,
                };

            // OK 接下来在当前世界上创建游戏世界，至于在哪个世界渲染……emm
            for (let _, wdat : context.m_dumped_editing_worlds)
            {
                let wdat_map = wdat->tomap();
                let syss = wdat_map->getor("runtime_systems", []: dynamic) as array->connect(
                    wdat_map->getor("systems", []: dynamic) as array
                );
                wdat_map->set("systems", syss: dynamic);
                do jeapi::deserialize::world(self->get_env->get_universe, wdat_map->unsafe::cast:< typeof(wdat)>, true);
            }
            self.m_debug_context = option::value(context);

            return result::ok(context);
        }

        public func get_module(self: Project, name: filesys::path_t)
        {
            return self.m_modules->get(name);
        }
        public func get_all_modules(self: Project)
        {
            return self.m_modules;
        }
        public func dump_all_world(self: Project)
        {
            let dump_dats = self.m_worlds->toarray
                =>> \pw = dat->has 
                    ? [dat->val->apply("is_editing", self->get_editing_world
                        ->> \ew = ew == pw.m_world_instance;
                        ->  valor(false) as bool: dynamic)] 
                    | [] 
                    where dat = self->serialize_world(pw.m_world_instance)
                    ;
                ;
            
            if (dump_dats->len != self.m_worlds->len)
                return result::err("有世界序列化失败"); 

            return result::ok(dump_dats);
        }
        public func dump_and_close_all_world(self: Project)
        {
            try! dats = self->dump_all_world();

            // OK 关闭全部现存世界
            do self.m_worlds->toarray->> \pw = self->destroy_world(pw.m_world_instance)->unwarp();;
            return result::ok(dats);
        }
        public func restore_all_world(self: Project, dats: array<dict<string, dynamic>>)
        {
            do dats->>\dat = self->deserialize_world(dat);;
        }
        func _create_default_configs(env: Environment)
        {
            using je;
            using je::gui;

            return {
                /* 引擎的默认编辑器系统 */
                ["JE_PROJECT_EDITOR_SYSTEM"] = IConfig::create(Config::create(
                    typeinfo::load(DEFAULT_EDITOR_SYSTEM_NAME)->val,
                    func(origin_editor_system)
                    {
                        let USABLE_EDITOR_SYSTEMS = typeinfo::editor::get_all_systems_types()
                                ->  forall(\t = t->name->beginwith("Editor::"););
                        let USABLE_EDITOR_SYSTEM_NAMES =  USABLE_EDITOR_SYSTEMS
                                ->> \t = t->name;;

                        let result = Combo("编辑系统", 
                            USABLE_EDITOR_SYSTEM_NAMES, 
                            USABLE_EDITOR_SYSTEM_NAMES->find(origin_editor_system->name))
                            =>> \index = USABLE_EDITOR_SYSTEMS->get(index);;
                        TextDisabled("* 重启后生效");
                        return result;
                    },
                    func(oldval, newval)
                    {
                        return true;
                    },
                    \val = val->name;,
                    \str = typeinfo::load(str);,
                    \_ = "// Editor-system is not needed when export.";,
                )),
                /* 项目的描述信息 */
                ["JE_PROJECT_DESCRIBE"] = IConfig::create(Config::create(
                    "新项目，你可以在这里编辑项目的描述文本",
                    func(origin_text)
                    {
                        Text("项目描述");
                        return InputTextMultilineSize("##项目描述", origin_text, 400., 200.);
                    },
                    \o,n = true;,
                    \val = val;,
                    \str = option::value(str);,
                    \describe = "// Describe is not needed when export.";,
                )),
                ["JE_ENGINE_TIME_SLEEP_SUPPRESSION"] = IConfig::create(Config::create(
                    do nil,
                    func(_create_default_configs)
                    {
                        Text("引擎提前唤醒间隔");
                        let result = InputFloatFormat("##引擎提前唤醒间隔", je::editor::get_sleep_suppression(), "%.6f");
                        do result->>\suppression=je::editor::set_sleep_suppression(suppression);;
                        TextDisabled("适当提高此值可以增加执行间隔和帧数的稳定性");
                        return result->>\_=do nil;;
                    },
                    \o,n = true;,
                    \_ = je::editor::get_sleep_suppression(): string;,
                    func (str){
                        je::editor::set_sleep_suppression(str: real);
                        return option::value(do nil);
                    },
                    \_ = F"je::editor::set_sleep_suppression({supp});"
                        where supp = je::editor::get_sleep_suppression()
                    ;,
                )),
                ["JE_GUI_FONT"] = IConfig::create(Config::create(
                    ("@/resource/font/HarmonyOS_Sans_SC_Regular.ttf", 18),
                    func(config)
                    {
                        Text("GUI字体");
                        let (font_path, font_size) = config;

                        let new_font_path = InputText("##fontpath", font_path)->valor(font_path);
                        SameLine();
                        let new_font_size = InputInt("##fontsize", font_size)->valor(font_size);

                        TextDisabled("* 重启后生效");

                        if (font_path != new_font_path || font_size != new_font_size)
                            return option::value((new_font_path, new_font_size));
                        return option::none;
                    },
                    func(o,n){je::gui::set_font(option::value(n[0]), n[1]); return true;},
                    \v = [v[0]: dynamic, v[1]: dynamic]->serialize->val;,
                    func (str){
                        let v = array::deserialize(str)->val;
                        return option::value((v[0] as string, v[1] as int));
                    },
                    \dat = F"je::gui::set_font(option::value({font->enstring}), {size});"
                        where (font, size) = dat
                    ;,
                )),
            }mut;
        }
        public func create(name: string, path: filesys::path_t)
        {
            let env = Environment::create();
            
            assert(filesys::setworkpath(path));

            let proj = Project{
                m_name = name,
                m_path = path,
                m_env = env,
                m_configs = _create_default_configs(env),
                m_worlds = []mut,
                m_modules = {}mut,
                m_debug_context = mut option::none,
                m_editing_world = mut option::none,
            };

            tools::update_tool_scripts(proj);
            gui::drawpannel::update_and_get_scripts(proj);

            return proj;
        }
        public func active_module(self: Project, module: CxxProject)
        {
            assert (std::issame(self.m_modules->getorset(module.path, module), module));
        }
        public func deactive_module(self: Project, module: CxxProject)
        {
            assert (std::issame(self.m_modules->getor(module.path, module), module));
            if (self.m_modules->remove(module.path))
            {
                module->close();
                return true;
            }
            return false;
        }
        public func load(path: filesys::path_t, dat: dict<string, dynamic>)
        {
            let self = create(dat["name"] as string, path);

            // 先加载配置！这非常重要！
            for (let name, val : dat["configs"] as dict ->> \k, v = (k as string, v as string);)
            {
                if (! self.m_configs->get(name)->> \config = config->parse(val);->valor(false))
                    je::logerr(F"选项 {name} = {val} 未在项目中找到或设置失败");
            }

            // TODO: 加载失败和二进制文件怎么git还需考虑一下
            do dat->get("modules")
                ->> \d = d as array<dynamic> 
                    =>> \p = err->has ? [(p, err->val)] | []
                        where err = CxxProject::load(module_name, self)->error
                            , module_name = path / p as string
                        ;
                    ;
                ->  valor([])
                ->> \mr = jeapi::gui::form::errmsg("加载失败", F"无法加载 '{mr[0]}'：{mr[1]}"); 
                ;

            do dat["worlds"] as array
                ->> \wpath = self->load_world(path / wpath as string);
                ;

            return self;
        }
        public func save_project(self: Project)
        {
            let (w, h) = je::input::window_size();
            let dat = {
                ["name"] = self.m_name: dynamic,
                ["configs"] = self.m_configs->> \k, v = (k, v->tostring());: dynamic,
                ["worlds"] = self.m_worlds->> \pw = pw.m_world_path->tostring->sub(self.m_path->tostring->len);: dynamic,
                ["modules"] = self.m_modules->unmapping->>\kv = kv[0]->tostring->sub(self.m_path->tostring->len);: dynamic,
            };

            // 顺手保存所有世界
            let failed_saving_worlds = self.m_worlds
                ->  toarray
                =>> \pw = saving_success ?  [] | [pw]
                    where saving_success = self->save_world(pw.m_world_instance)
                    ;
                ;
                
            if (failed_saving_worlds->empty == false)
            {
                let failed_file_list = failed_saving_worlds
                    ->> \pw = pw.m_world_path->tostring;
                    ->  reduce(\l, r = l + "\n" + r;)
                    ->  val;

                jeapi::gui::form::errmsg("错误", F"项目中的一些世界保存失败:\n{failed_file_list}\n项目保存未能完成");
                return false;
            }
            else if (!filesys::writeall(self.m_path/"project.jeproj4", dat as dict<string, dynamic>: string))
            {
                jeapi::gui::form::errmsg("错误", F"保存项目文件失败");
                return false;
            }
            return true;
        }
        public func close(self: Project)
        {
            for (let _, m : self.m_modules)
                m->close;
                
            self.m_env->close;
        }
        public func wait(self: Project)
        {
            self.m_env->wait;
        }
        public func get_env(self: Project)
        {
            return self.m_env;
        }

        func get_project_world(self: Project, world: je::world)
        {
            return self.m_worlds
                -> forall(\pw = pw.m_world_instance == world;)
                -> get(0);
        }
        func is_project_world(self: Project, world: je::world)
        {
            return self->get_project_world(world)->has;
        }
        public func get_editing_world(self: Project)
        {
            return self.m_editing_world;
        }
        public func validate_world_or_warning(self: Project, world: je::world)
        {
            if (self->is_project_world(world))
                return true;
                
            jeapi::gui::form::errmsg("错误", "请求的世界不存在"); 
            return false;
        }
        public func get_worlds_runtime_systems(self: Project, world: je::world)
        {
            return self->get_project_world(world)->>\pw = pw.m_runtime_systems;;
        }
        public func set_worlds_runtime_systems(self: Project, world: je::world, syss: array<je::typeinfo>)
        {
            return self->get_project_world(world)->>\pw = pw.m_runtime_systems = syss;->has;
        }
        public func reset_editing_world(self: Project, world: je::world)=> result<void, string>
        {
            if (self->is_project_world(world) || self->is_debugging)
            {
                // 将编辑器系统从旧编辑世界中移除，这里要求新编辑世界必须属于项目
                let editing_world = self->get_editing_world();

                match (editing_world)
                {
                value(last_edit_world)?
                {
                    if (last_edit_world == world)
                        return result::ok(do nil); // 新老世界相同，跳过更新

                    last_edit_world->remove_system(self->get_config_editor_system);
                }
                none?;
                }

                if (self->is_debugging == false)
                    do world->add_system(self->get_config_editor_system);

                self.m_editing_world = option::value(world);
                return result::ok(do nil);
            }
            return result::err("给定的世界不属于当前项目");
        }

        public func get_configs(self: Project)
        {
            return self.m_configs;
        }

        public func get_config(self: Project, config_name: string)
        {
            return self.m_configs->get(config_name);
        }

        public func get_config_editor_system(self: Project)
        {
            return self->get_config("JE_PROJECT_EDITOR_SYSTEM")
                ->> \config = config->tostring;
                ->  valor(DEFAULT_EDITOR_SYSTEM_NAME)
                ->  je::typeinfo::load
                ->  val;
        }

        public func get_all_worlds(self: Project)
        {
            return self.m_worlds->>\pw = pw.m_world_instance;;
        }
        func append_world_to_list(self: Project, world: ProjectWorld)
        {
            self.m_worlds->add(world);

            // 世界编辑器已经做平了这一块
            // do world.m_world_instance->add_system(
            //     je::typeinfo::load("Translation::TranslationUpdatingSystem")->val);

            // 创建默认世界之后，自动顺便创建调试使用的摄像机
            let camera_walker = world.m_world_instance->add_entity([
                // Transform 族组件
                je::typeinfo::load("Transform::LocalPosition")->val,
                je::typeinfo::load("Transform::LocalRotation")->val,
                je::typeinfo::load("Transform::LocalToWorld")->val,
                je::typeinfo::load("Transform::Translation")->val,
                je::typeinfo::load("Transform::Anchor")->val,
                // Editor 族组件
                je::typeinfo::load("Editor::Invisable")->val,
                je::typeinfo::load("Editor::EditorWalker")->val,
            ]);
            // 摄像机，同时负责x轴旋转
            let editor_camera = world.m_world_instance->add_entity([
                // Transform 族组件
                je::typeinfo::load("Transform::LocalRotation")->val,
                je::typeinfo::load("Transform::LocalToParent")->val,
                je::typeinfo::load("Transform::Translation")->val,
                // Editor 族组件
                je::typeinfo::load("Editor::Invisable")->val,
                je::typeinfo::load("Editor::EditorWalker")->val,
                // Camera 族组件
                je::typeinfo::load("Camera::PerspectiveProjection")->val,
                je::typeinfo::load("Camera::Projection")->val,
                je::typeinfo::load("Camera::RendToFramebuffer")->val,
            ]);
            editor_camera->je::editor::apply_camera_framebuf_setting(320, 240);
            do editor_camera->editor::set_parent(camera_walker, true);
    
            // 移动器，这里只创建根实体，具体的轴由编辑器系统生成
            do world.m_world_instance->add_entity([
                // Transform 族组件
                je::typeinfo::load("Transform::LocalPosition")->val,
                je::typeinfo::load("Transform::LocalRotation")->val,
                je::typeinfo::load("Transform::LocalScale")->val,
                je::typeinfo::load("Transform::Anchor")->val,
                je::typeinfo::load("Transform::Translation")->val,
                je::typeinfo::load("Transform::LocalToWorld")->val,
                // Editor 族组件
                je::typeinfo::load("Editor::Invisable")->val,
                je::typeinfo::load("Editor::EntityMoverRoot")->val,
            ]);

            return world.m_world_instance;
        }
        public func create_new_world(self: Project, new_world_file_path: filesys::path_t)
        {          
            return self->append_world_to_list(
                ProjectWorld 
                {
                    m_world_instance = self.m_env->create_world,
                    m_world_path = new_world_file_path,
                    m_runtime_systems = mut [],
                    m_remark_note = mut "",
                });
        }
        public func get_world_path(self: Project, w: je::world)
        {
            return self->get_project_world(w)->> \pw = pw.m_world_path;;
        }
        public func get_world_remark(self: Project, w: je::world)
        {
            return self->get_project_world(w)->> \pw = pw.m_remark_note;;
        }
        public func set_world_remark(self: Project, w: je::world, remark: string)
        {
            return self->get_project_world(w)->> \pw = pw.m_remark_note = remark;->has;
        }
        public func serialize_entity(self: Project, e: je::entity)
        {
            return jeapi::serialize::entity(e);
        }
        public func serialize_world(self: Project, w: je::world)
        {
            return self->get_project_world(w)
                =>> \pw = jeapi::serialize::world(w)->okay
                    ->> func (dat)
                        {
                            let mdat = dat->tomap;
                            mdat->set("entities", dat["entities"] as array->std::sort(
                                    \l, r = (l as dict["name": dynamic] as string) < (r as dict["name": dynamic] as string);
                                ): dynamic);
                            mdat->set("systems", dat["systems"] as array->std::sort(
                                    \l, r = (l as string) < (r as string);
                                ): dynamic);
                            return mdat->unsafe::cast:< typeof(dat) >;
                        }
                    ->> \dat = dat->apply("path", pw.m_world_path->tostring->sub(self.m_path->tostring->len): dynamic);
                    ->> \dat = dat->apply("runtime_systems", pw.m_runtime_systems->>\t=t->name; as array<string>: dynamic);
                    ->> \dat = dat->apply("remark", pw.m_remark_note as string: dynamic);
                    ;
                ;
        }
        public func deserialize_world(self: Project, dat: dict<string, dynamic>)
        {
            let w = self->append_world_to_list(
                ProjectWorld 
                {
                    m_world_instance = self.m_env->load_world(dat),
                    m_world_path = self.m_path / dat["path"] as string,
                    m_runtime_systems = 
                        mut dat->getor("runtime_systems", []: dynamic) as array
                            =>> \elem = systype->has ? [systype->val] | []
                                where systype = je::typeinfo::load(elem as string);,
                    m_remark_note = mut dat->getor("remark", "": dynamic) as string,
                });

            if (dat->getor("is_editing", false: dynamic) as bool)
                do self->reset_editing_world(w);

            return w;
        }
        public func save_world(self: Project, w: je::world)
        {
            return self->serialize_world(w)
                ->> \dat = filesys::writeall(self.m_path / dat["path"]: string, dat as dict<string, dynamic>: string);
                ->  valor(false);
        }
        public func load_world(self: Project, file_path: filesys::path_t)
        {
            // 不允许重复加载相同路径的世界
            if (self.m_worlds->forall(\pworld = pworld.m_world_path == file_path;)->empty)
            {
                match (filesys::readall(file_path)
                    =>> \dat = dict::deserialize(dat)
                        ->> \d = d
                            ->> \k, v = (k as string, v);
                            ;
                        ;
                    ->> \dat = self->deserialize_world(dat);)
                {
                value(w)?
                    return result::ok(w);
                none?
                    return result::err("序列化世界失败");
                }
            }
            return result::err("相同世界已存在");
        }
        
        public func destroy_world(self: Project, world: je::world)=> result<void, string>
        {
            // 使用create_new_world创建的世界，务必使用destroy_world销毁，不应该close
            match (self->get_project_world(world))
            {
            value(w)?
            {
                // 如果当前编辑中的世界就是待删除的世界，那么需要更新新的编辑世界
                let need_update_new_editing_world = 
                    self->get_editing_world->>\rw = rw == world;->valor(false);
               
                // NOTE: 必须在切换完成之后才能从世界列表中移除世界，否则无法正确获取编辑中的世界
                do self.m_worlds->remove(self.m_worlds->find(w));

                // 如果还有世界，那么选择第一个作为编辑中世界顶替
                self.m_worlds->get(0)
                    ->> \w = need_update_new_editing_world 
                        ? self->reset_editing_world(w.m_world_instance)->unwarp
                        | nil: void
                        ; // 必须成功
                    ->  or(\ = self.m_editing_world = option::none;)
                    ;

                world->close;
                
                return result::ok(do nil);
            }
            none?
                return result::err("期待销毁的世界不存在");
            }
        }
    }
}

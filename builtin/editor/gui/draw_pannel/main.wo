import je;
import je::gui;

import pkg::image;
import pkg::fsys;

import tools;
import imagescripts;

import builtin::editor::gui::inputmgr;

using je;
using je::gui;

namespace editor::gui::drawpannel
{
    public alias color4_t = (real, real, real, real);

    func save_texture_to_path(context: EditorContext, tex: graphic::texture, path: string)
    {
        let (w, h) = tex->size();
        let saving_img = new! image(w, h);

        for (let mut x = 0; x < w; x += 1)
            for (let mut y = 0; y < h; y += 1)
                saving_img->setpix((x, y), tex->pix((x, y))->get_color);

        let result = saving_img->save(path->replace("@", context->get_project.m_path->tostring));
        if (!result)
            jeapi::gui::form::errmsg("图像保存失败", F"无法保存图像到{path}");
        return result;
    }
    public using TextureSnapshot = struct
    {   
        m_width: int,
        m_height: int,
        m_pixels: array<color4_t>,
        m_texture: graphic::texture,
    }
    {
        public func create(tex: graphic::texture)
        {
            let (w, h) = tex->size;
            let pxs = new! array(w * h, mut (0., 0., 0., 0.));

            for (let mut x = 0; x < w; x += 1)
                for (let mut y = 0; y < h; y += 1)
                    pxs[y * w + x] = tex->pix((x, y))->get_color;

            return TextureSnapshot{
                m_width = w,
                m_height = h,
                m_pixels = pxs->unsafe::cast:< array<color4_t> >,
                m_texture = tex,
            };
        }
        public func restore(self: TextureSnapshot)
        {
            for (let mut x = 0; x < self.m_width; x += 1)
                for (let mut y = 0; y < self.m_height; y += 1)
                    self.m_texture->pix((x, y))->set_color(self.m_pixels[y * self.m_width + x]);
        }
    }

    using HistoryManager = struct {
        m_texture: graphic::texture,
        m_current: mut int,
        m_history: vec<TextureSnapshot>,
        m_edited_mark: mut bool,
    }
    {
        func create(tex: graphic::texture)
        {
            return HistoryManager{
                m_texture = tex,
                m_current = mut 0,
                m_history = [new! TextureSnapshot(tex)]mut,
                m_edited_mark = mut false,
            };  
        }
        func mark_as_edited(self: HistoryManager)
        {
            self.m_edited_mark = true;
        }
        func edited(self: HistoryManager)
        {
            return self.m_current != 0 || self.m_edited_mark;
        }
        func save_step(self: HistoryManager)
        {
            let snapshot = new! TextureSnapshot(self.m_texture);
            self.m_current += 1;
            if (self.m_current < self.m_history->len)
                // 新添加快照将覆盖后续所有
                assert(self.m_history->shrink(self.m_current)); // 必须成功
            self.m_history->add(snapshot);            
        }
        func undo(self: HistoryManager)
        {
            if (self->undoable())
                self.m_history[self.m_current -:= 1]->restore;
        }
        func reset(self: HistoryManager)
        {
            self.m_current = 0;
            self.m_history[0]->restore();
        }
        func redo(self: HistoryManager)
        {
            if (self->redoable())
                self.m_history[self.m_current +:= 1]->restore;
        }

        func undoable(self: HistoryManager)
        {
            return self.m_current > 0;
        }
        func redoable(self: HistoryManager)
        {
            return self.m_current < self.m_history->len - 1;
        }
    }
    using DrawContextT = struct{
        scale:      mut real,
        offset_x:   mut real,
        offset_y:   mut real,

        drawtoolname: mut string,
        drawtool:   mut IDrawtool,

        mousedown:  mut bool,

        usecolor:   mut color4_t,
        maincolor:  mut color4_t,
        subcolor:   mut color4_t,

        edited_textures: map<graphic::texture, (int/*texture pass id*/, HistoryManager)>,
        openform: mut bool,
    }
    {
        func update_edit_textures_history(self: DrawContextT, passid: int, oldtex: graphic::texture, newtex: graphic::texture)
        {
            do self.edited_textures->remove(oldtex);
            let history = new! HistoryManager(newtex);
            self.edited_textures->set(newtex, (passid, history));
            history->mark_as_edited();
        }
    }

    func _delta_wheel()
    {
        static let mut _w = input::wheel(0)[1];
        let _nw = input::wheel(0)[1];
        let delta = _nw - _w;
        _w = _nw;
        return delta;
    }

    interface! IDrawtool
    {
        public func OnMouseDown(self: IDrawtool, tex: graphic::texture, col: color4_t, pos: (int, int))=> void;
        public func OnMouseHold(self: IDrawtool, tex: graphic::texture, col: color4_t, pos: (int, int))=> void;
        public func OnMouseUp(self: IDrawtool, tex: graphic::texture, col: color4_t, pos: (int, int))=> void;
    }

    let all_draw_tools = [
        ("无", \=new! IDrawtool((): tools::Nothing);),
        ("钢笔", \=new! IDrawtool(new! tools::Pen());),
        ("直线", \=new! IDrawtool(new! tools::Line());),
        ("矩形", \=new! IDrawtool(new! tools::Rect());),
        ("填充", \=new! IDrawtool((): tools::Fill);),
    ];

    func edittexture(
        context: EditorContext, 
        entity: option<jeapi::debug::Eeid>, 
        images: array<(int, mut graphic::texture, mut option<string>)>, 
        draw_context: DrawContextT)
    {
        let mut open = true;
        match (BeginAttrOpen(F"绘制##{JobID()}", WindowsAttribute::ImGuiWindowFlags_MenuBar))
        {
        value(show)?
            if (show)
            {
                if (BeginTabBar("##draw_textures"))
                {
                    for (let index, (passid, texture, path) : images)
                    {
                        let history_mgr = draw_context.edited_textures[texture][1];

                        if (IsWindowFocused())
                        {
                            if (jeapi::gui::inputmgr::keyspush([je::keycode::L_CTRL, je::keycode::Z]))
                                history_mgr->undo();
                            if (jeapi::gui::inputmgr::keyspush([je::keycode::L_CTRL, je::keycode::Y]))
                                history_mgr->redo();
                        }

                        let texture_path = path->valor("<内置>");
                        if (BeginTabItem(F"通道{passid}: {texture_path}"))
                        {
                            if (BeginMenuBar())
                            {
                                if (BeginMenu("文件"))
                                {
                                    if (MenuItem("重置当前通道路径"))
                                    {
                                        jeapi::gui::form::ask("是否确认", "文件的路径将被重置，保存时将自动保存到其他目录。\n操作不可撤销，是否继续？",
                                            func(ok)
                                            {
                                                if (ok)
                                                {
                                                    draw_context->update_edit_textures_history(passid, texture, texture);
                                                    images[index][2] = option::none;
                                                }
                                            });
                                    }
                                    if (MenuItem("画布尺寸"))
                                    {
                                        // 更新画布尺寸之后，创建新的纹理对象覆盖到数组里
                                        let image_old_sz = texture->size;
                                        let image_new_sz = (mut image_old_sz[0], mut image_old_sz[1]);

                                        let open = new! mutable(true);

                                        launch(func(){
                                            match (BeginAttrOpen("创建绘制对象", WindowsAttribute::ImGuiWindowFlags_AlwaysAutoResize))
                                            {
                                            value(show)?
                                                if (show)
                                                {
                                                    Text("尺寸：");
                                                    Text("x:");
                                                    SameLine();
                                                    do InputInt("##x", image_new_sz[0])->>func(vi){
                                                        if (vi <= 0) return;
                                                        image_new_sz[0] = vi;
                                                    };
                                                    SameLine();
                                                    Text("y:");
                                                    SameLine();
                                                    do InputInt("##y", image_new_sz[1])->>func(vi){
                                                        if (vi <= 0) return;
                                                        image_new_sz[1] = vi;
                                                    };
                                                    if (Button("应用"))
                                                    {
                                                        jeapi::gui::form::ask("是否确认", "将覆盖当前通道纹理，操作不可撤销，是否继续？",
                                                            func(ok)
                                                            {
                                                                if (ok)
                                                                {
                                                                    open->set(false);
                                                                    
                                                                    let new_texture = new! je::graphic::texture(image_new_sz...);
                                                                    for (let mut ix = 0; ix < std::min(image_new_sz[0], image_old_sz[0]); ix += 1)
                                                                        for (let mut iy = 0; iy < std::min(image_new_sz[1], image_old_sz[1]); iy += 1)
                                                                            new_texture->pix((ix, iy))->set_color(texture->pix((ix, iy))->get_color());

                                                                    images[index][1] = new_texture;
                                                                    do texture->path->>\path = new_texture->bind_path(path);;

                                                                    draw_context->update_edit_textures_history(passid, texture, new_texture);
                                                                }
                                                            });                           
                                                    }
                                                    SameLine();

                                                    if (Button("取消"))
                                                        open->set(false);
                                                }
                                            none?
                                                open->set(false);
                                            }
                                            
                                            End();
                                            return open->get;
                                        }, ());
                                    }
                                    EndMenu();
                                }
                                if (BeginMenu("编辑"))
                                {
                                    if (MenuItemShortcutEnabled("撤销", "Ctrl + Z", history_mgr->undoable()))
                                        history_mgr->undo();
        
                                    if (MenuItemShortcutEnabled("重做", "Ctrl + Y", history_mgr->redoable()))
                                        history_mgr->redo();

                                    if (MenuItem("重置为原始状态"))
                                        history_mgr->reset();


                                    Separator();
                                    if (BeginMenu("从……复制"))
                                    {
                                        for (let _, (opassid, otexture, path) : images)
                                        {
                                            if (MenuItemEnabled(F"通道{opassid}：{path->valor("<内置>")}", passid != opassid))
                                            {
                                                jeapi::gui::form::ask("是否确认", "将覆盖当前通道纹理，操作不可撤销，是否继续？",
                                                    func(ok)
                                                    {
                                                        if (ok)
                                                        {
                                                            let new_tex = create_and_copy_texture(otexture);
                                                            images[index][1] = new_tex;
                                                            draw_context->update_edit_textures_history(passid, texture, new_tex);
                                                        }
                                                    });
                                            }
                                        }
                                        EndMenu();
                                    }
                                    Separator();
                                    if (BeginMenu("自定义效果"))
                                    {
                                        let scripts = get_all_scripts_name();
                                        if (scripts->empty)
                                            do MenuItemEnabled("<无>", false);

                                        for (let _, name: scripts)
                                        {
                                            if (MenuItem(name))
                                            {
                                                if (false == apply_script(name, texture))
                                                    jeapi::gui::form::errmsg("失败", "图像处理过程报告了一个错误");
                                                else
                                                    history_mgr->save_step();
                                            }
                                        }

                                        Separator();
                                        if (MenuItem("重新获取脚本"))
                                        {
                                            update_and_get_scripts(context->get_project);
                                        }
                                        if (MenuItem("脚本编辑器..."))
                                        {
                                            let DEFAULT_SCRIPT_SRC = 
@"// 图像处理脚本
import je::editor::graphic;

NAME = "自定义图像脚本";

public func entry(_: je::graphic::texture)
{
    return true;
}

public func pixel(t: je::graphic::texture, x: int, y: int)
    => (real, real, real, real)
{
    let (r, g, b, a) = tex(t, x, y);
    return (r, g ,b ,a);
}
"@;
                                            new! ScriptEditor(context, DEFAULT_SCRIPT_SRC, "图像效果", false)
                                                ->set_callback(func(vmm)
                                                {
                                                    let result = vmm->invoke("main", [texture: dynamic]);
                                                    history_mgr->save_step();

                                                    return result;
                                                });
                                        }
                                        EndMenu();
                                    }
                                    EndMenu();
                                }
                                EndMenuBar();
                            }
                            // OK 在这里显示一下绘图工具箱
                            BeginGroup();
                            
                            if (ColorButton("##main_color", draw_context.maincolor) )
                                OpenPopup("MainColorPicker");
                            SameLine();
                            if (ColorButton("##sub_color", draw_context.subcolor) )
                                OpenPopup("SubColorPicker");

                            let mut enable_draw = !input::keydown(keycode::L_CTRL);
                            if (BeginPopup("MainColorPicker"))
                            {
                                enable_draw = false;
                                do ColorPicker4("##main_color_picker", draw_context.maincolor)
                                    ->> \c = draw_context.maincolor = c;;
                                EndPopup();
                            }
                            if (BeginPopup("SubColorPicker"))
                            {
                                enable_draw = false;
                                do ColorPicker4("##sub_color_picker", draw_context.subcolor)
                                    ->> \c = draw_context.subcolor = c;;
                                EndPopup();
                            }

                            Text(F"当前工具: \n {draw_context.drawtoolname}");
                            for (let _, (name, tool_create_method) : all_draw_tools)
                            {
                                if (ButtonSize(name, (100., 0.)))
                                {
                                    draw_context.drawtool = tool_create_method();
                                    draw_context.drawtoolname = name;
                                }
                            }
                            EndGroup();

                            SameLine();

                            let (tex_width, tex_height) = texture->size;
                            let drawlist = GetWindowDrawList();

                            let (avaliw, avalih) = GetContentRegionAvail();

                            do InvisibleButton("##draw_space", (avaliw <= 100. ? 100. | avaliw, avalih <= 100. ? 100. | avalih));
                            if (IsItemActive() || IsItemHovered())
                            {
                                if (input::keydown(keycode::L_CTRL) 
                                    && IsMouseDragging(ImGuiMouseButton::ImGuiMouseButton_Left))
                                {
                                    let (mousedelta_x, mousedelta_y) = GetMouseDeltaPos();
                                    draw_context.offset_x += mousedelta_x;
                                    draw_context.offset_y += mousedelta_y;
                                }
                                draw_context.scale += _delta_wheel();

                                if (draw_context.scale < 1.)
                                    draw_context.scale = 1.;
                            }
                            else if (!draw_context.mousedown)
                                enable_draw = false;

                            let (p0, p1) = GetItemRect();
                            let (lux, luy) = p0;

                            PushClipRect(p0, p1);
                            drawlist->AddRectFilled(p0, p1, (75, 75, 75, 255));
                            drawlist->AddImage(
                                (lux + draw_context.offset_x, luy + draw_context.offset_y), 
                                (lux + draw_context.scale * tex_width:real + draw_context.offset_x, 
                                luy + draw_context.scale * tex_height:real + draw_context.offset_y), 
                                texture,
                                (255, 255, 255, 255));
                                
                            // OK 如果缩放大于5，就顺手画一下网格
                            if (draw_context.scale >= 5.)
                            {
                                for (let mut yoffset = 0.; yoffset <= tex_height:real * draw_context.scale; yoffset += draw_context.scale)
                                    drawlist->AddLine(
                                        (lux + draw_context.offset_x, luy + draw_context.offset_y + yoffset), 
                                        (lux + draw_context.offset_x + tex_width:real * draw_context.scale, luy + draw_context.offset_y + yoffset), 
                                        (0, 0, 0, 20),
                                        1.0);
                                for (let mut xoffset = 0.; xoffset <= tex_width:real * draw_context.scale; xoffset += draw_context.scale)
                                    drawlist->AddLine(
                                        (lux + draw_context.offset_x + xoffset, luy + draw_context.offset_y), 
                                        (lux + draw_context.offset_x + xoffset, luy + draw_context.offset_y + tex_height:real * draw_context.scale), 
                                        (0, 0, 0, 20),
                                        1.0);
                            }

                            // 获取鼠标所在的像素位置，高亮这一块儿
                            let (mposx, mposy) = GetMousePos();
                            let mpixx = ((mposx - lux - draw_context.offset_x) / draw_context.scale): int: real;
                            let mpixy = ((mposy - luy - draw_context.offset_y) / draw_context.scale): int: real;

                            if (mpixx >= 0. && mpixx < tex_width:real && mpixy >= 0. && mpixy < tex_height:real)
                            {
                                // Ok 鼠标指向的像素位置是合法的，高亮！
                                let highlight_p0 = (mpixx * draw_context.scale + draw_context.offset_x + lux, mpixy * draw_context.scale + draw_context.offset_y + luy);
                                let highlight_p1 = ((mpixx + 1.) * draw_context.scale + draw_context.offset_x + lux, (mpixy + 1.) * draw_context.scale + draw_context.offset_y + luy);
                                drawlist->AddRectFilled(highlight_p0, highlight_p1, (255, 255, 255, 100));
                            }

                            // 不过需要注意的是，引擎使用的像素坐标原点不是左上角，而是左下角，所以这里需要做一次简单变换
                            let mepixx = mpixx: int;
                            let mepixy = tex_height - 1 - mpixy: int;

                            if (input::mousedown(0, mousecode::MID)
                                && mepixx >= 0 && mepixx < tex_width
                                && mepixy >= 0 && mepixy < tex_height)
                                draw_context.maincolor = texture->pix((mepixx, mepixy))->get_color;

                            // 对接绘制工具，针对鼠标刚刚点下、按住、和松开分别回调
                            if (enable_draw)
                            {
                                let mut first_click = false;
                                if (draw_context.mousedown == false)
                                {
                                    first_click = true;
                                    if (input::mousedown(0, mousecode::LEFT))
                                        draw_context.usecolor = draw_context.maincolor;
                                    else if (input::mousedown(0, mousecode::RIGHT))
                                        draw_context.usecolor = draw_context.subcolor;
                                    else
                                        first_click = false;
                                }
                                if (input::mousedown(0, mousecode::LEFT) || input::mousedown(0, mousecode::RIGHT))
                                {
                                    draw_context.mousedown = true;
                                    if (first_click)
                                        draw_context.drawtool->OnMouseDown(texture, draw_context.usecolor, (mepixx, mepixy));
                                    else
                                        draw_context.drawtool->OnMouseHold(texture, draw_context.usecolor, (mepixx, mepixy));
                                }
                                else
                                {
                                    if (draw_context.mousedown)
                                    {
                                        draw_context.drawtool->OnMouseUp(texture, draw_context.usecolor, (mepixx, mepixy));
                                        history_mgr->save_step();
                                    }
                                    draw_context.mousedown = false;
                                }
                            }

                            PopClipRect();
                            EndTabItem();
                        }
                    }
                    EndTabBar();
                }
            }
        none?
            open = false;
        }
        End();

        if (!open)
        {
            let saving_image_action = []mut: vec<()=> void>;

            // 遍历所有被编辑过的图片，直接保存！
            for (let _, (passid, edited_texture, path) : images)
            {
                if (!draw_context.edited_textures[edited_texture][1]->edited)
                    continue;
                
                // 生成文件名，如果已经有了就有，没有就死！
                let projpath = context->get_project().m_path;
                let saving_path = path
                    ->> \p = fsys::normalize(p);
                    ->  or(func()
                        {
                            let genuidpath = \ = projpath/"resource"/"texture"/F"{je::uid()}.png";;
                            let mut name = genuidpath();
                            for (; fsys::exist(name); name = genuidpath())
                                ;
                            return name;
                        }
                        )
                    ->  \path = (fsys::extension(path)->lower == ".png" 
                        ? path 
                        | fsys::parent(path)/F"{fsys::purename(path)}.png")->tostring
                        ;
                ;
                
                saving_image_action->add(func()
                    {
                        if (save_texture_to_path(context, edited_texture, saving_path))
                        {
                            do entity
                                ->> \eid = eid->justdo(
                                        \e = e->bind_texture(passid, je::graphic::texture::load(
                                            context->get_project->get_env->get_universe->option::value, 
                                            // NOTE: saving_path是一个可能为规范路径 也有可能是项目路径的东西，这里直接简单处理了
                                            //       照理来说应该区分出类型再分别处理
                                            context->get_project->make_path_normalize(fsys::normalize(saving_path)))->val);
                                    )
                                    ;
                                ;
                        }
                    });
                
            }

            draw_context.openform = false;
            if (! saving_image_action->empty)
            {
                draw_context.openform = true;
                jeapi::gui::form::ask("是否保存", "是否保存绘制的图片",
                func(ok)
                {
                    draw_context.openform = false;
                    if (!ok)
                    {
                        // 不保存，但是因为共享纹理机制，需要把纹理reset回原始状态
                        for (let _, (_, history) : draw_context.edited_textures)
                        {
                            history->reset();
                        }
                        return;
                    }
                        
                    for (let _, act : saving_image_action)
                        act();
                });
            }
        }
        return draw_context.openform;
    }

    func create_and_copy_texture(t: je::graphic::texture)
    {
        let (w, h) = t->size();
        let nt = new! je::graphic::texture(w, h);
        for (let mut x = 0; x < w; x += 1)
        {
            for (let mut y = 0; y < h; y += 1)
            {
                nt->pix((x, y))->set_color(
                    t->pix((x, y))->get_color()
                );
            }
        }
        return nt;
    }
    public func drawimg(context: EditorContext, t: graphic::texture)
    {
        launch(edittexture, (
            context,
            option::none,
            [(0, mut t, mut t->path)],
            DrawContextT{
                scale = mut 10.,
                offset_x = mut 0.,
                offset_y = mut 0.,
                drawtool = mut all_draw_tools[0][1](),
                drawtoolname = mut all_draw_tools[0][0],

                mousedown = mut false,

                usecolor = mut (1., 1., 1., 1.),
                maincolor = mut (1., 1., 1., 1.),
                subcolor = mut (0., 0., 0., 0.),

                edited_textures = {[t] = (0, new! HistoryManager(t))}mut,
                openform = mut true,
            }
        ));
    }
    public func drawedit(context: EditorContext, e: entity)
    {
        // 检查实体有没有纹理组件，然后遍历检查所有纹理是否都存在，有没有没有路径的问题
        // 如果发现不正常的纹理就给个提示
        if (!e->get_component(typeinfo::load("Renderer::Textures")->val)->has)
        {
            jeapi::gui::form::errmsg("无法绘制当前实体", "当前实体不包含 Renderer::Textures 组件，无法绘制");
            return;
        }

        let textures = e->get_textures();

        // 这个大大的傻逼代码作用是获取当前实体使用的所有纹理通道
        let used_texture_id_pass = e->get_shaders()
            =>> \shader = shader->get_uniforms()
                    ->  unmapping
                    =>> \nv = nv...
                        ->  func(name, uniformval)
                            {
                                if (!name->beginwith("JOYENGINE_"))
                                {
                                    match (uniformval)
                                    {
                                    texture(id)?
                                        return [id];
                                    _?;
                                    }
                                }
                                return [];
                            }
                        ;
                ;
            ->> \id = (id, nil);
            ->  mapping
            ->  unmapping // remove all repeated elems.
            ->> \idn = idn[0];
        ;

        if (used_texture_id_pass->empty)
        {
            jeapi::gui::form::errmsg("无法绘制当前实体", "当前实体不使用任何纹理，因此无法编辑");
            return;
        }

        let (size_x, size_y, _) = e->get_component(typeinfo::load("Transform::LocalScale")->val)
            =>> \c = c->get_member("scale");
            ->> \m = m[1]->float3;
            ->  valor((1., 1., 1.))
            ;

        let create_and_copy_0pass_texture = func()
        {
            match (textures->get(0))
            {
            value(t)? return create_and_copy_texture(t);
            none? return new! je::graphic::texture(math::round(16. * size_x), math::round(16. * size_y));
            }
        };

        let id_tex_list = used_texture_id_pass 
            ->> \id = (id, mut tex, mut tex->path)
                where tex = textures->get(id)-> or(\= create_and_copy_0pass_texture();)
                ;
            ;
        launch(edittexture, (
            context,
            option::value(jeapi::debug::get_entity_editor_id(e)),
            id_tex_list,
            DrawContextT{
                scale = mut 10.,
                offset_x = mut 0.,
                offset_y = mut 0.,
                drawtool = mut all_draw_tools[0][1](),
                drawtoolname = mut all_draw_tools[0][0],

                mousedown = mut false,

                usecolor = mut (1., 1., 1., 1.),
                maincolor = mut (1., 1., 1., 1.),
                subcolor = mut (0., 0., 0., 0.),

                edited_textures = id_tex_list
                    ->> \id_text = (id_text[1], (id_text[0], new! HistoryManager(id_text[1])));
                    ->  mapping
                    ->  tomap
                    ,
                openform = mut true,
            }
        ));
    }
}

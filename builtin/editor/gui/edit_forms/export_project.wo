using je::gui;

namespace editor::gui::edit_forms
{
    union Action
    {
        SKIP,       // 跳过此文件
        ORIGIN,     // 原样复制到打包路径
        PACK,       // 打包
        ACTION((pack_config, je::editor::fimage_packer)=>array<(string, string)>),
    }
    using pack_config = struct {
        m_pack_dll_into_image: bool,        // 将C++模块打包进镜像文件中？如果为true，则在运行时释放出动态库，否则原样复制
        m_image_size: int,
        m_start_up_worlds: array<string>,
        m_rule: (fsys::path_t, string)=> Action,
        m_resolution: (int, int),

        m_pack_output_log: vec<string>,
        m_finished: mut bool,
    };

    func _default_rule(originpath: fsys::path_t, packpath: string)=> Action
    {
        // 如果是文件，才考虑打包
        if (fsys::isfile(originpath))
        {
            if (fsys::extension(originpath)->lower == ".jeproj4")
                return Action::SKIP;  // 跳过项目文件

            if (fsys::extension(originpath)->lower == ".jewo")
                return Action::SKIP;  // 跳过工具脚本
                
            if (fsys::extension(originpath)->lower == ".dmp")
                return Action::SKIP;  // 跳过崩溃转储文件

            if (fsys::extension(originpath)->lower == ".jetilemap4")
                return Action::SKIP;  // 跳过tilemap文件

            if (fsys::extension(originpath)->lower == ".jetileset4")
                return Action::SKIP;  // 跳过tileset文件
            
            if (fsys::extension(originpath)->lower == ".dmp")
                return Action::SKIP;  // 跳过崩溃转储文件

            if (fsys::extension(originpath)->lower == ".shader")
                return Action::ACTION(func(pconfig, _){
                    pconfig.m_pack_output_log->add(F"正在编译着色器：{packpath}");
                    match (je::graphic::shader::load(originpath->tostring))
                    {
                    value(_)?
                        return [(originpath->tostring + ".jecache4", packpath + ".jecache4")];
                    none?
                        {
                            pconfig.m_pack_output_log->add(F"无法编译着色器，跳过：{packpath}");
                            return [];
                        }
                    }
                });
            
            if (fsys::extension(originpath)->lower == ".wo")
                return Action::ACTION(func(pconfig, fimg){
                    pconfig.m_pack_output_log->add(F"正在编译脚本：{packpath}");
                    match (vm::load(originpath->tostring))
                    {
                    ok(vminstance)?
                        {
                            assert(
                                vminstance->save_binary(false)...
                                    -> \bindata, binlen = fimg->pack_buffer(bindata->ptr, binlen, packpath);
                            );
                            return [];
                        }
                    err(_)?
                        {
                            pconfig.m_pack_output_log->add(F"无法编译脚本，原样传输：{packpath}");
                            return [(originpath->tostring, packpath)];
                        }
                        
                    }
                    
                });

            if (packpath->lower->find(".jemodule4/") != -1)
                return Action::SKIP;  // 跳过C++工程文件

            if (packpath->lower->find("/.runtime/") != -1)
                return Action::SKIP;  // 跳过缓存文件

            if (packpath->lower->find("/.temporary/") != -1)
                return Action::SKIP;  // 跳过临时文件
            
            if (packpath->lower->find("/.git/") != -1)
                return Action::SKIP;  // 跳过git文件

            return Action::PACK;
        }

        return Action::SKIP;
    }
    func _export_logic(proj: Project, config: pack_config)
    {
        config.m_pack_output_log->add("开始打包……");

        let normalized_path = proj.m_path;
 
        // 1. 删掉 .export 目录下的内容
        config.m_pack_output_log->add("正在删除 .export 目录");
        do fsys::remove(normalized_path/".export")->unwarp;

        // 2. 遍历所有目录，记录下所有文件的原始路径和最终路径
        match (fsys::allsubpath(normalized_path))
        {
        ok(subpaths)?
            {
                config.m_pack_output_log->add("开始整理打包文件……");
                let bind_wrap_path = func(subpath: fsys::path_t){
                    return (subpath, proj->make_path_normalize(subpath));
                };
                let all_need_pack_files = subpaths
                    ->> bind_wrap_path
                    =>> func(paths)
                    {
                        let (subpath, packpath) = paths;
                        let action = config.m_rule(subpath, packpath);

                        return [(subpath, (packpath, action))];
                    }
                    ->  mapping;

                
                // 0. 重新编译所有C++项目，只编译到输出目录中
                // P.S. 这个序号真牛逼，人家都是1 2 3，这里是1 2 0 哈哈哈
                do new! thread(func()
                    {
                        config.m_pack_output_log->add("正在编译模块");
                        let compile_results = proj->get_all_modules->>\k, v = (k, (v, v->compile(je::platform(), option::none)));;
                        let error_compiling = compile_results->forall(\_, r = r[1]->iserr;);
                        if (error_compiling->empty == false)
                        {
                            // 有编译失败，跳过！
                            for (let name, _ : error_compiling)
                            {
                                config.m_pack_output_log->add(F"模块 {name} 编译失败");
                            }
                            config.m_pack_output_log->add("注意：一个或多个模块编译失败，打包终止");
                            config.m_finished = true;
                            return;
                        }
                        else
                        {
                            // 1. 开始正式打包！
                            // 1.1 将生成的C++模块打入包内，并记录文件列表
                            let dll_module_path = compile_results
                                ->  unmapping
                                ->> \kv = (kv[1][0], bind_wrap_path(kv[1][0]->get_build_dll_path(je::platform())->val)); // 必须有
                                ;

                            // 1.2 创建路径，准备打包
                            let export_path = normalized_path/".export";
                            do fsys::mkdir(export_path);
                            let fimg = new! je::editor::fimage_packer(export_path->tostring, config.m_image_size * 1024 * 1024);
     
                            let copy_origin = func(opath: fsys::path_t, ppath: string)
                            {
                                assert(ppath[0] == '@');
                                let target_ppath = export_path / ppath->sub(1);
                                let parent_target_ppath = fsys::parent(target_ppath);
                                do fsys::mkdir(parent_target_ppath);
                                return fsys::copy(opath, target_ppath);
                            };

                            // 1.3 开始打包
                            do fsys::mkdir(export_path/"builtin");
                            do fsys::writeall(export_path/"builtin"/".keepme", "");

                            for (let _, (_, (opath, ppath)) : dll_module_path)
                            {
                                config.m_pack_output_log->add(F"复制 {ppath}");

                                // assert(fimg->pack(opath, ppath));
                                do copy_origin(opath, ppath)->unwarp;
                            }

                            for (let opath, (ppath, method) : all_need_pack_files)
                            {
                                match (method)
                                {
                                PACK?
                                    {
                                        config.m_pack_output_log->add(F"打包 {ppath}");
                                        assert(fimg->pack(opath->tostring, ppath));
                                    }
                                ORIGIN?
                                    {
                                        config.m_pack_output_log->add(F"复制 {ppath}");
                                        do copy_origin(opath, ppath)->unwarp;
                                    }
                                ACTION(action)?
                                    {
                                        for (let _, (aopath, appath): action(config, fimg))
                                        {
                                            config.m_pack_output_log->add(F"打包 {appath}");
                                            assert(fimg->pack(aopath, appath));
                                        }
                                    }
                                SKIP?
                                    config.m_pack_output_log->add(F"跳过 {ppath}");
                                }
                            }

                            // 1.4 将引擎本体移动至打包目录
                            config.m_pack_output_log->add(F"正在复制引擎运行时");
                            do fsys::copy(fsys::normalize(std::args()[0]), export_path/F"{proj.m_name}.exe")->unwarp;

                            if (fsys::isfile(fsys::workpath() / "icon.ico"))
                            {
                                do new! process(F"{std::exepath()}/builtin/rcedit-x64.exe", 
                                    [
                                        F"{std::exepath()}/builtin/rcedit-x64.exe",
                                        (export_path / F"{proj.m_name}.exe")->tostring, 
                                        "--set-icon", 
                                        (fsys::workpath() / "icon.ico")->tostring,
                                    ])
                                    ->> \proc = proc->wait;
                                    ;
                            }

                            do CxxProject::get_lib_files_by_config(je::platform())
                                ->> \lf = lf->get_dynamic_libs
                                        ->> \libpath = do fsys::copy(fsys::normalize(F"{std::exepath()}/{libpath}"), export_path / libpath)->unwarp;
                                    ;
                                ;
                            do fsys::copy(fsys::normalize(F"{std::exepath()}/OpenAL32.dll"), export_path / "OpenAL32.dll")->unwarp;
                            
                            // 1.5 将启动脚本编译后打入镜像
                            config.m_pack_output_log->add(F"正在打包启动脚本");
                            let boot_up_script = @"
                                import je;
                                import je::gui;
                                import je::editor;
                                import woo::std;
                                import builtin::api::serialize::main;
                                import builtin::editor::gui::form::panic;

                                je::editor::set_able_shared_glresource(true);
                                je::editor::register_panic_hook(jeapi::gui::form::panic);

                                let LOADED_WORLDS_MAPPING = {}mut: map<string, je::world>;
                                func LOAD_WORLD(path: string)
                                {
                                    let world_dat = je::file::readall(path)
                                        =>> \dat = dict::deserialize(dat);
                                        ->  val
                                        ->> \k, v = (k as string, v);
                                        ;
                                    
                                    LOADED_WORLDS_MAPPING->set(path, jeapi::deserialize::world(RUNTIME_UNIVERSE, world_dat, false));
                                }

                                let LOADED_MODULE_HANDLES = []mut: vec<handle>;
                                let LOADED_TOWOO_SYSTEM_TYPES = []mut: vec<je::typeinfo>;
                                let LOADED_TOWOO_COMPONENT_TYPES = []mut: vec<je::typeinfo>;

                                // 在此处加载模块
                                $LOAD_DYLIB_MODULES$

                                // 在此处加载ToWoo组件
                                $LOAD_TOWOO_COMPONENT$

                                je::towoo::update_api();

                                // 在此处加载ToWoo系统
                                $LOAD_TOWOO_SCRIPTS$

                                // 在此设置分辨率
                                $APPLY_RESOLUTION$

                                // 在此设置窗口标题
                                $APPLY_TITLE$
                                
                                // 启动Universe，在Universe中加载世界
                                let RUNTIME_UNIVERSE = je::universe::create();
                               
                                // 在此处应用项目设置
                                $APPLY_PROJECT_CONFIG$

                                // 在此处加载世界实例
                                $LOAD_WORLD_INSTANCE$

                                // 在此调用运行时脚本（如果有）
                                $IMPORT_RUNTIME_SCRIPT_MAY_NOT_EXIST$

                                RUNTIME_UNIVERSE->wait();

                                for (let _, tinfo: LOADED_TOWOO_SYSTEM_TYPES)
                                    je::towoo::unregister_system(tinfo);

                                for (let _, tinfo: LOADED_TOWOO_COMPONENT_TYPES)
                                    je::towoo::unregister_component(tinfo);

                                for (let _, libhandle : LOADED_MODULE_HANDLES)
                                    je::delay_unload_module(libhandle);
                                
                            "@;

                            // 1.5.1 生成加载动态库相关代码
                            config.m_pack_output_log->add(F"正在生成装载动态库的脚本");
                            let mut dylib_loader = "";
                            for (let _, (minstance, (_, ppath)) : dll_module_path)
                            {
                                // TODO: 根据情况，从镜像文件中释出相关文件
                                assert(ppath[0] == '@');

                                let runtime_loading_code = 
                                    "LOADED_MODULE_HANDLES->add(" 
                                    + "je::load_module($MODULENAME$, std::exepath() + $MODULERPATH$)->val"
                                    + ");";

                                dylib_loader +=
                                    runtime_loading_code
                                        ->replace("$MODULENAME$", minstance.name->enstring)
                                        ->replace("$MODULERPATH$", ppath->sub(1)->enstring)
                                    + "\n";
                            }

                            // 1.5.2 加载ToWoo类型
                            let loading_towoo_components = proj->get_all_towoo_scripts_name_and_path
                                ->  forall(\_, paths = fsys::filename(paths[0])->lower->endwith(".jecomponent.wo");)
                                ->  unmapping
                                ->> \pathnameandpath = F"LOADED_TOWOO_COMPONENT_TYPES->add(je::towoo::update_component({
                                        name->enstring}, {path->enstring})->val);\n"
                                        where (name, (_, path)) = pathnameandpath
                                    ;
                                ->  reduce(\l, r = l + r;)
                                ->  valor("");
                            let loading_towoo_systems = proj->get_all_towoo_scripts_name_and_path
                                ->  forall(\_, paths = fsys::filename(paths[0])->lower->endwith(".jesystem.wo");)
                                ->  unmapping
                                ->> \pathnameandpath = F"LOADED_TOWOO_SYSTEM_TYPES->add(je::towoo::update_system({
                                        name->enstring}, {path->enstring})->val);\n"
                                        where (name, (_, path)) = pathnameandpath
                                    ;
                                ->  reduce(\l, r = l + r;)
                                ->  valor("");

                            // 1.5.3 应用项目设置
                            config.m_pack_output_log->add(F"正在生成应用项目设置的脚本");
                            let mut proj_config = "";
                            for (let _, pconfig : proj->get_configs)
                            {
                                proj_config += pconfig->apply + "\n";
                            }

                            // 1.5.4 加载和序列化世界
                            config.m_pack_output_log->add(F"正在生成加载世界的脚本");
                            let mut load_world_instance = "";
                            for (let _, startup_world_path : config.m_start_up_worlds)
                            {
                                load_world_instance += F"LOAD_WORLD({startup_world_path->enstring});\n";
                            }
  
                            // 1.5.5 加载入口脚本
                            let load_entry_script = "";

                            let final_boot_script = boot_up_script
                                ->replace("$LOAD_DYLIB_MODULES$", dylib_loader)
                                ->replace("$LOAD_TOWOO_COMPONENT$", loading_towoo_components)
                                ->replace("$LOAD_TOWOO_SCRIPTS$", loading_towoo_systems)
                                ->replace("$APPLY_PROJECT_CONFIG$", proj_config)
                                ->replace("$LOAD_WORLD_INSTANCE$", load_world_instance)
                                ->replace("$IMPORT_RUNTIME_SCRIPT_MAY_NOT_EXIST$", load_entry_script)
                                ->replace("$APPLY_RESOLUTION$", F"je::editor::set_window_size({config.m_resolution[0]}, {config.m_resolution[1]});")
                                ->replace("$APPLY_TITLE$", F"je::editor::set_window_title({proj.m_name->enstring});");

                            let (start_up_script_binary, start_up_script_binary_sz) = 
                                new! vm("@/builtin/main.wo", final_boot_script)->unwarp->save_binary(false);

                            assert(fimg->pack_buffer(start_up_script_binary->ptr, start_up_script_binary_sz, "@/builtin/main.wo"));

                            // 2. 结束，保存镜像
                            fimg->finish();

                            config.m_pack_output_log->add("打包完成");

                            config.m_finished = true;
                        }
                    }, ());
                return ok(do nil);
            }
        err(errdat)?
            return err(errdat);
        }
    }
    public func show_export_project(context: EditorContext)
    {
        let all_project_files = fsys::allsubpath(context->get_project.m_path)->unwarp;
        let selecting_all_worlds_file = all_project_files
            ->  forall(\p = fsys::extension(p)->lower == ".jeworld";)
            ->> \p = (context->get_project->make_path_normalize(p), mut false);
            ;
            
        let pack_image_file_size = new! mutable(128);
        let reso_option_index = new! mutable(1);
        let reso_config = new! mutable((1366, 768));
        let pack_config_instance = new! mutable(option::none: option<pack_config>);

        context->launch_editor_form(func(step: mutable<int>){
            let mut open = true;
            if (BeginAttr("项目导出向导", WindowsAttribute::ImGuiWindowFlags_AlwaysAutoResize))
            {                
                let (cur_width, _) = GetContentRegionAvail();

                let current_step_count = step->get;
                if (current_step_count == 0)
                {
                    TextDisabled("即将开始……");
                    Separator();

                    do BeginChildSize("SUBFORM.", 500., 300.);

                    Text("欢迎使用JoyEngineECS 项目导出向导");
                    Text("向导将引导您完成接下来一系列的配置操作");
                    Text("注意：导出操作将删除项目目录下的 .export 目录中的全部内容");
                    
                    EndChild();
                    
                    if (ButtonSize("我已确认准备就绪，继续下一步", (cur_width, 0.)))
                        step->set(current_step_count + 1);
                    if (ButtonSize("取消导出", (cur_width, 0.)))
                        open = false;
                }
                if (current_step_count == 1)
                {
                    TextDisabled("第一步 选择启动时加载的世界");
                    Separator();

                    do BeginChildSize("SUBFORM.", 500., 300.);

                    Text("请在下方勾选导出项目启动时，需要自动加载的世界");

                    do BeginChild("SUBFORM.2");
                    do selecting_all_worlds_file
                        ->> \path_and_checked = do CheckBox(path_and_checked...)
                                ->> \opt = path_and_checked[1] = opt;
                            ;
                        ;
                    EndChild();
                    EndChild();
                    
                    if (ButtonSize("下一步", (cur_width, 0.)))
                        step->set(current_step_count + 1);
                    if (ButtonSize("上一步", (cur_width, 0.)))
                        step->set(current_step_count - 1);
                }
                if (current_step_count == 2)
                {
                    TextDisabled("第二步 导出画面设置");
                    Separator();

                    do BeginChildSize("SUBFORM.", 500., 300.);

                    Text("请选择启动时默认渲染的画面分辨率");
                    Text("* 默认为 1366x768");

                    let static reso_list = [
                        ("1280x720 [16:9]", (1280, 720)),
                        ("1366x768 [16:9]", (1366, 768)),
                        ("1920x1080 [16:9]", (1920, 1080)),
                        ("2560x1440 [16:9]", (2560, 1440)),
                        ("3840x2160 [16:9]", (3840, 2160)),

                        ("800x600 [4:3]", (800, 600)),
                        ("1024x768 [4:3]", (1024, 768)),
                        ("1400x1050 [4:3]", (1400, 1050)),
                        ("1920x1440 [4:3]", (1920, 1440)),
                    ];

                    do Combo("##RESO_LIST.", reso_list->>\RR = RR[0];, reso_option_index->get)
                        ->> func(idx)
                            {
                                reso_option_index->set(idx);
                                reso_config->set(reso_list[idx][1]);
                            }
                        ;

                    EndChild();
                    
                    if (ButtonSize("下一步", (cur_width, 0.)))
                        step->set(current_step_count + 1);
                    if (ButtonSize("上一步", (cur_width, 0.)))
                        step->set(current_step_count - 1);
                }
                if (current_step_count == 3)
                {
                    TextDisabled("第三步 导出镜像设置");
                    Separator();

                    do BeginChildSize("SUBFORM.", 500., 300.);
                    Text("请为打包镜像设置分包大小，单位为MB");
                    Text("* 默认为 128MB");
                    
                    do InputInt("##IMAGESZ.", pack_image_file_size->get)
                        ->> func(n)
                            {
                                if (n > 0)
                                    pack_image_file_size->set(n);
                            }
                        ;

                    EndChild();
                    
                    if (ButtonSize("下一步", (cur_width, 0.)))
                        step->set(current_step_count + 1);
                    if (ButtonSize("上一步", (cur_width, 0.)))
                        step->set(current_step_count - 1);
                }
                if (current_step_count == 4)
                {
                    TextDisabled("导出操作确认");
                    Separator();

                    do BeginChildSize("SUBFORM.", 500., 300.);
                    Text("打包导出的全部配置已经准备就绪");
                    Text("按下确认开始打包");

                    Separator();
                    Text("* 请再次确认 .export 目录是否有文件尚未备份！");
                    
                    EndChild();
                    
                    if (ButtonSize("开始打包", (cur_width, 0.)))
                    {
                        let conf = pack_config{
                            m_pack_dll_into_image = false,
                            m_image_size = pack_image_file_size->get,
                            m_start_up_worlds = selecting_all_worlds_file
                                ->  forall(\path_and_checked = path_and_checked[1];)
                                ->> \path_and_checked = path_and_checked[0];,
                            m_rule = _default_rule,
                            m_resolution = reso_config->get,

                            m_pack_output_log = []mut,
                            m_finished = mut false,
                        };
                        do _export_logic(context->get_project, conf)->unwarp;
                        pack_config_instance->set(option::value(conf));
                        step->set(current_step_count + 1);
                    }
                    if (ButtonSize("上一步", (cur_width, 0.)))
                        step->set(current_step_count - 1);
                }
                if (current_step_count == 5)
                {
                    TextDisabled("正在导出……");
                    Separator();

                    do BeginChildSize("SUBFORM.", 500., 300.);
                    
                    let (avail_width, avail_height) = GetContentRegionAvail();
                    if (BeginListBox("##", avail_width, avail_height))
                    {
                        let logs = pack_config_instance->get->val.m_pack_output_log;
                        for (let mut index = logs->len; index > 0; index -= 1)
                            do Selectable(logs[index - 1]);

                        EndListBox();
                    }
                    
                    EndChild();
                    
                    if (pack_config_instance->get->val.m_finished)
                    {
                        if (ButtonSize("完成", (cur_width, 0.)))
                            open = false;
                    }

                }
            }
            End();
            return open;
        }, (new! mutable(0),));
    }
}

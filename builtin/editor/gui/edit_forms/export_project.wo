using je::gui;

namespace editor::gui::edit_forms
{
    enum Action
    {
        SKIP,       // 跳过此文件
        ORIGIN,     // 原样复制到打包路径
        PACK,       // 打包
    }
    using pack_config = struct {
        m_pack_dll_into_image: bool,        // 将C++模块打包进镜像文件中？如果为true，则在运行时释放出动态库，否则原样复制
    };
    func _default_rule(originpath: string, packpath: string)=> Action
    {
        // 如果是文件，才考虑打包
        if (filesys::isfile(originpath))
        {
            if (filesys::extension(originpath)->lower == ".jeproj4")
                return Action::SKIP;  // 跳过项目文件

            if (packpath->lower->find(".jemodule4") != -1)
                return Action::SKIP;  // 跳过C++工程文件

            return Action::PACK;
        }

        return Action::SKIP;
    }
    func _export_logic(proj: Project, rule: (string, string)=> Action)
    {
        let normalized_path = filesys::normalize(proj.m_path);
        assert(!normalized_path->endwith("\\") && !normalized_path->endwith("/"));   
        // 1. 删掉 .export 目录下的内容
        do filesys::remove(F"{normalized_path}/.export");

        // 2. 遍历所有目录，记录下所有文件的原始路径和最终路径
        match (filesys::allsubpath(normalized_path))
        {
        ok(subpaths)?
            {
                let bind_wrap_path = func(subpath: string){
                    assert(subpath->beginwith(normalized_path));
                    return (subpath, subpath->sub(normalized_path->len)
                            ->  \s = s->beginwith("/") 
                                ? F"@{s}"
                                | s
                                ;
                            );
                };
                let all_need_pack_files = subpaths
                    ->> bind_wrap_path
                    =>> func(paths)
                    {
                        let (subpath, packpath) = paths;
                        let action = rule(subpath, packpath);
                        if (action != Action::SKIP)
                            return [(subpath, (packpath, action))];
                        else
                            return [];
                    }
                    ->  mapping;

                
                // 0. 重新编译所有C++项目，只编译到输出目录中
                // P.S. 这个序号真牛逼，人家都是1 2 3，这里是1 2 0 哈哈哈
                do thread::create(func()
                    {
                        let compile_results = proj->get_all_modules->>\k, v = (k, (v, v->compile(je::editor::platform(), option::none)));;
                        let error_compiling = compile_results->forall(\_, r = r[1]->iserr;);
                        if (error_compiling->empty == false)
                        {
                            // 有编译失败，跳过！
                            return;
                        }
                        else
                        {
                            // 1. 开始正式打包！
                            // 1.1 将生成的C++模块打入包内，并记录文件列表
                            let dll_module_path = compile_results
                                ->  unmapping
                                ->> \kv = bind_wrap_path(kv[1][0]->get_build_dll_path(je::editor::platform())->val); // 必须有
                                ;

                            // 1.2 创建路径，准备打包
                            let export_path = F"{normalized_path}/.export";
                            do filesys::mkdir(export_path);
                            let fimg = je::editor::fimage_packer::create(proj.m_path, export_path, 6660);
     
                            let copy_origin = func(opath: string, ppath: string)
                            {
                                assert(ppath[0] == '@');
                                let target_ppath = export_path + ppath->sub(1);
                                let parent_target_ppath = filesys::parent(target_ppath);
                                do filesys::mkdir(parent_target_ppath);
                                return filesys::copy(opath, target_ppath);
                            };

                            // 1.3 开始打包
                            for (let _, (opath, ppath) : dll_module_path)
                            {
                                // assert(fimg->pack(opath, ppath));
                                do copy_origin(opath, ppath)->unwarp;
                            }

                            for (let opath, (ppath, method) : all_need_pack_files)
                            {
                                if (method == Action::PACK)
                                    assert(fimg->pack(opath, ppath));
                                else
                                {
                                    assert(method == Action::ORIGIN);
                                    do copy_origin(opath, ppath)->unwarp;
                                }
                            }

                            // 1.4 将引擎本体移动至打包目录
                            filesys::copy(std::args[0], F"{export_path}/{proj.m_name}.exe");
                            filesys::copy()

                            // 1.5 将启动脚本编译后打入镜像

                            // 2. 结束，保存镜像
                            fimg->finish();
                            
                        }
                    }, ());

                
                return ok(do nil);
            }
        err(errdat)?
            return err(errdat);
        }
    }
    public func show_export_project(context: EditorContext)
    {
        context->launch_editor_form(func(){
            do Begin("导出项目-TESTING");
                if (Button("测试"))
                    do _export_logic(context->get_project, _default_rule);
            End();
            return true;
        }, ());
    }
}
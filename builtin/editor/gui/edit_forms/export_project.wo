using je::gui;

namespace editor::gui::edit_forms
{
    union Action
    {
        SKIP,       // 跳过此文件
        ORIGIN,     // 原样复制到打包路径
        PACK,       // 打包
        ACTION((pack_config)=>array<(string, string)>),
    }
    using pack_config = struct {
        m_pack_dll_into_image: bool,        // 将C++模块打包进镜像文件中？如果为true，则在运行时释放出动态库，否则原样复制
        m_image_size: int,
        m_start_up_worlds: array<string>,
        m_rend_world: option<string>,
        m_rule: (string, string)=> Action,
        m_resolution: (int, int),

        m_pack_output_log: vec<string>,
        m_finished: mut bool,
    };
    func _default_rule(originpath: string, packpath: string)=> Action
    {
        // 如果是文件，才考虑打包
        if (filesys::isfile(originpath))
        {
            if (filesys::extension(originpath)->lower == ".jeproj4")
                return Action::SKIP;  // 跳过项目文件

            if (filesys::extension(originpath)->lower == ".jewo")
                return Action::SKIP;  // 跳过工具脚本

            if (filesys::extension(originpath)->lower == ".shader")
                return Action::ACTION(func(pconfig){
                    pconfig.m_pack_output_log->add(F"正在编译着色器：{packpath}");
                    match (je::graphic::shader::load(originpath))
                    {
                    value(_)?
                        return [(originpath + ".jecache4", packpath + ".jecache4")];
                    none?
                        {
                            pconfig.m_pack_output_log->add(F"无法编译着色器，跳过：{packpath}");
                            return [];
                        }
                    }
                });

            if (packpath->lower->find(".jemodule4") != -1)
                return Action::SKIP;  // 跳过C++工程文件

            return Action::PACK;
        }

        return Action::SKIP;
    }
    func _export_logic(proj: Project, config: pack_config)
    {
        config.m_pack_output_log->add("开始打包……");

        let normalized_path = proj.m_path;
 
        // 1. 删掉 .export 目录下的内容
        config.m_pack_output_log->add("正在删除 .export 目录");
        do filesys::remove(F"{normalized_path}/.export")->unwarp;

        // 2. 遍历所有目录，记录下所有文件的原始路径和最终路径
        match (filesys::allsubpath(normalized_path))
        {
        ok(subpaths)?
            {
                config.m_pack_output_log->add("开始整理打包文件……");
                let bind_wrap_path = func(subpath: string){
                    return (subpath, proj->make_path_normalize(subpath));
                };
                let all_need_pack_files = subpaths
                    ->> bind_wrap_path
                    =>> func(paths)
                    {
                        let (subpath, packpath) = paths;
                        let action = config.m_rule(subpath, packpath);

                        return [(subpath, (packpath, action))];
                    }
                    ->  mapping;

                
                // 0. 重新编译所有C++项目，只编译到输出目录中
                // P.S. 这个序号真牛逼，人家都是1 2 3，这里是1 2 0 哈哈哈
                do thread::create(func()
                    {
                        config.m_pack_output_log->add("正在编译模块");
                        let compile_results = proj->get_all_modules->>\k, v = (k, (v, v->compile(je::editor::platform(), option::none)));;
                        let error_compiling = compile_results->forall(\_, r = r[1]->iserr;);
                        if (error_compiling->empty == false)
                        {
                            // 有编译失败，跳过！
                            for (let name, _ : error_compiling)
                            {
                                config.m_pack_output_log->add(F"模块 {name} 编译失败");
                            }
                            config.m_pack_output_log->add("注意：一个或多个模块编译失败，打包终止");
                            config.m_finished = true;
                            return;
                        }
                        else
                        {
                            // 1. 开始正式打包！
                            // 1.1 将生成的C++模块打入包内，并记录文件列表
                            let dll_module_path = compile_results
                                ->  unmapping
                                ->> \kv = (kv[1][0], bind_wrap_path(kv[1][0]->get_build_dll_path(je::editor::platform())->val)); // 必须有
                                ;

                            // 1.2 创建路径，准备打包
                            let export_path = F"{normalized_path}/.export";
                            do filesys::mkdir(export_path);
                            let fimg = je::editor::fimage_packer::create(proj.m_path, export_path, config.m_image_size * 1024 * 1024);
     
                            let copy_origin = func(opath: string, ppath: string)
                            {
                                assert(ppath[0] == '@');
                                let target_ppath = export_path + ppath->sub(1);
                                let parent_target_ppath = filesys::parent(target_ppath);
                                do filesys::mkdir(parent_target_ppath);
                                return filesys::copy(opath, target_ppath);
                            };

                            // 1.3 开始打包
                            do filesys::mkdir(F"{export_path}/builtin");
                            do filesys::writeall(F"{export_path}/builtin/.keepme", "");

                            for (let _, (minstance, (opath, ppath)) : dll_module_path)
                            {
                                config.m_pack_output_log->add(F"复制 {ppath}");

                                // assert(fimg->pack(opath, ppath));
                                do copy_origin(opath, ppath)->unwarp;
                            }

                            for (let opath, (ppath, method) : all_need_pack_files)
                            {
                                match (method)
                                {
                                PACK?
                                    {
                                        config.m_pack_output_log->add(F"打包 {ppath}");
                                        assert(fimg->pack(opath, ppath));
                                    }
                                ORIGIN?
                                    {
                                        config.m_pack_output_log->add(F"复制 {ppath}");
                                        do copy_origin(opath, ppath)->unwarp;
                                    }
                                ACTION(action)?
                                    {
                                        for (let _, (aopath, appath): action(config))
                                        {
                                            config.m_pack_output_log->add(F"打包 {appath}");
                                            assert(fimg->pack(aopath, appath));
                                        }
                                    }
                                SKIP?
                                    config.m_pack_output_log->add(F"跳过 {ppath}");
                                }
                            }

                            // 1.4 将引擎本体移动至打包目录
                            config.m_pack_output_log->add(F"正在复制引擎运行时");
                            do filesys::copy(std::args()[0], F"{export_path}/{proj.m_name}.exe")->unwarp;
                            do CxxProject::get_lib_files_by_config(je::editor::platform())
                                ->> \lf = lf->get_dynamic_libs
                                        ->> \libpath = do filesys::copy(F"{std::exepath()}/{libpath}", F"{export_path}/{libpath}")->unwarp;
                                    ;
                                ;
                            
                            // 1.5 将启动脚本编译后打入镜像
                            config.m_pack_output_log->add(F"正在打包启动脚本");
                            let boot_up_script = @"
                                import je;
                                import je.gui;
                                import woo.std;
                                import builtin.api.serialize.main;
                                import builtin.api.rend.main;

                                let mut ENGINE_GRAPHIC_PIPELINE = "Graphic::DefaultGraphicPipelineSystem";
                                let LOADED_WORLDS_MAPPING = {}mut: map<string, je::world>;
                                func LOAD_WORLD(path: string)
                                {
                                    let world_dat = je::file::readall(path)
                                        =>> \dat = dat->todict;
                                        ->  val
                                        ->> \k, v = (k as string, v);
                                        ;
                                    
                                    let allsys = world_dat["systems"] as array->connect(world_dat["runtime_systems"] as array);
                                    world_dat->unsafe::cast:<map<string, dynamic>>->set("systems", allsys: dynamic); 
                                    LOADED_WORLDS_MAPPING->set(path, jeapi::deserialize::world(RUNTIME_UNIVERSE, world_dat));
                                }

                                let LOADED_MODULE_HANDLES = []mut: vec<handle>;

                                // 在此处加载模块
                                $LOAD_DYLIB_MODULES$

                                // 在此设置分辨率
                                $APPLY_RESOLUTION$
                                
                                // 启动Universe，在Universe中加载世界
                                let RUNTIME_UNIVERSE = je::universe::create();
                               
                                // 在此处应用项目设置
                                $APPLY_PROJECT_CONFIG$

                                // 在此处加载世界实例
                                $LOAD_WORLD_INSTANCE$

                                RUNTIME_UNIVERSE->wait();

                                for (let _, libhandle : LOADED_MODULE_HANDLES)
                                    je::editor::unload_module(libhandle);
                            "@;

                            // 1.5.1 生成加载动态库相关代码
                            config.m_pack_output_log->add(F"正在生成装载动态库的脚本");
                            let mut dylib_loader = "";
                            for (let _, (minstance, (opath, ppath)) : dll_module_path)
                            {
                                // TODO: 根据情况，从镜像文件中释出相关文件
                                assert(ppath[0] == '@');

                                let runtime_loading_code = 
                                    "LOADED_MODULE_HANDLES->add(" 
                                    + "je::editor::load_module($MODULENAME$, std::exepath() + $MODULERPATH$)->val"
                                    + ");";

                                dylib_loader +=
                                    runtime_loading_code
                                        ->replace("$MODULENAME$", minstance.name->enstring)
                                        ->replace("$MODULERPATH$", ppath->sub(1)->enstring)
                                    + "\n";
                            }

                            // 1.5.2 应用项目设置
                            config.m_pack_output_log->add(F"正在生成应用项目设置的脚本");
                            let mut proj_config = "";
                            for (let _, pconfig : proj->get_configs)
                            {
                                proj_config += pconfig->apply + "\n";
                            }

                            // 1.5.3 加载和序列化世界
                            config.m_pack_output_log->add(F"正在生成加载世界的脚本");
                            let mut load_world_instance = "";
                            for (let _, startup_world_path : config.m_start_up_worlds)
                            {
                                load_world_instance += F"LOAD_WORLD({startup_world_path->enstring});\n";
                            }
                            match (config.m_rend_world)
                            {
                            value(rend_world_path)?
                                load_world_instance += F"jeapi::rend::reset_rend_world(LOADED_WORLDS_MAPPING[{rend_world_path->enstring}], je::typeinfo::load(ENGINE_GRAPHIC_PIPELINE)->val);\n";
                            none?
                                config.m_pack_output_log->add(F"没有指定要渲染的世界，跳过");
                            }

                            let (start_up_script_binary, start_up_script_binary_sz) = 
                                vm::create("@/builtin/main.wo", 
                                    boot_up_script
                                        ->replace("$LOAD_DYLIB_MODULES$", dylib_loader)
                                        ->replace("$APPLY_PROJECT_CONFIG$", proj_config)
                                        ->replace("$LOAD_WORLD_INSTANCE$", load_world_instance)
                                        ->replace("$APPLY_RESOLUTION$", F"je::input::set_window_size({config.m_resolution[0]}, {config.m_resolution[1]});")
                                    )->unwarp->save_binary;

                            assert(fimg->pack_buffer(start_up_script_binary->ptr, start_up_script_binary_sz, "@/builtin/main.wo"));

                            // 2. 结束，保存镜像
                            fimg->finish();

                            config.m_pack_output_log->add("打包完成");

                            config.m_finished = true;
                        }
                    }, ());
                return ok(do nil);
            }
        err(errdat)?
            return err(errdat);
        }
    }
    public func show_export_project(context: EditorContext)
    {
        let all_project_files = filesys::allsubpath(context->get_project.m_path)->unwarp;
        let selecting_all_worlds_file = all_project_files
            ->  forall(\p = filesys::extension(p)->lower == ".jeworld";)
            ->> \p = (context->get_project->make_path_normalize(p), mut false);
            ;
        let bootup_world = mutable::create(option::none: option<string>);
        let pack_image_file_size = mutable::create(128);
        let reso_option_index = mutable::create(1);
        let reso_config = mutable::create((1366, 768));
        let pack_config_instance = mutable::create(option::none: option<pack_config>);

        context->launch_editor_form(func(step: mutable<int>){
            do BeginAttr("项目导出向导", WindowsAttribute::ImGuiWindowFlags_AlwaysAutoResize);
                
            let mut open = true;
            let (cur_width, _) = GetContentRegionAvail();

            let current_step_count = step->get;
            if (current_step_count == 0)
            {
                TextDisabled("即将开始……");
                Separator();

                do BeginChildSize("SUBFORM.", 500., 300.);

                Text("欢迎使用JoyEngineECS 项目导出向导");
                Text("向导将引导您完成接下来一系列的配置操作");
                Text("注意：导出操作将删除项目目录下的 .export 目录中的全部内容");
                
                EndChild();
                
                if (ButtonSize("我已确认准备就绪，继续下一步", (cur_width, 0.)))
                    step->set(current_step_count + 1);
                if (ButtonSize("取消导出", (cur_width, 0.)))
                    open = false;
            }
            if (current_step_count == 1)
            {
                TextDisabled("第一步 选择启动时加载的世界");
                Separator();

                do BeginChildSize("SUBFORM.", 500., 300.);

                Text("请在下方勾选导出项目启动时，需要自动加载的世界");

                do BeginChild("SUBFORM.2");
                do selecting_all_worlds_file
                    ->> \path_and_checked = do CheckBox(path_and_checked...)
                            ->> \opt = path_and_checked[1] = opt;
                        ;
                    ;
                EndChild();
                EndChild();
                
                if (ButtonSize("下一步", (cur_width, 0.)))
                {
                    do bootup_world->set(option::none);
                    step->set(current_step_count + 1);
                }
                if (ButtonSize("上一步", (cur_width, 0.)))
                    step->set(current_step_count - 1);
            }
            if (current_step_count == 2)
            {
                TextDisabled("第二步 选择一个启动世界");
                Separator();

                do BeginChildSize("SUBFORM.", 500., 300.);
                Text("请在下方选择导出项目启动后，默认渲染的场景");
                Text("* 若不选择，则不在任何世界渲染");
                
                let (avail_width, avail_height) = GetContentRegionAvail();
                if (BeginListBox("##", avail_width, avail_height))
                {
                    for (let _, (path, checked) : selecting_all_worlds_file)
                    {
                        if (checked)
                        {
                            if (SelectableSelected(path, bootup_world->get->>\p = p == path;->valor(false)))
                                do bootup_world->set(option::value(path));
                        }
                    }
                    EndListBox();
                }
                EndChild();
                
                if (ButtonSize("下一步", (cur_width, 0.)))
                    step->set(current_step_count + 1);
                if (ButtonSize("上一步", (cur_width, 0.)))
                    step->set(current_step_count - 1);
            }
            if (current_step_count == 3)
            {
                TextDisabled("第三步 导出画面设置");
                Separator();

                do BeginChildSize("SUBFORM.", 500., 300.);

                match (bootup_world->get)
                {
                value(_)?
                    {
                        Text("请选择启动时默认渲染的画面分辨率");
                        Text("* 默认为 1366x768");

                        let static reso_list = [
                            ("1280x720 [16:9]", (1280, 720)),
                            ("1366x768 [16:9]", (1366, 768)),
                            ("1920x1080 [16:9]", (1920, 1080)),
                            ("2560x1440 [16:9]", (2560, 1440)),
                            ("3840x2160 [16:9]", (3840, 2160)),

                            ("800x600 [4:3]", (800, 600)),
                            ("1024x768 [4:3]", (1024, 768)),
                            ("1400x1050 [4:3]", (1400, 1050)),
                            ("1920x1440 [4:3]", (1920, 1440)),
                        ];

                        do Combo("##RESO_LIST.", reso_list->>\RR = RR[0];, reso_option_index->get)
                            ->> func(idx)
                                {
                                    do reso_option_index->set(idx);
                                    do reso_config->set(reso_list[idx][1]);
                                }
                            ;
                    }
                none?
                    {
                        Text("并未指定要渲染的世界，您可以返回上一步，或者继续导出");
                    }
                }
                EndChild();
                
                if (ButtonSize("下一步", (cur_width, 0.)))
                    step->set(current_step_count + 1);
                if (ButtonSize("上一步", (cur_width, 0.)))
                    step->set(current_step_count - 1);
            }
            if (current_step_count == 4)
            {
                TextDisabled("第四步 导出镜像设置");
                Separator();

                do BeginChildSize("SUBFORM.", 500., 300.);
                Text("请为打包镜像设置分包大小，单位为MB");
                Text("* 默认为 128MB");
                
                do InputInt("##IMAGESZ.", pack_image_file_size->get)
                    ->> func(n)
                        {
                            if (n > 0)
                                do pack_image_file_size->set(n);
                        }
                    ;

                EndChild();
                
                if (ButtonSize("下一步", (cur_width, 0.)))
                    step->set(current_step_count + 1);
                if (ButtonSize("上一步", (cur_width, 0.)))
                    step->set(current_step_count - 1);
            }
            if (current_step_count == 5)
            {
                TextDisabled("导出操作确认");
                Separator();

                do BeginChildSize("SUBFORM.", 500., 300.);
                Text("打包导出的全部配置已经准备就绪");
                Text("按下确认开始打包");

                Separator();
                Text("* 请再次确认 .export 目录是否有文件尚未备份！");
                
                EndChild();
                
                if (ButtonSize("开始打包", (cur_width, 0.)))
                {
                    let conf = pack_config{
                        m_pack_dll_into_image = false,
                        m_image_size = pack_image_file_size->get,
                        m_start_up_worlds = selecting_all_worlds_file
                            ->  forall(\path_and_checked = path_and_checked[1];)
                            ->> \path_and_checked = path_and_checked[0];,
                        m_rend_world = bootup_world->get,
                        m_rule = _default_rule,
                        m_resolution = reso_config->get,

                        m_pack_output_log = []mut,
                        m_finished = mut false,
                    };
                    do _export_logic(context->get_project, conf)->unwarp;
                    pack_config_instance->set(option::value(conf));
                    step->set(current_step_count + 1);
                }
                if (ButtonSize("上一步", (cur_width, 0.)))
                    step->set(current_step_count - 1);
            }
            if (current_step_count == 6)
            {
                TextDisabled("正在导出……");
                Separator();

                do BeginChildSize("SUBFORM.", 500., 300.);
                
                let (avail_width, avail_height) = GetContentRegionAvail();
                if (BeginListBox("##", avail_width, avail_height))
                {
                    let logs = pack_config_instance->get->val.m_pack_output_log;
                    for (let mut index = logs->len; index > 0; index -= 1)
                        do Selectable(logs[index - 1]);

                    EndListBox();
                }
                
                EndChild();
                
                if (pack_config_instance->get->val.m_finished)
                {
                    if (ButtonSize("完成", (cur_width, 0.)))
                        open = false;
                }

            }
            End();
            return open;
        }, (mutable::create(0),));
    }
}
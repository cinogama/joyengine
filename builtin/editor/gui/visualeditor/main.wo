// visualeditor.main
// 可视化编辑器
// ---------------------------------------
// 由于ECS中，逻辑和数据分离，这在一定情况下会阻碍开发
// visualeditor预计是一个可视化的逻辑行为编辑器，拥有
// woolang或C++后端。
/*
概念：
值节点 (多入口多出口)(可缓存的值节点)
行为节点（单入口（实际上可以不限制？）多出口）（起始行为节点）（自定义脚本行为节点）
流程端口 （多入单出）
值端口 （单入多出）（类型）
*/

import pkg::interface;

import woo::std;
import je::gui;

using je;
using std;
using je::gui;

namespace visualeditor
{
    using uid_t = string
    {
        func create()=> uid_t
        {
            return uid(): uid_t;
        }
    }
    
    using IType = struct
    {
        m_name: string,
        m_color: (int, int, int, int),
        m_typeid: int,
    }
    {
        func create<T>()
        {
            return IType{
                m_name = typeof(declval:<T>())::name,
                m_color = typeof(declval:<T>())::color,
                m_typeid = typeid:<T>,
            };
        }
    }

    using Value<T> = struct
    {
        m_value: mut typeof(declval:<T>())::value_t,
    }
    {
        func get_type<T>(self: Value<T>)=> IType
        {
            return IType::create:<T>();
        }
        func edit<T>(self: Value<T>)=> bool
        {
            return typeof(declval:<T>())::edit(self);
        }
    }

    interface! IValue
    {
        func edit(self: IValue)=> bool;
        func get_type(self: IValue)=> IType;
    }
    
    using InPort = struct
    {
        m_uid: uid_t,
        m_name: string,
        m_typed_value: IValue,
    };
    using OutPort = struct
    {
        m_uid: uid_t,
        m_name: string,
        m_type: IType,
    }
    {
        func create<OutT>(name: string)
        {
            return OutPort{
                m_uid = uid_t::create(),
                m_name = name,
                m_type = IType::create:<OutT>(),
            };
        }
    }

    using Node = struct
    {
        // 值节点是值端口的集合
        m_uid: uid_t,
        m_in_vports: vec<InPort>,
        m_out_vports: vec<OutPort>,
    }
    {
        func create()
        {
            return Node{
                m_uid = uid_t::create(),
                m_in_vports = []mut,
                m_out_vports = []mut,
            };
        }
        public func define_out<OutT>(self: Node, name: string)
        {
            let oport = OutPort::create:<OutT>(name);
            self.m_out_vports->add(oport);
            return oport;
        }
    }

    interface! INode
    {
        func serialize(self: INode)=> string;
        func deserialize(self: INode, data: string)=> bool;
    }

    using Behavior = void
    {
        public let name = "Behavior";
        public let color = (75, 75, 75, 255);
        public alias value_t = void;
    }

    using BeginNode = struct{
        m_next: OutPort
    }
    {
        public func create(node: Node)
        {
            return BeginNode{
                m_next = node->define_out :<Behavior>("next"),
            };
        }
        public func serialize(_: BeginNode)
        {
            return "";
        }
        public func deserialize(_: BeginNode, _: string)
        {
            return true;
        }
    }

    using Graph = struct
    {
        // 图是节点和链接关系的集合
        m_nodes: map<uid_t, (Node, INode)>,

        m_scale: mut real,
        m_center: mut (real, real),
    }
    {
        func create()
        {
            return Graph{
                m_nodes = {}mut,
                m_scale = mut 1.0,
                m_center = mut (0., 0.),
            };
        }
        func add_node<NodeT>(self: Graph)
        {
            let node = Node::create();
            let nodeinstance = typeof(declval:< NodeT>())::create(node);
            self.m_nodes->set(node.m_uid, (node, INode::create(nodeinstance)));
            return nodeinstance;
        }
        func edit(self: Graph, availsz: (real, real))
        {
            do self;

            let drawlist = GetWindowDrawList();

            let (avaliw, avalih) = availsz;

            do InvisibleButton("##edit_range", (avaliw <= 100. ? 100. | avaliw, avalih <= 100. ? 100. | avalih));
            let (p0, p1) = GetItemRect();
            
            PushClipRect(p0, p1);
            drawlist->AddRectFilled(p0, p1, (75, 75, 75, 255));
            
            // TODO: Draw node here.

            PopClipRect();
        }
    }

    public func main()
    {
        let testg = Graph::create();
        do testg->add_node :<BeginNode>();
        launch(func()
            {
                match (BeginOpen("节点编辑器 测试"))
                {
                value(show)?
                    {
                        if (show)
                        {
                            testg->edit(GetContentRegionAvail());
                        }
                        End();
                        return true;
                    }
                none?
                    {
                        End();
                        return false;
                    }
                }
            }, ());
    }
}
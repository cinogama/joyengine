using je::gui;

namespace editor::gui::particalbaker
{
    public using ParticalContext = struct{
        m_frame_count : mut int,
        m_frame_size : mut (int, int),
        m_frame_rate : mut real,    // Sec per frame
        m_repeat_round : mut int,
        m_frames_caches : mut array<je::graphic::texture>,
        m_script : mut string,
        m_path : filesys::path_t,
    };
    let PARTICALBAKER = 
@"// Partical baker
// (C)Cinogama project.

import woo.std;
import pkg.math;
import je;

using ParticalContext = struct{
    m_frame_count : mut int,
    m_frame_size : mut (int, int),
    m_frame_rate : mut real,    // Sec per frame
    m_repeat_round : mut int,
    m_frames_caches : mut array<je::graphic::texture>,
    m_script : mut string,
    m_path : filesys::path_t,
};

let mut partical_context = nil->unsafe::cast:<ParticalContext>();
let mut baking_cache = []: array<je::graphic::texture>;

public func upos2ppox(upos: (real, real))=> (int, int)
{
    let (w, h) = partical_context.m_frame_size;
    let (px, py) = upos;
    return (math::round((px + 1.) / 2. * w: real), math::round((py + 1.) / 2. * h: real));
}
public func ppos2upox(upos: (int, int))=> (real, real)
{
    let (w, h) = partical_context.m_frame_size;
    let (ipx, ipy) = upos;
    return ((ipx: real / w: real - 0.5) * 2.0, (ipy: real / h: real - 0.5) * 2.0);
}
public func clamp(v: real)
{
    if (v < 0.) return 0.;
    else if (v > 1.) return 1.;
    return v;
}

func draw(mut frame: int, pos: (real, real), color: (real, real, real, real))
{
    let fcount = partical_context.m_frame_count;
    while (frame < 0)
        frame += fcount;

    let (w, h) = partical_context.m_frame_size;
    let (ipx, ipy) = upos2ppox(pos);

    if (ipx >= 0 && ipx < w && ipy >= 0 && ipy < h)
    {
        let pix = baking_cache[frame % fcount]->pix((ipx, ipy));
        let (or, og, ob, oa) = pix->get_color();
        let (r, g, b, a) = color;
        let cr = clamp(r), cg = clamp(g), cb = clamp(b), ca = clamp(a);

        // Mix
        pix->set_color((
            or * (1. - ca) + cr * ca,
            og * (1. - ca) + cg * ca,
            ob * (1. - ca) + cb * ca,
            oa * (1. - ca) + ca * ca,
        ));
    }
}
public func deltatime()
{
    return partical_context.m_frame_rate;
}
public func pixelsize()
{
    let (w, h) = partical_context.m_frame_size;
    return (1. / w: real, 1./ h: real);
}
public func launch(frame_place: int, partical_count: int)
{
    for (let mut i = 0; i < partical_count; i += 1)
    {
        let user_data = perparticle(frame_place);
        for (let mut f = 0; f < partical_context.m_frame_count * partical_context.m_repeat_round; f += 1)
        {
            let fid = f + frame_place;
            let poses = position(fid, user_data) as array<(real, real)>;
            let col = color(fid, user_data) as (real, real, real, real);

            // Apply!
            for (let _, pos : poses)
                draw(fid, pos, col);
        }
    }
}
extern public func _start_baking(context: ParticalContext)
{
    partical_context = context;

    for (let mut i = 0; i < partical_context.m_frame_count; i += 1)
        baking_cache->unsafe::cast:<vec<je::graphic::texture>>->add(je::graphic::texture::create(partical_context.m_frame_size...));

    assert(baking_cache->len == partical_context.m_frame_count);

    context.m_frames_caches = baking_cache;
    launcher(partical_context.m_frame_count);
    
    // Make sure ok, force update all texture.
    for (let _, t : baking_cache)
        t->pix((0, 0))->set_color(t->pix((0, 0))->get_color());
}
"@;
    assert(vm::create_virtual_script("je/particalbacker.wo", PARTICALBAKER, false));

    let DEFAULT_SOURCE = 
@"// Particalbaker Script
import woo.std;
import pkg.worst;
import je.particalbacker;

using std;

public func launcher(total_frame: int)
{
    for (let i : range::create(0, total_frame - 1))
        launch(i, 1);
}

using PerparticleContext = struct{
    pos: mut (real, real),
    speed: mut (real, real),
    life: mut int,
};

public func perparticle(launch_frame: int)
{
    return PerparticleContext{
        pos = mut(0., 0.),
        speed = mut(randreal(-1., 1.), randreal(-1., 1.)),
        life = mut 20,
    };
}

public func position(frame: int, context: PerparticleContext)
{
    let (x, y) = context.pos;
    let (sx, sy) = context.speed;
    let (pixw, pixh) = pixelsize();

    context.pos = (x + sx * deltatime(), y + sy * deltatime());
    context.life -= 1;

    // Make a star shape.
    let (ix, iy) = upos2ppox((x, y));
    return [
        ppos2upox((ix + 1, iy)),
        ppos2upox((ix - 1, iy)),
        ppos2upox((ix, iy)),
        ppos2upox((ix, iy + 1)),
        ppos2upox((ix, iy - 1)),
    ];
}

public func color(frame: int, context: PerparticleContext)
{
    return (1., 1., 1., context.life: real / 19.);
}
"@;
    using _EditorContext = struct{
        m_last_update_time: mut real,
        m_frame_index: mut int,
        m_enable_bake: mut bool, 
    };
    func _particalbaker_editor(
        context: EditorContext, 
        partical_context: ParticalContext, 
        econtext: _EditorContext)
    {
        let mut open = BeginAttrOpen(F"粒子动画烘焙器 {partical_context.m_path}", 
            WindowsAttribute::ImGuiWindowFlags_AlwaysAutoResize
            + WindowsAttribute::ImGuiWindowFlags_MenuBar);

        if (BeginMenuBar())
        {
            if (MenuItemEnabled("烘焙", econtext.m_enable_bake))
            {
                match (vm::create("je/particalbacker/baker.wo", 
                    partical_context.m_script))
                {
                ok(vmm)?
                    {
                        if (!vmm->run()->has)
                            jeapi::gui::form::errmsg("烘焙失败", F"烘焙脚本运行终止，可能存在错误，请检查日志");
                        
                        do thread::create(func(){
                            econtext.m_enable_bake = false;
                            if (!vmm->invoke("_start_baking", [partical_context: dynamic])->has)
                                jeapi::gui::form::errmsg("烘焙失败", F"烘焙脚本运行终止，可能存在错误，请检查日志");
                            econtext.m_enable_bake = true;
                        }, ());
                    }
                err(msg)?
                    jeapi::gui::form::errmsg("烘焙失败", F"烘焙脚本存在错误\n{msg}");
                }
            }
            EndMenuBar();
        }

        BeginGroup();

        Text("帧数");
        SameLine();
        do InputInt("##framecount", partical_context.m_frame_count)
            ->> \c = c > 0 ? (partical_context.m_frame_count = c) | (nil: void);;

        Text("尺寸");
        SameLine();
        do InputInt2("##framesize", partical_context.m_frame_size...)
            ->> \s = (x > 0 && y > 0) ? (partical_context.m_frame_size = s) | (nil: void)
                where (x, y) = s
                ;;

        Text("帧速率(秒/帧)");
        SameLine();
        do InputFloat("##framerate", partical_context.m_frame_rate)
            ->> \r = r > 0. ? (partical_context.m_frame_rate = r) | (nil: void);;

        Text("粒子渲染趟数");
        SameLine();
        do InputInt("##repeatcount", partical_context.m_repeat_round)
            ->> \r = r > 0 ? (partical_context.m_repeat_round = r) | (nil: void);;
        
        let (w, h) = partical_context.m_frame_size;

        do BeginChildSize("##review", w: real * 400. / h: real, 400.);
        
        let frames = partical_context.m_frames_caches;
        
        if (std::time() - econtext.m_last_update_time >= partical_context.m_frame_rate)
        {
            econtext.m_frame_index += 1;
            econtext.m_last_update_time = std::time();
        }

        econtext.m_frame_index = frames->empty
            ? 0
            | econtext.m_frame_index % frames->len;
        
        ProgressBar(frames->empty ? 0. | econtext.m_frame_index: real / frames->len: real);
        
        let drawlist = GetWindowDrawList();
        do InvisibleButton("##draw_space", GetContentRegionAvail());

        let (p0, p1) = GetItemRect();
        let (lux, luy) = p0;
        let (rbx, rby) = p1;

        PushClipRect(p0, p1);
        drawlist->AddRectFilled(p0, p1, (75, 75, 75, 255));
        if (!frames->empty)
            drawlist->AddImage(
                (lux, luy), 
                (rbx, rby), 
                frames[econtext.m_frame_index]);

        EndChild();

        EndGroup();
        SameLine();

        BeginGroup();
        
        do InputTextMultilineSize("##source", partical_context.m_script, 500., GetContentRegionAvail()[0])
            ->> \t = partical_context.m_script = t;;

        EndGroup();

        End();

        return open;
    }
    public func show(
        context: EditorContext, 
        partical_context: ParticalContext,
        econtext: _EditorContext)
    {
        launch(_particalbaker_editor, (context, partical_context, econtext));
    }
    public func debugshow(context: EditorContext)
    {
        show(context, ParticalContext{
            m_frame_count = mut 24,
            m_frame_size = mut (64, 64),
            m_frame_rate = mut 1./24.,
            m_repeat_round = mut 1,
            m_frames_caches = mut [],
            m_script = mut DEFAULT_SOURCE,
            m_path = filesys::normalize(std::exepath()),
        }, _EditorContext{
            m_last_update_time = mut std::time(),
            m_frame_index = mut 0,
            m_enable_bake = mut true,
        });
    }
}
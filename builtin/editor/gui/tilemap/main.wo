// Tile map editor

import woo::std;
import je;
import je::gui;
import je::editor;

import pkg::try;
import pkg::filesystem;
import pkg::image;

using std;
using je;
using je::gui;
using je::editor;

namespace editor::gui::tilemap
{
    // 由于Tilemap的特性，Tile的纹理坐标不是引擎内置的以左下角为原点，而是以左上角为原点。
    using Tile = struct{
        uid: string,                 // 当前Tile的uid，被用于跟踪Tile并进行组件更新
        texture: graphic::texture,   // 为了规避边缘像素采样问题，tile使用的纹理会单独裁剪出来变成独立的纹理   
        tile_components: dict<typeinfo, dict<string/*member name*/, string /*member value*/>>,
        location: (int, int),
    }
    {
        func _create_clip_texture(
            context: EditorContext, 
            imgpath: filesys::path_t, 
            maintex: graphic::texture, 
            ix: int, iy: int, 
            xcount: int, ycount: int)
        {
            let (maintex_w, maintex_h) = maintex->size;
            let (tile_w, tile_h) = (maintex_w / xcount, maintex_h / ycount);

            let tileimage = image::create(tile_w, tile_h);
            // 

            let (lux, luy) = (ix * tile_w, (ycount - iy) * tile_h);
            for (let mut idx = 0; idx < tile_w; idx += 1)
            {
                for (let mut idy = 0; idy < tile_h; idy += 1)
                {
                    tileimage->setpix((idx, tile_h - 1 - idy), maintex->pix((lux + idx, luy - 1 - idy))->get_color);
                }
            }
            if (tileimage->save(imgpath->tostring))
                return graphic::texture::load(context->get_project->make_path_normalize(imgpath));

            return option::none;
        }
        func create(context: EditorContext, 
            maintex: graphic::texture, 
            crc64: int, 
            tileuid: string,
            ix: int, iy: int, 
            xcount: int, ycount: int)
        {
            let tilemap_path = context->get_project.m_path / "resource" / "texture" / "tilemap";
            do filesys::mkdir(tilemap_path);

            let imgpath = tilemap_path / F"{crc64}-{ix}d{xcount}-{iy}d{ycount}.png";

            try! tiletexture = context->get_project->make_path_normalize(imgpath)
                ->  graphic::texture::load
                ->  orbind(\=_create_clip_texture(context, imgpath, maintex, ix, iy, xcount, ycount);)
                ->> \t = result::ok(t): result<graphic::texture, string>;
                ->  valor(result::err("无法加载或创建Tile纹理"))
                ;
            return result::ok(Tile{
                texture = tiletexture,
                tile_components = {},
                uid = tileuid,
                location = (ix, iy),
            });
        }
    }

    // tilemapset 是一组地图的纹理切片、组件集合设置的集合
    // 一个项目可以有多组图集
    using TileMapSet = struct{
        name: string,
        texture: graphic::texture,
        tiles: array<array<Tile>>,
    }
    {
        func create(context: EditorContext, name: string, tilemaptex: graphic::texture, xcount: int, ycount: int)
        {
            try! crc64 = tilemaptex->path
                =>> \p = crc64file(context->get_project->parse_path_normalize(p)->tostring);
                ->> \crc = result::ok(crc): result<int, string>;
                ->  valor(result::err("创建TileMapSet的纹理必须是从文件加载的"))
                ;

            let tiles = []mut: vec<array<Tile>>;
            for (let mut ix = 0; ix < xcount; ix += 1)
            {
                let ytiles = []mut: vec<Tile>;
                for (let mut iy = 0; iy < ycount; iy += 1)
                {
                    try! tile = Tile::create(context, tilemaptex, crc64, je::uid(), ix, iy, xcount, ycount);
                    ytiles->add(tile);
                }
                tiles->add(ytiles as vec<Tile>->unsafe::cast :<array<Tile>>());
            }
            return result::ok(
                TileMapSet
                {
                    name = name,
                    texture = tilemaptex,
                    tiles = tiles as vec<array<Tile>>->unsafe::cast :<array<array<Tile>>>(),
                });
        }
        func getsize(self: TileMapSet)
        {
            return (self.tiles->len, self.tiles->get(0)->>\a=a->len;->valor(0));
        }
        func gettile(self: TileMapSet, x: int, y: int)
        {
            return self.tiles->get(x)=>>\a = a->get(y);;
        }
    }

    using TileEditContext = struct{
        m_context: EditorContext,
        m_editing_world: mut option<world>,
        m_tile_sets: vec<TileMapSet>,
        m_selected_tileset_index: mut int,
        m_selected_tile: mut (int, int),

        // 以下部分是绘制区域的数据
        m_drawing_layer: mut int,
        m_focus_on_drawing_layer: mut bool,
        m_offset: mut(real, real),
        m_scale: mut real,
        m_layerd_tiles: map<int, map<int, map<int, Tile>>>
    }
    {
        func create(context: EditorContext)
        {
            return TileEditContext{
                m_context = context,
                m_editing_world = mut option::none,
                m_tile_sets = []mut,
                m_selected_tileset_index = mut -1,
                m_selected_tile = mut (0, 0),

                m_drawing_layer = mut 0,
                m_focus_on_drawing_layer = mut false,
                m_offset = mut(0., 0.),
                m_scale = mut 1.,
                m_layerd_tiles = {}mut,
            };
        }
        func apply_draw_tile(self: TileEditContext, x: int, y: int)
        {
            match (self.m_tile_sets->get(self.m_selected_tileset_index)=>>\tileset = tileset->gettile(self.m_selected_tile...);)
            {
            value(tile)?
                self.m_layerd_tiles->getorset(self.m_drawing_layer, {}mut)->getorset(x, {}mut)->set(y, tile);
            none?;
            }
        }
        func clear_draw_tile(self: TileEditContext, x: int, y: int)
        {
            do self.m_layerd_tiles->get(self.m_drawing_layer)=>>\tiles=tiles->get(x);->>\ytiles=ytiles->remove(y);;
        }
        func update(self: TileEditContext)
        {
            let now_editing_world = self.m_context->get_project->get_editing_world;
            if (!self.m_editing_world=>>\w = now_editing_world->>\nw = w == nw;;->valor(false))
            {
                match (now_editing_world)
                {
                value(w)?
                    {
                        do w;
                    }
                none?
                    ;
                }
                self.m_editing_world = now_editing_world;
            }
        }
        func create_tilemap_form(self: TileEditContext)
        {
            let create_context = struct{
                m_name = mut "新建tilemap",
                m_texture = mut option::none: option<graphic::texture>,
                m_tile_x_count = mut 1,
                m_tile_y_count = mut 1, 
            };
            launch(func()
                {
                    let mut open = true;
                    match (BeginAttrOpen("新建TileMap", WindowsAttribute::ImGuiWindowFlags_AlwaysAutoResize))
                    {
                    value(show)?
                        if (show)
                        {
                            match (jeapi::gui::widget::File("使用的TileMap纹理", 
                                create_context.m_texture=>>\t=t->path;->valor(""))
                                =>> \newpath = create_context.m_texture := graphic::texture::load(newpath);
                            )
                            {
                            value(tex)?
                                {
                                    let (x, y) = tex->size;
                                    create_context.m_tile_x_count = std::max(1, x / 16);
                                    create_context.m_tile_y_count = std::max(1, y / 16);
                                }
                            none?
                                ;
                            }

                            BeginGroup();
                            Text("预览");
                            
                            match (create_context.m_texture)
                            {
                            value(tex)?
                                {
                                    ImageScale(tex, std::min(200. / tex->size[0]: real, 300. / tex->size[1]: real));
                                } 
                            none? Text("暂无预览");
                            }
                            
                            EndGroup();
                            
                            SameLine();
                            
                            BeginGroup();
                            do InputText("名称", create_context.m_name)->>\newname = create_context.m_name = newname;;
                            do InputInt("X方向Tile数量", create_context.m_tile_x_count)->>\newc = create_context.m_tile_x_count = std::max(1, newc);;
                            do InputInt("Y方向Tile数量", create_context.m_tile_y_count)->>\newc = create_context.m_tile_y_count = std::max(1, newc);;
                            EndGroup();

                            if (Button("创建"))
                            {
                                match (create_context.m_texture)
                                {
                                value(tex)?
                                    {
                                        match (TileMapSet::create(
                                            self.m_context, 
                                            create_context.m_name,
                                            tex,
                                            create_context.m_tile_x_count,
                                            create_context.m_tile_y_count,
                                            ))
                                        {
                                        ok(tilemap)?
                                            {
                                                open = false;
                                                self.m_tile_sets->add(tilemap);
                                            }
                                        err(msg)?
                                            jeapi::gui::form::errmsg("失败", msg);
                                        }
                                        
                                    }
                                none?
                                    jeapi::gui::form::errmsg("失败", "创建TileMap时需要指定纹理");
                                }
                            }
                        }
                    none?
                        open = false;
                    }
                    End();
                    return open;
                }, ());
        }
        func show_tile_sets(self: TileEditContext)
        {
            if (BeginChildSize("##tilemapsets", 400., 0.))
            {
                do InputInt("绘制层级", self.m_drawing_layer)->>\n = self.m_drawing_layer = n;;
                SameLine();
                do CheckBox("着重", self.m_focus_on_drawing_layer)->>\o = self.m_focus_on_drawing_layer = o;;

                if (BeginTabBar("TileMap 集合"))
                {
                    for (let index, tset: self.m_tile_sets)
                    {
                        if (BeginTabItem(F"{tset.name}##{index}"))
                        {
                             self.m_selected_tileset_index = index;

                            let drawlist = GetWindowDrawList();
                            let (avaliw, _) = GetContentRegionAvail();
                            let (texw, texh) = tset.texture->size;
                            let scale = avaliw / texw: real;
                            let (rangew, rangeh) = (avaliw <= 100. ? 100. | avaliw, texh: real * scale  <= 100. ? 100. | texh: real * scale);

                            let (blockcountx, blockcounty) = tset->getsize;
                            let (blockw, blockh) = (rangew / blockcountx: real, rangeh / blockcounty: real);

                            do InvisibleButton("##tileset", (rangew, rangeh));
                            let ismouse_hovered = IsItemHovered();
                            let (p0, p1) = GetItemRect();
                            let (lux, luy) = p0;

                            let (mposx, mposy) = GetMousePos();
                            let (mpblockx, mpblocky) = (
                                ((mposx - lux) / blockw): int: real, 
                                ((mposy - luy) / blockh): int: real
                                );

                            PushClipRect(p0, p1);

                            drawlist->AddRectFilled(p0, p1, (75, 75, 75, 255));
                            drawlist->AddImage(
                                p0, p1, 
                                tset.texture,
                                (255, 255, 255, 255));

                            if (ismouse_hovered)
                            {
                                if (input::keydown(keycode::MOUSE_L_BUTTION))
                                    self.m_selected_tile = (mpblockx: int, mpblocky: int);
                                else
                                    drawlist->AddRectFilled(
                                        (lux + mpblockx * blockw, luy + mpblocky * blockh), 
                                        (lux + mpblockx * blockw + blockw, luy + mpblocky * blockh + blockh), 
                                        (255, 255, 255, 100));
                            }

                            let (locx, locy) = self.m_selected_tile;
                            drawlist->AddRect(
                                (lux + locx: real * blockw, luy + locy: real * blockh), 
                                (lux + locx: real * blockw + blockw, luy + locy: real * blockh + blockh), 
                                (255, 255, 255, 255), 2.);


                            PopClipRect();

                            EndTabItem();
                        }
                    }
                    if (self.m_tile_sets->empty())
                    {
                        TextDisabled("没有可用的TileMap");
                    }
                    EndTabBar();
                }
            }
            EndChild();
        }
        func draw_tile(self: TileEditContext)
        {
            if (BeginChild("##drawtiles"))
            {
                let drawlist = GetWindowDrawList();

                let (avaliw, avalih) = GetContentRegionAvail();
                let (rangew, rangeh) = (avaliw <= 100. ? 100. | avaliw, avalih  <= 100. ? 100. | avalih);

                do InvisibleButton("##tileset", (rangew, rangeh));
                let ismouse_hovered = IsItemHovered();
                let (p0, p1) = GetItemRect();
                let (lux, luy) = p0;
                let (draww, drawh) = (p1[0] - lux, p1[1] - luy);
                PushClipRect(p0, p1);
                
                drawlist->AddRectFilled(p0, p1, (75, 75, 75, 255));

                // scale = 1. 的情况下，一个Tile的大小是这么大
                let BASE_TILE_SIZE = 50.;
                let scaled_tile_size = self.m_scale * BASE_TILE_SIZE;
                let (oldoffsetx, oldoffsety) = self.m_offset;

                for (let layer, tiles : self.m_layerd_tiles)
                {
                    for (let x, ytiles: tiles)
                    {
                        for (let y, tile : ytiles)
                        {
                            // 将瓦片画出来~
                            let mut tilealpha = 255;
                            if (self.m_focus_on_drawing_layer && layer != self.m_drawing_layer)
                                tilealpha = 75;

                            drawlist->AddImage(
                                (lux + x: real * scaled_tile_size + oldoffsetx, luy + y: real * scaled_tile_size + oldoffsety), 
                                (lux + x: real * scaled_tile_size + scaled_tile_size + oldoffsetx, luy + y: real * scaled_tile_size + scaled_tile_size + oldoffsety), 
                                tile.texture,
                                (255, 255, 255, tilealpha));
                        }
                    }
                }

                if (self.m_scale >= 1.)
                {
                    for (let mut ix = 0.; ix < draww; ix += scaled_tile_size)
                        drawlist->AddLine((lux + ix + oldoffsetx % scaled_tile_size, luy), (lux + ix + oldoffsetx % scaled_tile_size, p1[1]), (127, 127, 127, 255), 2.);
                    for (let mut iy = 0.; iy < drawh; iy += scaled_tile_size)
                        drawlist->AddLine((lux, luy + iy + oldoffsety % scaled_tile_size), (p1[0], luy + iy + oldoffsety % scaled_tile_size), (127, 127, 127, 255), 2.);
                }

                // 高亮鼠标所在的块儿
                static let mut recored_wheel_count = input::wheel();
                
                if (ismouse_hovered)
                {
                    let new_wheel_count = input::wheel();
                    self.m_scale *= math::pow(2., (new_wheel_count - recored_wheel_count): real);
                    recored_wheel_count = new_wheel_count;

                    let (mposx, mposy) = GetMousePos();

                    let (mpblockx, mpblocky) = (
                        math::floor((mposx - lux - oldoffsetx) / scaled_tile_size): real, 
                        math::floor((mposy - luy - oldoffsety) / scaled_tile_size): real
                        );

                    let mut highlight_alpha = 100;

                    if (input::keydown(keycode::MOUSE_L_BUTTION))
                    {
                        if (input::keydown(keycode::L_CTRL))
                        {
                            highlight_alpha = 0;

                            let (mousedelta_x, mousedelta_y) = GetMouseDeltaPos();
                            self.m_offset = (oldoffsetx + mousedelta_x, oldoffsety + mousedelta_y);
                        }
                        else
                        {
                            highlight_alpha = 50;
                            self->apply_draw_tile(mpblockx: int, mpblocky: int);
                        }
                    }
                    else if (input::keydown(keycode::MOUSE_R_BUTTION))
                    {
                        self->clear_draw_tile(mpblockx: int, mpblocky: int);
                    }

                    drawlist->AddRectFilled(
                        (lux + mpblockx * scaled_tile_size + oldoffsetx, luy + mpblocky * scaled_tile_size + oldoffsety), 
                        (lux + mpblockx * scaled_tile_size + scaled_tile_size + oldoffsetx, luy + mpblocky * scaled_tile_size + scaled_tile_size + oldoffsety), 
                        (255, 255, 255, highlight_alpha));
                }
                else
                    recored_wheel_count = input::wheel();

                PopClipRect();

            }
            EndChild();
        }
    }

    public func main(context: EditorContext)
    {
        let editctx = TileEditContext::create(context);
        launch(func(){
            let mut open = true;
            match (BeginAttrOpen("Tile editor test", WindowsAttribute::ImGuiWindowFlags_MenuBar))
            {
            value(show)?
                if (show)
                {
                    editctx->update();
                    if (BeginMenuBar())
                    {
                        if (BeginMenu("编辑"))
                        {
                            if (MenuItem("新建TileMap"))
                                editctx->create_tilemap_form();

                            EndMenu();
                        }
                        EndMenuBar();
                    }

                    BeginGroup();
                    editctx->show_tile_sets();
                    EndGroup();

                    SameLine();

                    BeginGroup();
                    editctx->draw_tile();
                    EndGroup();
                }
            none?
                open = false;
            }
            End();
            
            return open;
        }, ());
    }
}
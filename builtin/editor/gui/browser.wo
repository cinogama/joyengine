import pkg.image;
import pkg.filesystem;

import woo.shell;
import builtin.editor.cpp.main;
import builtin.editor.gui.animation2d;
import builtin.editor.gui.particalbaker;

using je::gui;

namespace editor::gui
{
    public let mut editor_need_hiding_file = true;

    func create_font_image(proj: Project, default_name: string, location: string)
    {
        let fonts = filesys::allsubpath(proj.m_path/"resource"/"font")
            -> or(\_=[];)
            -> forall(\path = filesys::isfile(path) && filesys::extension(path)->lower == ".ttf";)
            ->> \path = proj->make_path_normalize(path);
            ;

        if (fonts->empty)
        {
            jeapi::gui::form::errmsg("失败", "没有在 @/resource/font 找到有效的字体");
            return;
        }

        let create_context = (mut default_name, mut "Helloworld", mut 0, mut 16);
        launch(func(){
            let mut open = true;
            je::gui::SetNextWindowSizeConstraints((350., 200.), (350., 200.));
            do Begin(F"在{location}创建纹理");

            Text("文件名");
            create_context[0] = InputText("##imagename", create_context[0])->valor(create_context[0]);

            Separator();

            Text("字体");
            SameLine();
            do Combo("##fontname", fonts, create_context[2])->>\id = create_context[2] = id;;
            SameLine();
            do InputInt("##fontsize", create_context[3])->>func(new_size){
                if (new_size > 0)
                    create_context[3] = new_size;
            };

            let (w, h) = GetContentRegionAvail();
            create_context[1] = InputTextMultilineSize("##imagetext", create_context[1], w, h - 30.)
                ->valor(create_context[1]);

            if (Button("创建"))
            {
                match (je::graphic::font::load(fonts[create_context[2]], create_context[3]))
                {
                value(font_instance)?
                    {
                        let tex = font_instance->load_string(create_context[1]);
                        // 创建image，然后保存！
                        let (tw, th) = tex->size();
                        let img = image::create(tw, th);
                        for (let mut ix = 0; ix < tw; ix += 1)
                            for (let mut iy = 0; iy < th; iy += 1)
                                img->setpix((ix, iy), tex->pix((ix, iy))->get_color());
                        
                        let aimpath = F"{location}/{create_context[0]}.png";
                        if (!img->save(aimpath))
                            jeapi::gui::form::errmsg("创建失败", F"无法写入{aimpath}");
                        else
                        {
                            open = false;
                            force_update();
                        }
                    }
                none?
                    jeapi::gui::form::errmsg("失败", F"无法打开纹理：{fonts[create_context[2]]}");
                } 
            }
            SameLine();
            if (Button("取消"))
                open = false;

            End();

            return open;
        }, ());
    }

    func create_image(default_name: string, location: string, generator: (image)=> void)
    {
        let create_context = (mut 16, mut 16, mut default_name);
        launch(
            func(context: (mut int, mut int, mut string))
            {
                let mut open = true;
                je::gui::SetNextWindowSizeConstraints((300., 200.), (300., 200.));
                do Begin(F"在{location}创建纹理");
                Text("文件名");
                context[2] = InputText("##imagename", context[2])->valor(context[2]);

                Separator();

                Text("宽");
                SameLine();
                context[0] = InputInt("##width", context[0])->valor(context[0]);

                Text("高");
                SameLine();
                context[1] = InputInt("##height", context[1])->valor(context[1]);

                if (Button("创建"))
                {
                    let img = image::create(context[0], context[1]);

                    generator(img);

                    let aimpath = F"{location}/{context[2]}.png";
                    if (!img->save(aimpath))
                        jeapi::gui::form::errmsg("创建失败", F"无法写入{aimpath}");
                    else
                    {
                        open = false;
                        force_update();
                    }
                }
                SameLine();

                if (Button("取消"))
                    open = false;

                End();

                return open;
            }, (create_context, )
        );
    }
    
    // 支持作为图片格式的拓展名
    let IMAGE_FILE_EXTERN_NAMES = [".png", ".jpg", ".bmp", ".psd",];

    // 用于储存文件拓展名和图标的对应关系
    let FILE_TYPE_ICONS = {
        [".png"] = je::graphic::texture::load(F"!/builtin/icon/TextureFile.png")->val,
        [".jpg"] = je::graphic::texture::load(F"!/builtin/icon/TextureFile.png")->val,
        [".bmp"] = je::graphic::texture::load(F"!/builtin/icon/TextureFile.png")->val,
        [".psd"] = je::graphic::texture::load(F"!/builtin/icon/TextureFile.png")->val,
        [".shader"] = je::graphic::texture::load(F"!/builtin/icon/ShaderFile.png")->val,
        [".jemodule4"] = je::graphic::texture::load(F"!/builtin/icon/CppProgram.png")->val,
        [".jecache4"] = je::graphic::texture::load(F"!/builtin/icon/JoyEngineCSP-Dev.png")->val,
        [".jeworld"] = je::graphic::texture::load(F"!/builtin/icon/World.png")->val,
        [".jewo"] = je::graphic::texture::load(F"!/builtin/icon/Plugins.png")->val,
        [".jeanim4"] = je::graphic::texture::load(F"!/builtin/icon/AnimationFile.png")->val,
        
        // 欸嘿还没做呢，先拿joy顶一下
        [".jepartical"] = je::graphic::texture::load(F"!/builtin/icon/joyengine.png")->val,
    };

    // 根据文件拓展名返回文件的类型
    private func get_file_icon_by_extern_name(_path: PathInfo)
    {
        static let default_path_icon 
            = je::graphic::texture::load(F"!/builtin/icon/FilePath.png")->val;
        static let default_file_icon 
            = je::graphic::texture::load(F"!/builtin/icon/File.png")->val;

        let icon = FILE_TYPE_ICONS->get(_path.externname);

        match (icon)
        {
        none?
        {
            match (_path.type->get)
            {
            dir(_)?
                return default_path_icon;
            file?
                return default_file_icon;
            }
        }
        value(i)? return i;
        }
    }

    union PathType
    {
        dir(option<array<PathInfo>>),
        file,
    }

    public using PathInfo = struct {
        path        : filesys::path_t,   // 当前目录/文件的目录
        name        : string,
        externname  : string,
        type        : mutable<PathType>, // 类型，如果是目录，则还包含目录内的子项    
    }
    {
        func should_hide(self: PathInfo)
        {
            static let HIDING_FILE_TYPE = [".jecache4"];
            
            if (editor_need_hiding_file)
                return HIDING_FILE_TYPE->find(self.externname) != -1;
            return false;
        }
        func isdir(self : PathInfo)
        {
            match (self.type->get)
            {
            dir(_)? return true;
            file? return false;
            }
        }
        func indir(self : PathInfo, functor: (option<array<PathInfo>>)=>void)
        {
            match (self.type->get)
            {
            dir(subdirs)? functor(subdirs);
            file?;
            }
            return self;
        }
        func infile(self : PathInfo, functor: ()=>void)
        {
            match (self.type->get)
            {
            dir(subdirs)?;
            file? functor();
            }
            return self;
        }
        func childs(self : PathInfo, force_update: bool)
        {
            // 如果没有要求强制更新，有现成的就用现成的
            match (self.type->get)
            {
            dir(_dir)?
                match(_dir)
                {
                value(subdirs)?
                    if (!force_update)
                        return subdirs;
                none?;
                }
            file? // 文件也来获取子目录，搁这儿找茬呢？
                std::panic("Failed to get subpath: is a file.");
            }

            // 当前目录的子项目尚未获取，在这里获取一下塞进去
            let sublist = 
                filesys::subpath(self.path)
                    ->unwarp
                    ->map(\current_subpath = PathInfo{
                        path = current_subpath, 
                        name = filesys::filename(current_subpath),
                        externname = filesys::extension(current_subpath),
                        type = mutable::create(filesys::isdir(current_subpath)?
                                PathType::dir(option::none) | PathType::file),
                    };);

            self.type->set(PathType::dir(option::value(sublist)));
            return sublist;
        }
        func get_open_method(self: PathInfo)
        {
            static let registed_open_method = {
                [".jeworld"] = 
                    \p: PathInfo, context: EditorContext = 
                        ow->has
                        ? ow =>> \w = context->get_project->reset_editing_world(w)->error;
                        | option::value("无法加载世界")                      
                        where ow = context->get_project->load_world(p.path)
                    ;,
                [".jeanim4"] = 
                    func(p: PathInfo, context: EditorContext)
                    {
                        match (animation2d::AnimationContext::open(p.path))
                        {
                        ok(ctx)?
                            {
                                animation2d::show(context, ctx);
                                return option::none;
                            }
                        err(_)?
                            return option::value(F"无法打开和编辑帧动画文件：{p.path}");
                        }
                    },
                [".jepartical"] = 
                    func (p: PathInfo, context: EditorContext)
                    {
                        match (particalbaker::ParticalContext::load(p.path))
                        {
                        value(ctx)?
                            {
                                particalbaker::show(context, ctx);
                                return option::none;
                            }
                        none?
                            return option::value(F"无法打开和编辑粒子动画文件：{p.path}");
                        }
                    }
            };

            return registed_open_method
                ->  get(self.externname->lower)
                ->  valor(
                        \p, _ = result == 0 
                            ? option::none
                            | option::value(F"文件 '{p.path}' 打开失败({result})")
                            where result = std::shell(p.path->tostring())
                        ;
                    );
        }
    }

    static let mut current_work_path = "";        

    func set_current_work_path(path: filesys::path_t)
    {
        assert(filesys::isdir(path));
        current_work_path = path->tostring();
    }

    enum Action
    {
        Nothing,
        Click,
        DoubleClick,
        RightClick,
    }

    func write_file_if_not_exist(path: filesys::path_t, content: string)
    {
        if (filesys::exist(path))
            return false;
        return filesys::writeall(path, content);
    }

    func context_menu(path: option<PathInfo>, context: EditorContext)
    {
        let mut shown_context = false;
        if (path
            ->map(\_ = BeginPopupContextItem();)
            ->or(\ = BeginPopupContextWindow();))
        {
            if (BeginMenu(F"新建..."))
            {
                if (MenuItem(F"目录"))
                    jeapi::gui::form::input("新建目录", F"在{current_work_path}新建目录", "NewDir",
                        \dirname: string = filesys::mkdir(filesys::normalize(current_work_path) / dirname)
                            ->map(\_ = force_update();)
                            ->or(\errid = jeapi::gui::form::errmsg("失败", F"创建目录失败{errid}");););
                if (MenuItem(F"空文件"))
                {
                    jeapi::gui::form::input("新建空文件", F"在{current_work_path}新建空文件", "NewFile.txt",
                        \filename: string = filesys::exist(file_path)
                            ? jeapi::gui::form::errmsg("创建空文件失败", "同名文件已经存在")
                            | write_file_if_not_exist(file_path, "") 
                                ? force_update()
                                | jeapi::gui::form::errmsg("创建空文件失败", "无法创建文件，可能是文件名非法或磁盘已满")
                        where file_path = filesys::normalize(current_work_path) / filename;);
                }
                Separator();
                if (MenuItem(F"世界"))
                {
                    jeapi::gui::form::input("创建世界", F"将在{current_work_path}创建新世界：",
                        "Newworld",
                        \new_world_name = launch(
                            edit_forms::show_world_creator, (context, edit_forms::WorldContext::create(
                                context->get_project(), new_world_name, filesys::normalize(F"{current_work_path}/{new_world_name}.jeworld"),
                                func (w)
                                {
                                    if (context->get_project()->serialize_world(w)
                                            ->> \wdat = write_file_if_not_exist(
                                                filesys::normalize(F"{current_work_path}/{new_world_name}.jeworld"), 
                                                wdat as dict<string, dynamic>: string)
                                                ;
                                            ->  valor(false)
                                        == false)
                                    {
                                        jeapi::gui::form::errmsg("创建世界失败", "无法创建文件，可能是文件名非法或磁盘已满");
                                        return false;
                                    }
                                    force_update();
                                    return true;
                                }
                            )));
                        ); 
                }
                Separator();
                if (BeginMenu(F"纹理"))
                {
                    if (MenuItem(F"空白纹理"))
                        create_image("White", current_work_path, func(img){
                            let (w, h) = img->size;
                            for (let mut x = 0 ; x < w; x += 1)
                                for (let mut y = 0 ; y < h; y += 1)
                                    img->setpix((x, y), (1., 1., 1., 1.));
                        });
                    if (MenuItem(F"透明纹理"))
                        create_image("Empty", current_work_path, func(img){
                            let (w, h) = img->size;
                            for (let mut x = 0 ; x < w; x += 1)
                                for (let mut y = 0 ; y < h; y += 1)
                                    img->setpix((x, y), (0., 0., 0., 0.));
                        });
                    if (MenuItem(F"文本纹理"))
                        create_font_image(context->get_project(), "Text", current_work_path);
                        
                    EndMenu();
                }
                Separator();
                if (BeginMenu("着色器脚本"))
                {
                    static let editor_origin_shaders = [
                        ("单色", "MonoColor"),
                        ("无光", "Unlit"),
                        ("2D光照", "Forward2D"),
                        ("2D光照法线", "Forward2DNormal"),
                        ("2D光照自发光", "SelfGrowingForward2D"),
                        ("2D光照自发光法线", "SelfGrowingForward2DNormal"),
                        ("2D点光源（光源）", "Light2DPoint"),
                        ("2D平行光源（光源）", "Light2DParallel"),
                        ("2D光照后处理（摄像机）", "Light2DCameraPass"),
                        ("2D光照外发光后处理（摄像机）", "Light2DCameraBloomPass"),
                    ];

                    let create_shader_at = func(shader_name: string, shader_src: string)
                    {
                        let shader_path = filesys::normalize(F"{current_work_path}/{shader_name}.shader");
                        if (!write_file_if_not_exist(shader_path, shader_src))
                            jeapi::gui::form::errmsg("创建着色器失败", F"无法写入{shader_path}");
                        else
                            force_update();
                    };

                    for (let _, (shader_display_name, shader_path_name) : editor_origin_shaders)
                        if (MenuItem(shader_display_name))
                            jeapi::gui::form::input("创建着色器", F"将在{current_work_path}创建{shader_display_name}：",
                                shader_path_name,
                                \shader_name: string = 
                                    filesys::readall(filesys::normalize(F"{std::exepath()}/builtin/shader/{shader_path_name}.shader"))
                                        ->> \src = create_shader_at(shader_name, src);
                                        ->  or(\ = je::logerr(F"打开内置着色器文件{shader_path_name}失败，请检查编辑器目录");)
                                    ;
                                ); // end of inputbox
                  
                    EndMenu();
                }
                if (BeginMenu("动画"))
                {
                    if (MenuItem("2D帧序列"))
                    {
                        jeapi::gui::form::input("新建2D帧动画", F"在{current_work_path}新建动画", "NewAnimation",
                            func (filename)
                            {
                                let path = filesys::normalize(current_work_path) / F"{filename}.jeanim4";
                                if (filesys::exist(path))
                                    jeapi::gui::form::errmsg("创建2D帧动画失败", "可能是同名文件已经存在或文件名路径不合法");
                                else
                                {
                                    assert(animation2d::AnimationContext::create(path)->save);
                                    force_update();
                                }
                            });
                    }
                    if (MenuItem("粒子动画"))
                    {
                        jeapi::gui::form::input("新建粒子动画", F"在{current_work_path}新建动画", "NewPartical",
                            func (filename)
                            {
                                let path = filesys::normalize(current_work_path) / F"{filename}.jepartical";
                                if (filesys::exist(path))
                                    jeapi::gui::form::errmsg("创建粒子动画失败", "可能是同名文件已经存在或文件名路径不合法");
                                else
                                {
                                    assert(particalbaker::ParticalContext::create(path)->save);
                                    force_update();
                                }
                            });
                    }
                    EndMenu();
                }
                if (MenuItem(F"C++模块"))
                {
                    // 创建C++模块，就跟JoyEngineCSP差不多
                    jeapi::gui::form::input("创建C++模块", F"将在{current_work_path}创建，请为项目命名：", "CppModule", 
                        \module_name: string = CxxProject::start(module_name, current_work_path, context->get_project)
                            ->> \ _ = force_update();
                            ->or(\reason = jeapi::gui::form::errmsg("创建C++模块失败", reason);)
                            ;
                        );
                }
                EndMenu();
            }

            Separator();

            do path
                ->> \p = file_item_menu(p, context);
                ->> \_ = Separator();
                ;
                        
            if (MenuItem("在资源管理器中显示"))
                do std::shell(F"explorer \"{filesys::normalize(current_work_path)->tostring->replace("/", "\\")}\"");

            if (MenuItem(F"刷新"))
                force_update();

            EndPopup();
        }
    }

    func crc_path(path: filesys::path_t)
    {
        // 给定一个路径，计算整个路径的全部crc
        using filesys;
        using je::editor;
        let normalized_path = path;
        let pure_path = 
            \p: string = p->beginwith(normalized_path->tostring()) 
                ? p->sub(normalized_path->tostring()->len)
                | p
            ;
        ;

        func debug(msg)
        {
            std::println(msg);
            return msg;
        }

        return normalized_path
            -> allsubpath()
            -> okay
            =>> \childs = childs
                ->> \child = isfile(child)
                    ? filesys::filename(filesys::normalize(pchild)) + crc64file(child->tostring)->val: string 
                    | pchild
                    where pchild = pure_path(child->tostring);
                ->  reduce(\l, r = l + r;)
                ->> \str = crc64str(str);
                ;
            ->  val;
    }

    func try_update_recompile(module: CxxProject)
    {
        // 检查一下引擎的提供的文件，确认是否需要重新编译
        let engine_path_crc64 = crc_path(CxxProject::ENGINE_HEADER_PATH);
        let specify_module_path_crc64 = crc_path(module.path/"engine"/"include");

        if (engine_path_crc64 == specify_module_path_crc64)
        {
            module->update_compile(je::editor::platform());
        }
        else
        {
            jeapi::gui::form::ask("模块头文件版本不一致", F"模块{module.path}\n的引擎头文件在尝试重新编译时检测到了不一致。\n是否需要更新？",
                func(choice)
                {
                    if (choice)
                    {
                        let update_result = 
                            CxxProject::update_engine_file(module.path)
                                =>> \r = CxxProject::generate_module_config(module.project, module.name, module.path, r);;
                        if (!update_result->isok)
                        {
                            jeapi::gui::form::errmsg("重新编译失败", F"{module.path}更新引擎文件失败：\n{update_result->error->val}");
                            return;
                        }
                    }
                    else; // 点NO 啥也不干~
                    module->update_compile(je::editor::platform());
                });
        }
    }
    public func update_shader(context: EditorContext, path: string)
    {
        // 从universe中获取所有world，更新world中所有实体的shader
        do context->get_project->get_env->get_universe
            ->  editor::get_all_worlds
            ->> \w: je::world = w
                ->  editor::get_all_entities
                ->> \e: je::entity = 
                    e->editor::graphic::try_reload_shaders(shader_path, shader_path)
                        where shader_path = context->get_project->make_path_normalize(filesys::normalize(path))
                    ;
                ;
            ;
    }
    func file_item_menu(path: PathInfo, context: EditorContext)
    {
        let NOT_MODIFIABLE_FILES = [".jeproj4", ".jemodule4"];
        let is_modifiable_file = NOT_MODIFIABLE_FILES->find(path.externname) == -1;

        if (path.externname == ".shader")
        {
            if (MenuItem(F"更新此着色器"))
            {
                update_shader(context, path.path->tostring());
            }
            Separator();
        }
        else if (path.externname == ".jemodule4")
        {
            if (MenuItem(F"重新编译此模块"))
            {
                match (context->get_project->get_module(path.path))
                {
                value(module)?
                    try_update_recompile(module);
                none?
                    jeapi::gui::form::ask("是否加载此模块？", 
                        F"正在要求重新编译模块{path.path}\n但此模块尚未被加载。\n是否现在加载并重新编译？",
                        func (sure: bool)
                        {
                            if (!sure) return;
                            match (CxxProject::open_for_loading(path.path, context->get_project))
                            {
                            ok(module)?
                                try_update_recompile(module);
                            err(reason)?
                                jeapi::gui::form::errmsg("加载模块失败", reason);
                            }
                        });
                }
                    
            }
            if (MenuItem(F"组件/系统..."))
            {
                let components = filesys::subpath(path.path/"components")
                        ->map(\s = s
                             ->forall(\f = filesys::extension(f) == ".hpp";)
                             ->map(\f = fname->subto(0, fname->len - 4)
                                where fname = filesys::filename(f);)
                            ;)
                        ->or(\_=[];)
                        ->tovec;
                let systems = filesys::subpath(path.path/"systems")
                    ->okay
                    ->map(\s = s
                         ->forall(\f = filesys::extension(f) == ".hpp";)
                         ->map(\f = fname->subto(0, fname->len - 4)
                            where fname = filesys::filename(f);)
                        ;)
                    ->valor([])
                    ->tovec;

                func _wrap_path(path: string)
                {
                    // 根据不同平台，如果路径包含空白分割字符或需要在shell里转义的字符什么的，这里包一下
                    if (path->find(" ") != -1 || path->find("\t") != -1)
                        return F"\"{path}\"";
                    return path;
                }

                let display_usable_component = func(s: string)
                {
                    do Selectable(s);
                    if (BeginPopupContextItem())
                    {
                        let file_path = path.path/"components"/F"{s}.hpp";

                        if (MenuItem("在VSCode中打开"))
                            do std::shell(F"code {_wrap_path(path.path->tostring())} {_wrap_path(file_path->tostring)}");
                        if (MenuItem("移除此组件"))
                            jeapi::gui::form::ask("确认移除组件？", F"是否从模块{filesys::filename(path.path)}中移除组件{s}?",
                                func(sure: bool){
                                    if (!sure) return;
                                    do components->remove(components->find(s));
                                    do filesys::remove(file_path)->unwarp;
                                });
                        EndPopup();
                    }
                };

                let display_usable_system = func(s: string)
                {
                    do Selectable(s);
                    if (BeginPopupContextItem())
                    {
                        let file_path = path.path/"systems"/F"{s}.cpp";

                        if (MenuItem("在VSCode中打开"))
                            do std::shell(F"code {_wrap_path(path.path->tostring)} {_wrap_path(file_path->tostring)}");
                        if (MenuItem("移除此系统"))
                            jeapi::gui::form::ask("确认移除系统？", F"是否从模块{filesys::filename(path.path)}中移除系统{s}?",
                                func(sure: bool){
                                    if (!sure) return;

                                    do systems->remove(systems->find(s));
                                    do filesys::remove(path.path/"systems"/F"{s}.hpp")->unwarp;
                                    do filesys::remove(file_path)->unwarp;
                                });
                        EndPopup();
                    }
                };

                launch(func(mut open: bool)
                {
                    open = BeginAttrOpen(F"模块{filesys::filename(path.path)}当前组件和系统", 
                        WindowsAttribute::ImGuiWindowFlags_MenuBar);
                    if (BeginMenuBar())
                    {
                        if (BeginMenu("创建..."))
                        {
                            if (MenuItem("新系统"))
                                jeapi::gui::form::input("创建新系统", F"为模块{filesys::filename(path.path)}创建系统", "NewSystem",
                                    func(name: string)
                                    {
                                        if (systems->find(name) != -1)
                                        {
                                            jeapi::gui::form::errmsg("创建系统失败", F"模块{filesys::filename(path.path)}已经存在一个同名系统");
                                            return;
                                        }

                                        let system_header = 
@"#include "jeecs.hpp"

namespace $$MODULE_NAME$$
{
    struct $$SYSTEM_NAME$$ : public jeecs::game_system
    {
        $$SYSTEM_NAME$$(jeecs::game_world world);
        void PreUpdate();
        void Update();
        void LateUpdate();
    };
}
"@;
                                    let system_src = 
@"#include "$$SYSTEM_NAME$$.hpp"

using namespace std;
using namespace jeecs;

namespace $$MODULE_NAME$$
{
    $$SYSTEM_NAME$$::$$SYSTEM_NAME$$(game_world world)
        : game_system(world)
    {
        
    }

    void $$SYSTEM_NAME$$::PreUpdate()
    {

    }

    void $$SYSTEM_NAME$$::Update()
    {

    }

    void $$SYSTEM_NAME$$::LateUpdate()
    {

    }
}
"@;
                                        let module_name = filesys::purename(path.path);
                                        let system_name = name;

                                        if (!filesys::writeall(path.path/"systems"/F"{system_name}.hpp", 
                                            system_header
                                                ->replace("$$MODULE_NAME$$", module_name)
                                                ->replace("$$SYSTEM_NAME$$", system_name))
                                            ||
                                            !filesys::writeall(path.path/"systems"/F"{system_name}.cpp", 
                                            system_src
                                                ->replace("$$MODULE_NAME$$", module_name)
                                                ->replace("$$SYSTEM_NAME$$", system_name))
                                            )
                                        {
                                            do filesys::remove(path.path/"systems"/F"{system_name}.hpp")->unwarp;
                                            do filesys::remove(path.path/"systems"/F"{system_name}.cpp")->unwarp;

                                            jeapi::gui::form::errmsg("创建系统失败", "无法创建和写入系统源文件");
                                        }
                                        else
                                        {
                                            jeapi::gui::form::errmsg("创建系统成功", "系统已创建到\n" 
                                                + F"{path.path}/systems/{system_name}.hpp\n"
                                                + F"{path.path}/systems/{system_name}.cpp");
                                            systems->add(system_name);
                                        }
                                    });
                            //End of create new system
                            if (MenuItem("新组件"))
                                jeapi::gui::form::input("创建新组件", F"为模块{filesys::filename(path.path)}创建组件", "NewComponent",
                                    func(name: string)
                                    {
                                        if (components->find(name) != -1)
                                        {
                                            jeapi::gui::form::errmsg("创建组件失败", F"模块{filesys::filename(path.path)}已经存在一个同名组件");
                                            return;
                                        }

                                        let component_header = 
@"#include "jeecs.hpp"

namespace $$MODULE_NAME$$
{
    struct $$COMPONENT_NAME$$
    {
        static void JERefRegsiter()
        {
            using namespace jeecs;

            // Register member in this function.
            // e.g. typing::register_member(&$$COMPONENT_NAME$$::member, "member");
        }
    };
}
"@;
                                        let module_name = filesys::purename(path.path);
                                        let component_name = name;

                                        if (!filesys::writeall(path.path/"components"/F"{component_name}.hpp", 
                                            component_header
                                                ->replace("$$MODULE_NAME$$", module_name)
                                                ->replace("$$COMPONENT_NAME$$", component_name))
                                            )
                                        {
                                            do filesys::remove(path.path/"components"/F"{component_name}.hpp")->unwarp;
                                            jeapi::gui::form::errmsg("创建组件失败", "无法创建和写入组件源文件");
                                        }
                                        else
                                        {
                                            jeapi::gui::form::errmsg("创建组件成功", "组件已创建到\n" 
                                                + F"{path.path}/components/{component_name}.hpp");
                                            components->add(component_name);
                                        }
                                    });
                            // End of create new component
                            EndMenu();
                        }
                        EndMenuBar();
                    }

                    let (available_width, _) = GetContentRegionAvail();

                    BeginGroup();
                    Text("系统");
                    let (_, avaliable_height) = GetContentRegionAvail();

                    if (BeginListBox("##1", available_width/2.-0.5, avaliable_height))
                    {
                        do systems->> \s = display_usable_system(s);;
                        EndListBox();
                    }
                    EndGroup();

                    SameLine();

                    BeginGroup();
                    Text("组件");
                    let (_, avaliable_height2) = GetContentRegionAvail();
                    if (BeginListBox("##2", available_width/2.-0.5, avaliable_height2))
                    {
                        do components->> \s = display_usable_component(s);;
                        EndListBox();
                    }
                    EndGroup();

                    End();

                    return open;
                }, (true,));
            }
            Separator();
        }    
        else if (IMAGE_FILE_EXTERN_NAMES->find(path.externname) != -1)
        {
            // 是图片，在这里编辑图片的采用方法等数据
            if (MenuItem("编辑图片"))
            {
                using je::editor;
                let image_samping_method = je::editor::get_texture_sampling_method_by_path(path.path->tostring);

                drawpannel::modify_sampling_method(path.path->tostring, image_samping_method, 
                    \method = do je::editor::update_texture_sampling_method_by_path(path.path->tostring, method););
            }
            if (MenuItem("更新此图片"))
            {
                std::panic("TODO");
            }
            Separator();
        }

        // 下面是通用的选项
        if (MenuItem("复制路径"))
        {
            SetClipboardText(path.path->tostring);
        }
        if (MenuItemEnabled("复制文件", is_modifiable_file))
        {
            let path = path.path;
            let mut target_path = filesys::parent(path) / (filesys::purename(path) + "(1)" + filesys::extension(path));

            for (let mut n = 2; ; n += 1)
                if (filesys::exist(target_path))
                    target_path = filesys::parent(path) / (filesys::purename(path) + F"({n})" + filesys::extension(path));
                else break;

            match (filesys::copy(path, target_path))
            {
            ok(_)?
                force_update();
            err(errid)?
                jeapi::gui::form::errmsg("失败", F"复制文件失败({errid})");
            }
        }
        if (MenuItemEnabled("重命名", is_modifiable_file))
        {
            jeapi::gui::form::input("重命名", F"请输入{path.path}的新名称", F"{path.name}", 
                \newname: string = filesys::move(path.path, filesys::parent(path.path)/newname)
                    ->> \_ = force_update();
                    ->or(\errid = jeapi::gui::form::errmsg("失败", F"重命名失败({errid})");););
        }
        if (MenuItemEnabled("删除", is_modifiable_file))
        {
            jeapi::gui::form::ask(F"删除{path.path}", F"是否继续删除{path.path}",
                func(sure: bool)
                {
                    if (!sure) return;
                    do filesys::remove(path.path)
                        ->> \_ = force_update();
                        ->  or(\errid = jeapi::gui::form::errmsg("失败", F"删除失败({errid})");)
                        ;
                });
        }        
    }

    // 带图标的文件按钮
    func FileIcon(path: PathInfo, context: EditorContext)=> Action
    {
        BeginGroup();
            PushIDStr(path.path->tostring);
                let clicked = ImageButtonSize(get_file_icon_by_extern_name(path), 32., 32.);
            PopID();
            let right_click = IsItemClicked(ImGuiMouseButton::ImGuiMouseButton_Right);
            context_menu(option::value(path), context);
            if (BeginDragDropSource())
            {
                let ppath = context->get_project()->make_path_normalize(path.path);
                do SetDragDropPayload("JEDITOR_FILE_PATH", ppath);
                    Text(F"File: {ppath}");
                EndDragDropSource();
            }

            SameLine();
            Text(path.name);
        EndGroup();

        static let mut _last_click_time = std::time();

        if(clicked)
        {
            let _current_click_time = std::time();
            if (_current_click_time - _last_click_time < 0.2)
                return Action::DoubleClick;

            _last_click_time = _current_click_time;
            return Action::Click;
        }
        else if (right_click)
            return Action::RightClick;
        
        return Action::Nothing;
    }

    static let mut force_update_file_group_flag = false;
    static let mut force_update_dir_tree_flag = false;
    // 刷新显示的目录信息等...
    public func force_update()
    {
        force_update_dir_tree_flag = true;
        force_update_file_group_flag = true;
    }

    // 右边的文件详情等信息
    func files_group(context: EditorContext)
    {
        static let mut new_showing_path = "";
        static let mut now_item_in_path = []: array<PathInfo>;
        if (new_showing_path != current_work_path || force_update_file_group_flag)
        {
            new_showing_path = current_work_path;
            force_update_file_group_flag = false;
   
            func compare_method (a: PathInfo, b: PathInfo)
            {
                func is_dir(p){match(p.type->get){dir(_)?return true;file?return false;}}
                if (is_dir(a))
                    return !is_dir(b);
                else if (is_dir(b))
                    return false;

                if (a.externname != b.externname)
                    return a.externname < b.externname;
                return a.name < b.name;
            }

            now_item_in_path =
                filesys::subpath(filesys::normalize(current_work_path))
                    ->  unwarp
                    ->> \subpath = PathInfo{ 
                            path = subpath,
                            name = filesys::filename(subpath),
                            externname = filesys::extension(subpath),
                            type = mutable::create(filesys::isdir(subpath)
                                ? PathType::dir(option::none) 
                                | PathType::file),
                        };
                    ->std::sort(compare_method)
                    ;
        }

        do BeginChild("files_list");
            context_menu(option::none, context);
            do now_item_in_path
                -> forall(\item = !item->should_hide;)
                ->> \item = 
                    action == Action::Click 
                    ? (nil: void)
                    | action == Action::DoubleClick ? 
                        (item
                            ->indir(\_ = set_current_work_path(item.path);)
                            ->infile(\ = do item->get_open_method()(item, context)
                                        ->> \err = jeapi::gui::form::errmsg("失败", F"打开文件失败:\n{err}");
                                    ;)
                        ): void
                    | (nil: void) // get void
                    where action = FileIcon(item, context);
                ; 
        EndChild();
    }

    // 左侧的目录概况
    func path_tree(context: EditorContext)
    {
        let root_path = 
            context->get_project.m_path;

        if (current_work_path == "")
            current_work_path = root_path->tostring();

        static let _root = PathInfo {
                path = root_path,
                name = filesys::filename(root_path),
                externname = filesys::extension(root_path),
                type = mutable::create(PathType::dir(option::none)),
            };

        if (force_update_dir_tree_flag)
        {
            force_update_dir_tree_flag = false;

            // 强制更新，直接把缓存的子目录全部干掉
            _root.type->set(PathType::dir(option::none));
        }

        // 用于递归展示所有子目录等
        func _show_paths(path: PathInfo)
        {
            match (path.type->get)
            {
            PathType::dir(subpath)?
            {
                let mut attribute = TreeNodeAttribute::ImGuiTreeNodeFlags_OpenOnArrow 
                                + TreeNodeAttribute::ImGuiTreeNodeFlags_OpenOnDoubleClick 
                                + TreeNodeAttribute::ImGuiTreeNodeFlags_SpanAvailWidth;
                if (current_work_path == path.path->tostring)
                    attribute += TreeNodeAttribute::ImGuiTreeNodeFlags_Selected;

                let show_child = TreeNodeEx(F"{path.name}##p", attribute);
                if (IsItemClickedLeft() && !IsItemToggledOpen())
                    current_work_path = path.path->tostring;

                if (show_child)
                {
                    for (let _, subpath : path->childs(false))
                        _show_paths(subpath);

                    TreePop();
                }
                else
                    // 如果目录被折叠起来，则删除缓存，等待下次展开时重新获取
                    path.type->set(PathType::dir(option::none));
            }
            PathType::file?
                ; // path_tree只显示目录，跳过文件
            }
        }

        do BeginChildSize("path_tree", 200., 0.);
            _show_paths(_root);
        EndChild();
    }

    public func show_browser(context: EditorContext, show: mutable<bool>)
    {
        if (show->get)
        {
            je::gui::SetNextWindowSizeConstraints((500., 200.), (2000., 1100.));
            do show->set(BeginAttrOpen("资源管理器", WindowsAttribute::ImGuiWindowFlags_NoBringToFrontOnFocus));
                path_tree(context);
                SameLine();
                BeginGroup();
                    do BeginChildSize("tools_bar", 0., 40.);
                        // TODO 此处放一些返回上一层之类的按钮
                        if (Button("U"))
                            current_work_path = filesys::parent(filesys::normalize(current_work_path))->tostring;
                        SameLine();
                        Text(current_work_path);
                    EndChild();
                    files_group(context);
                    
                EndGroup();
            End();
        }
    }
}

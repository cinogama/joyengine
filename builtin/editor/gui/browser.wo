import woo::std;
import woo::shell;

import je;
import je::gui;
import je::internal;
import je::towoo;
import je::towoo::components;
import je::towoo::types;

import pkg::image;
import pkg::fsys;
import pkg::worst;
import pkg::thread;

import builtin::editor::project::main;
import builtin::editor::cpp::main;
import builtin::editor::gui::animation2d;
import builtin::editor::gui::particalbaker;
import builtin::editor::gui::workflow;
import builtin::editor::gui::refactor;
import builtin::editor::gui::form::msg;
import builtin::editor::gui::form::input;
import builtin::editor::gui::form::ask;
import builtin::editor::gui::main;
import builtin::editor::environment::main;
import builtin::editor::dbg::main;
import builtin::api::serialize::main;
import builtin::editor::gui::tilemap::main;
import builtin::editor::gui::edit_forms::world_creator;
import builtin::editor::gui::draw_pannel::main;

using je::gui;

namespace editor::gui
{
    func _wrap_path(path: string)
    {
        // 根据不同平台，如果路径包含空白分割字符或需要在shell里转义的字符什么的，这里包一下
        if (path->find(" ")->is_value || path->find("\t")->is_value)
            return F"\"{path}\"";
        return path;
    }
    
    public let mut editor_need_hiding_file = true;
    
    func create_font_image(proj: Project, default_name: string, location: string)
    {
        let fonts = fsys::allsubpath(proj->get_path/"resource"/"font")
            -> or([])
            -> forall(\path = fsys::isfile(path) && fsys::extension(path)->lower == ".ttf";)
            ->> \path = proj->make_path_normalize(path);
            ;
            
        if (fonts->empty)
        {
            jeapi::gui::form::errmsg("失败", "没有在 @/resource/font 找到有效的字体");
            return;
        }
        
        let create_context = (mut default_name, mut "Helloworld", mut option::none: option<int>, mut 16);
        launch(func(){
                let mut open = true;
                je::gui::SetNextWindowSizeConstraints((350., 200.), (350., 200.));
                if (Begin(F"在{location}创建纹理"))
                {
                    Text("文件名");
                    create_context[0] = InputText("##imagename", create_context[0])->or(create_context[0]);
                    
                    Separator();
                    
                    Text("字体");
                    SameLine();
                    do Combo("##fontname", fonts, create_context[2])
                        ->> \new_idx = create_context[2] = option::value(new_idx);
                        ;
                        
                    SameLine();
                    do InputInt("##fontsize", create_context[3])->>func(new_size){
                        if (new_size > 0)
                            create_context[3] = new_size;
                    };
                    
                    let (w, h) = GetContentRegionAvail();
                    create_context[1] = InputTextMultilineSize("##imagetext", create_context[1], w, h - 30.)
                        ->or(create_context[1]);
                        
                    if (create_context[2]->is_value && Button("创建"))
                    {
                        match (je::graphic::font::load(fonts[create_context[2]->unwrap], create_context[3]))
                        {
                            value(font_instance)?
                            {
                                let tex = font_instance->load_string(create_context[1]);
                                // 创建image，然后保存！
                                let (tw, th) = tex->size();
                                let img = new! image(tw, th);
                                for (let mut ix = 0; ix < tw; ix += 1)
                                    for (let mut iy = 0; iy < th; iy += 1)
                                        img->setpix((ix, iy), tex->pix((ix, iy))->get_color());
                                        
                                let aimpath = F"{location}/{create_context[0]}.png";
                                if (!img->save(aimpath))
                                    jeapi::gui::form::errmsg("创建失败", F"无法写入{aimpath}");
                                else
                                {
                                    open = false;
                                    force_update();
                                }
                            }
                            none?
                                jeapi::gui::form::errmsg("失败", F"无法打开字体：{fonts[create_context[2]->unwrap]}");
                        }
                    }
                    SameLine();
                    if (Button("取消"))
                        open = false;
                }
                End();
                
                return open;
            });
    }
    
    func create_image(default_name: string, location: string, generator: (image)=> void)
    {
        let context = (mut 16, mut 16, mut default_name);
        launch(
            func()
            {
                let mut open = true;
                je::gui::SetNextWindowSizeConstraints((300., 200.), (300., 200.));
                if (Begin(F"在{location}创建纹理"))
                {
                    Text("文件名");
                    context[2] = InputText("##imagename", context[2])->or(context[2]);
                    
                    Separator();
                    
                    Text("宽");
                    SameLine();
                    context[0] = InputInt("##width", context[0])->or(context[0]);
                    
                    Text("高");
                    SameLine();
                    context[1] = InputInt("##height", context[1])->or(context[1]);
                    
                    if (Button("创建"))
                    {
                        let img = new! image(context[0], context[1]);
                        
                        generator(img);
                        
                        let aimpath = F"{location}/{context[2]}.png";
                        if (!img->save(aimpath))
                            jeapi::gui::form::errmsg("创建失败", F"无法写入{aimpath}");
                        else
                        {
                            open = false;
                            force_update();
                        }
                    }
                    SameLine();
                    
                    if (Button("取消"))
                        open = false;
                }
                End();
                
                return open;
            }
        );
    }
    
    // 支持作为图片格式的拓展名
    public let IMAGE_FILE_EXTERN_NAMES = [".png", ".jpg", ".bmp", ".psd",];
    
    // 用于储存文件拓展名和图标的对应关系
    let FILE_TYPE_ICONS = {
        [".png"] = je::graphic::texture::load(option::none, F"!/builtin/icon/TextureFile.png")->unwrap,
        [".jpg"] = je::graphic::texture::load(option::none, F"!/builtin/icon/TextureFile.png")->unwrap,
        [".bmp"] = je::graphic::texture::load(option::none, F"!/builtin/icon/TextureFile.png")->unwrap,
        [".psd"] = je::graphic::texture::load(option::none, F"!/builtin/icon/TextureFile.png")->unwrap,
        
        [".ttf"] = je::graphic::texture::load(option::none, F"!/builtin/icon/Font.png")->unwrap,
        
        [".wav"] = je::graphic::texture::load(option::none, F"!/builtin/icon/Music.png")->unwrap,
        
        [".wo"] = je::graphic::texture::load(option::none, F"!/builtin/icon/Plugins.png")->unwrap,
        
        [".shader"] = je::graphic::texture::load(option::none, F"!/builtin/icon/ShaderFile.png")->unwrap,
        
        [".je4module"] = je::graphic::texture::load(option::none, F"!/builtin/icon/CppProgram.png")->unwrap,
        [".je4workflow"] = je::graphic::texture::load(option::none, F"!/builtin/icon/InputPin.png")->unwrap,
        
        [".je4world"] = je::graphic::texture::load(option::none, F"!/builtin/icon/World.png")->unwrap,
        [".je4entity"] = je::graphic::texture::load(option::none, F"!/builtin/icon/Entity.png")->unwrap,
        
        [".je4animation"] = je::graphic::texture::load(option::none, F"!/builtin/icon/AnimationFile.png")->unwrap,
        
        [".je4tilemap"] = je::graphic::texture::load(option::none, F"!/builtin/icon/Tilemap.png")->unwrap,
        [".je4partical"] = je::graphic::texture::load(option::none, F"!/builtin/icon/Partical.png")->unwrap,
        
        [".je4cache"] = je::graphic::texture::load(option::none, F"!/builtin/icon/Joy.png")->unwrap,
    };
    
    // 根据文件拓展名返回文件的类型
    private func get_file_icon_by_extern_name(_path: PathInfo, context: EditorContext)
    {
        static let default_path_icon
            = je::graphic::texture::load(option::none, F"!/builtin/icon/FilePath.png")->unwrap;
        static let default_file_icon
            = je::graphic::texture::load(option::none, F"!/builtin/icon/File.png")->unwrap;
            
        let mut icon = FILE_TYPE_ICONS->get(_path.externname);
        if (IMAGE_FILE_EXTERN_NAMES->find(_path.externname)->is_value)
        {
            if (!cached_image_file_mip_map->contains(_path.path))
            {
                let proj = context->get_project;
                let wrapped_path = proj->make_path_normalize(_path.path);
                cached_image_file_mip_map->set(_path.path,
                    je::graphic::texture::load(option::value(proj->get_env->get_universe), wrapped_path));
            }
            match (cached_image_file_mip_map[_path.path])
            {
                value(tex)? icon = option::value(tex);
                none?;
            }
        }
        
        match (icon)
        {
            none?
            {
                match (_path.type->get)
                {
                    dir(_)?
                        return default_path_icon;
                    file?
                        return default_file_icon;
                }
            }
            value(i)? return i;
        }
    }
    
    union PathType
    {
        dir(option<array<PathInfo>>),
        file,
    }
    
    public using PathInfo = struct {
        path        : fsys::path_t,   // 当前目录/文件的目录
        name        : string,
        externname  : string,
        type        : std::mutable<PathType>, // 类型，如果是目录，则还包含目录内的子项
    }
    {
        func should_hide(self: PathInfo)
        {
            static let HIDING_FILE_TYPE = [
                ".je4cache",
                ".je4project",
                ".je4lock",
                ".je4style"];
                
            if (editor_need_hiding_file)
            {
                return HIDING_FILE_TYPE->find(self.externname)->is_value
                    || self.name->begin_with(".");
            }
            return false;
        }
        func isdir(self : PathInfo)
        {
            match (self.type->get)
            {
                dir(_)? return true;
                file? return false;
            }
        }
        func indir(self : PathInfo, functor: (option<array<PathInfo>>)=>void)
        {
            match (self.type->get)
            {
                dir(subdirs)? functor(subdirs);
                file?;
            }
            return self;
        }
        func infile(self : PathInfo, functor: ()=>void)
        {
            match (self.type->get)
            {
                file? functor();
                dir(_)?;
            }
            return self;
        }
        func childs(self : PathInfo, force_update: bool)
        {
            // 如果没有要求强制更新，有现成的就用现成的
            match (self.type->get)
            {
                dir(_dir)?
                    match(_dir)
                    {
                        value(subdirs)?
                            if (!force_update)
                                return subdirs;
                        none?;
                    }
                file? // 文件也来获取子目录，搁这儿找茬呢？
                    std::panic("Failed to get subpath: is a file.");
            }
            
            // 当前目录的子项目尚未获取，在这里获取一下塞进去
            let sublist =
                fsys::subpath(self.path)
                    ->unwrap
                    ->map(\current_subpath = PathInfo{
                                path = current_subpath,
                                name = fsys::filename(current_subpath),
                                externname = fsys::extension(current_subpath)->lower,
                                type = new! std::mutable(fsys::isdir(current_subpath)?
                                    PathType::dir(option::none) | PathType::file),
                            };);
                            
            self.type->set(PathType::dir(option::value(sublist)));
            return sublist;
        }
        func get_open_method(self: PathInfo)
        {
            static let registed_open_method = {
                [".je4world"] =
                    \p: PathInfo, context: EditorContext =
                        context->get_project->load_world(p.path)
                            =>> \w =context->get_project->reset_editing_world(w);
                            ->  error
                        ;,
                [".je4workflow"] =
                    func(p: PathInfo, context: EditorContext)
                    {
                        workflow::open(p.path, context);
                        return option::none;
                    },
                [".je4animation"] =
                    func(p: PathInfo, context: EditorContext)
                    {
                        match (animation2d::AnimationContext::open(p.path))
                        {
                            ok(ctx)?
                            {
                                animation2d::show(context, ctx);
                                return option::none;
                            }
                            err(_)?
                                return option::value(F"无法打开和编辑帧动画文件：{p.path}");
                        }
                    },
                [".je4partical"] =
                    func (p: PathInfo, context: EditorContext)
                    {
                        match (particalbaker::ParticalContext::load(p.path))
                        {
                            value(ctx)?
                            {
                                particalbaker::show(context, ctx);
                                return option::none;
                            }
                            none?
                                return option::value(F"无法打开和编辑粒子动画文件：{p.path}");
                        }
                    },
                [".je4tilemap"] =
                    func (p: PathInfo, context: EditorContext)
                    {
                        match (fsys::readall(p.path)=>>\dat = dat->dict::deserialize->>\dat = dat->>\k, v = (k as string, v);;;)
                        {
                            value(tilemap_data)?
                            {
                                tilemap::main(context, p.path, tilemap_data);
                                return option::none;
                            }
                            none?
                                return option::value(F"无法打开和编辑瓦片地图文件：{p.path}");
                        }
                    },
                [".wo"] =
                    func (p: PathInfo, context: EditorContext)
                    {
                        do std::shell(F"code {_wrap_path(context->get_project->get_path->to_string())} {_wrap_path(p.path->to_string)}");
                        return option::none;
                    },
                    
            };
            
            return registed_open_method
                ->  get(self.externname)
                ->  or(
                    func (p, _)
                    {
                        do new! thread(func()
                            {
                                let result = std::shell(p.path->to_string());
                                if (0 != result)
                                    jeapi::gui::form::errmsg("失败", F"无法打开'{p.path->to_string()}'({result})");
                                    
                            });
                        return option::none;
                    }
                );
        }
    }
    
    static let mut current_work_path = "";
    
    public func set_current_work_path(path: fsys::path_t)
    {
        if (fsys::isdir(path))
            current_work_path = path->to_string();
        else
            // 刷新！
            jeapi::gui::form::errmsg("无效的路径", F"无效的路径：{path->to_string()}");
            
    }
    
    enum Action
    {
        Nothing,
        Click,
        DoubleClick,
        RightClick,
        Hovered,
    }
    
    func write_file_if_not_exist(path: fsys::path_t, content: string)
    {
        if (fsys::exist(path))
            return false;
        return fsys::writeall(path, content);
    }
    
    func context_menu(path: option<PathInfo>, context: EditorContext)
    {
        let cur_creating_path = current_work_path;
        if (path
            ->map(\_ = BeginPopupContextItem();)
            ->or_do(\ = BeginPopupContextWindow();))
        {
            if (BeginMenu("新建..."))
            {
                if (MenuItem(F"空目录"))
                    jeapi::gui::form::input("新建空目录", F"在{cur_creating_path}新建空目录", "NewDir",
                        \dirname: string = fsys::mkdir(fsys::normalize(cur_creating_path) / dirname)
                            ->map(\_ = force_update();)
                            ->or_do(\errid = jeapi::gui::form::errmsg("失败", F"创建目录失败{errid}");););
                Separator();
                if (MenuItem("空文件"))
                {
                    jeapi::gui::form::input("新建空文件", F"在{cur_creating_path}新建空文件", "NewFile.txt",
                        \filename: string = fsys::exist(file_path)
                            ? jeapi::gui::form::errmsg("创建空文件失败", "同名文件已经存在")
                            | write_file_if_not_exist(file_path, "")
                            ? force_update()
                            | jeapi::gui::form::errmsg("创建空文件失败", "无法创建文件，可能是文件名非法或磁盘已满")
                                where file_path = fsys::normalize(cur_creating_path) / filename;);
                }
                if (MenuItem("Woolang 脚本"))
                {
                    let default_empty_script = 
@"import woo::std;
import je;

using std;
using je;

// 可以在此处编写自己的代码：
je::log("Helloworld");
"@;
                        jeapi::gui::form::input("新建Woolang 脚本", F"在{cur_creating_path}新建Woolang 脚本", "NewScript",
                        \filename: string = fsys::exist(file_path)
                            ? jeapi::gui::form::errmsg("创建Woolang 脚本失败", "同名文件已经存在")
                            | write_file_if_not_exist(file_path, F"// {filename}.wo\n{default_empty_script}")
                            ? force_update()
                            | jeapi::gui::form::errmsg("创建Woolang 脚本失败", "无法创建文件，可能是文件名非法或磁盘已满")
                                where file_path = fsys::normalize(cur_creating_path) / (filename + ".wo"););
                }
                if (MenuItem("ToWoo Component 声明"))
                {
                    let default_empty_script = 
@"import woo::std;

import je::towoo::component;
import je::towoo::types;

component!
{
}
"@;
                        jeapi::gui::form::input("新建ToWoo Component 声明", F"在{cur_creating_path}新建ToWoo Component 脚本", "NewToWooComponent",
                        \filename: string = fsys::exist(file_path)
                            ? jeapi::gui::form::errmsg("创建ToWoo Component 声明失败", "同名文件已经存在")
                            | write_file_if_not_exist(file_path, F"// {filename}.jecomponent.wo\n{default_empty_script}")
                            ? func(){context->get_project->try_update_towoo(false);force_update();}()
                            | jeapi::gui::form::errmsg("创建ToWoo Component 声明失败", "无法创建文件，可能是文件名非法或磁盘已满")
                                where file_path = fsys::normalize(cur_creating_path) / (filename + ".jecomponent.wo"););
                }
                if (MenuItem("ToWoo System 脚本"))
                {
                    let default_empty_script = 
@"import woo::std;
import je;
import je::towoo;
import je::towoo::types;
import je::towoo::components;
import je::towoo::system;

using std;
using je;
using je::towoo;

using Context = struct{
};

extern func create(_: je::world)=> Context
{
    return Context{
    };
}
extern func close(_: Context)
{
}

extern func on_enable(_: Context)
{
}
extern func on_disable(_: Context)
{
}

PRE_UPDATE!
{
}
UPDATE!
{
    system! update()
    {
    }
}
LATE_UPDATE!
{
}
"@;
                        jeapi::gui::form::input("新建ToWoo System 脚本", F"在{cur_creating_path}新建ToWoo System 脚本", "NewToWooSystem",
                        \filename: string = fsys::exist(file_path)
                            ? jeapi::gui::form::errmsg("创建ToWoo System 脚本失败", "同名文件已经存在")
                            | write_file_if_not_exist(file_path, F"// {filename}.jesystem.wo\n{default_empty_script}")
                            ? func(){context->get_project->try_update_towoo(false);force_update();}()
                            | jeapi::gui::form::errmsg("创建ToWoo System 脚本失败", "无法创建文件，可能是文件名非法或磁盘已满")
                                where file_path = fsys::normalize(cur_creating_path) / (filename + ".jesystem.wo"););
                }
                if (MenuItem("Physics2D 组配置"))
                {
                    let default_empty_script = 
@"import je::physics2d::config;

PHYSICS2D_GROUP! 普通物体
{
}

PHYSICS2D_COLLISIONS!
{
    普通物体, 普通物体;
}
"@;
                        jeapi::gui::form::input("新建Physics2D 组配置", F"在{cur_creating_path}新建Physics2D 组配置", "group",
                        \filename: string = fsys::exist(file_path)
                            ? jeapi::gui::form::errmsg("创建Physics2D 组配置失败", "同名文件已经存在")
                            | write_file_if_not_exist(file_path, F"// {filename}.jephysics2d.wo\n{default_empty_script}")
                            ? force_update()
                            | jeapi::gui::form::errmsg("创建Physics2D 组配置失败", "无法创建文件，可能是文件名非法或磁盘已满")
                                where file_path = fsys::normalize(cur_creating_path) / (filename + ".jephysics2d.wo"););
                }
                if (MenuItem("编辑器工具脚本"))
                {
                    let default_empty_script = 
@"import woo::std;
import je;

using std;
using je;

extern func main(_: universe, _: option<world>, _: option<entity>)
{
}
"@;
                        jeapi::gui::form::input("新建编辑器工具脚本", F"在{cur_creating_path}新建编辑器工具脚本", "NewScript",
                        \filename: string = fsys::exist(file_path)
                            ? jeapi::gui::form::errmsg("创建编辑器工具脚本失败", "同名文件已经存在")
                            | write_file_if_not_exist(file_path, F"// {filename}.je.wo\n{default_empty_script}")
                            ? force_update()
                            | jeapi::gui::form::errmsg("创建编辑器工具脚本失败", "无法创建文件，可能是文件名非法或磁盘已满")
                                where file_path = fsys::normalize(cur_creating_path) / (filename + ".je.wo"););
                }
                if (BeginMenu("Workflow"))
                {
                    if (MenuItem("新建 Workflow 图"))
                    {
                        jeapi::gui::form::input("新建 Workflow 图", F"在{cur_creating_path}新建 Workflow 图", "NewWorkflow",
                            \filename: string = fsys::exist(file_path)
                                ? jeapi::gui::form::errmsg("创建Workflow 图失败", "同名文件已经存在")
                                | write_file_if_not_exist(file_path, "{}")
                                ? force_update()
                                | jeapi::gui::form::errmsg("创建Workflow图失败", "无法创建文件，可能是文件名非法或磁盘已满")
                                    where file_path = fsys::normalize(cur_creating_path) / (filename + ".je4workflow"););
                    }
                    Separator();
                    if (MenuItem("新建Node"))
                    {
                        let default_empty_script = 
@"
import woo::std;
import je;
import je::gui;

import pkg::interface;

import builtin::api::gui::nodeeditor;

using je::gui;
using jeapi::gui::node_editor;

using $NEW_NODE_NAME$ = struct{}
{
    alias NodeEditor = jeapi::gui::node_editor;
    
    public func create(_: NodeEditor)=> $NEW_NODE_NAME$
        where require!($NEW_NODE_NAME$: INode);
    {
        return $NEW_NODE_NAME${};
    }
    public func name(_: $NEW_NODE_NAME$)=> string
    {
        return "$NEW_NODE_NAME$";
    }
    public func color(_: $NEW_NODE_NAME$)
    {
        return (0, 0, 0, 127);
    }
    public func onUpdate(_: $NEW_NODE_NAME$, _: NodeEditor, _: string)=> void
    {
    }
    public func onDelete(_: $NEW_NODE_NAME$, _: NodeEditor)=> bool
    {
        return true;
    }
    public func onEval(_: $NEW_NODE_NAME$, _: NodeEditor)=> bool
    {
        return true;
    }
    public func to_string(_: $NEW_NODE_NAME$)=> string
    {
        return "";
    }
    public func parse(_: $NEW_NODE_NAME$, _: string)=> void
    {
    }
}
"@;
                            if (false == fsys::normalize(cur_creating_path)->to_string()->begin_with(
                                (context->get_project->get_path / "resource" / "workflow" / "node")->to_string))
                            jeapi::gui::form::errmsg("创建Workflow Node失败", "Node只能在@/resource/workflow/node目录下创建");
                        else
                        {
                            jeapi::gui::form::input("新建 Workflow Node", F"在{cur_creating_path}新建 Workflow Node", "NewNode",
                                func(filename: string)
                                {
                                    let file_path = fsys::normalize(cur_creating_path) / (filename + ".wo");
                                    if (fsys::exist(file_path))
                                        jeapi::gui::form::errmsg("创建Workflow Node失败", "同名文件已经存在");
                                        
                                    if (write_file_if_not_exist(file_path, default_empty_script->replace("$NEW_NODE_NAME$", filename)))
                                        force_update();
                                    else
                                        jeapi::gui::form::errmsg("创建Workflow Node失败", "无法创建文件，可能是文件名非法或磁盘已满");
                                });
                        }
                    }
                    
                    if (MenuItem("新建Type"))
                    {
                        let default_empty_script = 
@"
import woo::std;
import je;
import je::gui;

import pkg::interface;

import builtin::api::gui::nodeeditor;

using je::gui;
using jeapi::gui::node_editor;

using $NEW_TYPE_NAME$ = struct{}
{
    public func create()=> $NEW_TYPE_NAME$
        where require!($NEW_TYPE_NAME$: ITyped);
    {
        return $NEW_TYPE_NAME${};
    }
    public func to_string(_: $NEW_TYPE_NAME$)=> string
    {
        return "";
    }
    public func parse(_: $NEW_TYPE_NAME$, _: string)=> void
    {
    }
    public func edit(_: $NEW_TYPE_NAME$, _: string)=> void
    {
        PushItemWidth(100.);
        {
        }
        PopItemWidth();
    }
    public func typename(_: $NEW_TYPE_NAME$)=> string
    {
        return "$NEW_TYPE_NAME$";
    }
    public func maxoutput(_: $NEW_TYPE_NAME$)=> int
    {
        return 0;
    }
    public func color(_: $NEW_TYPE_NAME$)=> (int, int, int, int)
    {
        return (180, 140, 150, 255);
    }

    public func get(_: $NEW_TYPE_NAME$)
    {
        // Get value from typevalue
    }
    public func set(_: $NEW_TYPE_NAME$, _: void)
    {
        // Set the value into typevalue
    }
}
"@;
                            jeapi::gui::form::input("新建 Workflow Type", F"在{cur_creating_path}新建 Workflow Type", "NewType",
                            func(filename: string)
                            {
                                let file_path = fsys::normalize(cur_creating_path) / (filename + ".wo");
                                if (fsys::exist(file_path))
                                    jeapi::gui::form::errmsg("创建Workflow Type失败", "同名文件已经存在");
                                    
                                if (write_file_if_not_exist(file_path, default_empty_script->replace("$NEW_TYPE_NAME$", filename)))
                                    force_update();
                                else
                                    jeapi::gui::form::errmsg("创建Workflow Type失败", "无法创建文件，可能是文件名非法或磁盘已满");
                            });
                    }
                    if (MenuItem("新建Producer"))
                    {
                        let default_empty_script =
@"
import woo::std;
import je;
import je::gui;

import pkg::interface;

import builtin::api::gui::nodeeditor;

using je::gui;
using jeapi::gui::node_editor;

using $NEW_PRODUCER_NAME$ = struct{}
{
    public func create()=> $NEW_PRODUCER_NAME$
        where require!($NEW_PRODUCER_NAME$: IProducer);
    {
        return $NEW_PRODUCER_NAME${};
    }
    public func reset(_: $NEW_PRODUCER_NAME$)
    {
    }
    public func finished(_: $NEW_PRODUCER_NAME$)=> bool
    {
        return true;
    }
    public func to_string(_: $NEW_PRODUCER_NAME$)=> string
    {
        return "";
    }
    public func parse(_: $NEW_PRODUCER_NAME$, _: string)=> void
    {
    }
    public func edit(_: $NEW_PRODUCER_NAME$, _: string)=> void
    {
        PushItemWidth(100.);
        {
        }
        PopItemWidth();
    }

    public func next(_: $NEW_PRODUCER_NAME$)
    {
        return option::none;
    }
}
"@;
                            
                        jeapi::gui::form::input("新建 Workflow Producer", F"在{cur_creating_path}新建 Workflow Producer", "NewProducer",
                            func(filename: string)
                            {
                                let file_path = fsys::normalize(cur_creating_path) / (filename + ".wo");
                                if (fsys::exist(file_path))
                                    jeapi::gui::form::errmsg("创建Workflow Producer失败", "同名文件已经存在");
                                    
                                if (write_file_if_not_exist(file_path, default_empty_script->replace("$NEW_PRODUCER_NAME$", filename)))
                                    force_update();
                                else
                                    jeapi::gui::form::errmsg("创建Workflow Producer失败", "无法创建文件，可能是文件名非法或磁盘已满");
                            });
                    }
                    EndMenu();
                }
                Separator();
                if (MenuItem("世界"))
                {
                    jeapi::gui::form::input("创建世界", F"将在{cur_creating_path}创建新世界：",
                        "Newworld",
                        func(new_world_name)
                        {
                            let world_context = new! edit_forms::WorldContext(
                                context->get_project(),
                                new_world_name,
                                fsys::normalize(F"{cur_creating_path}/{new_world_name}.je4world"),
                                func (w)
                                {
                                    if (context->get_project()->serialize_world(w, true)
                                        ->> \wdat = write_file_if_not_exist(
                                                fsys::normalize(F"{cur_creating_path}/{new_world_name}.je4world"),
                                                wdat as jeapi::serialize::WorldData: string)
                                            ;
                                        ->  or(false)
                                        == false)
                                    {
                                        jeapi::gui::form::errmsg("创建世界失败", "无法创建文件，可能是文件名非法或磁盘已满");
                                        return false;
                                    }
                                    force_update();
                                    return true;
                                });
                            launch(\= edit_forms::show_world_creator(context, world_context););
                        });
                }
                if (MenuItem("瓦片地图"))
                {
                    jeapi::gui::form::input("新建瓦片地图", F"在{cur_creating_path}新建瓦片地图", "NewTileMap",
                        \filename: string = fsys::exist(file_path)
                            ? jeapi::gui::form::errmsg("新建瓦片地图失败", "同名文件已经存在")
                            | write_file_if_not_exist(file_path, "{}")
                            ? func(){context->get_project->try_update_towoo(false);force_update();}()
                            | jeapi::gui::form::errmsg("新建瓦片地图失败失败", "无法创建文件，可能是文件名非法或磁盘已满")
                                where file_path = fsys::normalize(cur_creating_path) / (filename + ".je4tilemap"););
                }
                Separator();
                if (BeginMenu("纹理"))
                {
                    if (MenuItem(F"空白纹理"))
                        create_image("White", cur_creating_path, func(img){
                                let (w, h) = img->size;
                                for (let mut x = 0 ; x < w; x += 1)
                                    for (let mut y = 0 ; y < h; y += 1)
                                        img->setpix((x, y), (1., 1., 1., 1.));
                            });
                    if (MenuItem(F"透明纹理"))
                        create_image("Empty", cur_creating_path, func(img){
                                let (w, h) = img->size;
                                for (let mut x = 0 ; x < w; x += 1)
                                    for (let mut y = 0 ; y < h; y += 1)
                                        img->setpix((x, y), (0., 0., 0., 0.));
                            });
                    if (MenuItem(F"文本纹理"))
                        create_font_image(context->get_project(), "Text", cur_creating_path);
                        
                    EndMenu();
                }
                Separator();
                if (BeginMenu("着色器脚本"))
                {
                    static let editor_origin_shaders = [
                        ("单色", "Mono"),
                        ("无光", "Unlit"),
                        ("无光混合", "UnlitBlend"),
                        ("后向2D", "Forward2D"),
                        ("后向2D单色", "Forward2DMono"),
                        ("后向2D法线纹理", "Forward2DNormal"),
                        ("后向2D自发光系数", "Forward2DSelfGlowing"),
                        ("后向2D自发光系数单色", "Forward2DMonoSelfGlowing"),
                        ("后向2D自发光系数法线", "Forward2DNormalSelfGlowing"),
                        ("后向2D氛围光", "Forward2DAura"),
                        ("2D点光（光源）", "Light2DPoint"),
                        ("2D范围光（光源）", "Light2DRange"),
                        ("2D平行光（光源）", "Light2DParallel"),
                        ("2D光照后处理（摄像机）", "CameraDefer2DPass"),
                        ("2D光照外发光后处理（摄像机）", "CameraDefer2DBloomPass"),
                        ("2D光照雾效果后处理（摄像机）", "CameraDefer2DFogPass"),
                    ];
                    
                    let create_shader_at = func(shader_name: string, shader_src: string)
                    {
                        let shader_path = fsys::normalize(F"{cur_creating_path}/{shader_name}.shader");
                        if (!write_file_if_not_exist(shader_path, shader_src))
                            jeapi::gui::form::errmsg("创建着色器失败", F"无法写入{shader_path}");
                        else
                            force_update();
                    };
                    
                    for (let (shader_display_name, shader_path_name) : editor_origin_shaders)
                        if (MenuItem(shader_display_name))
                            jeapi::gui::form::input("创建着色器", F"将在{cur_creating_path}创建{shader_display_name}：",
                                shader_path_name,
                                \shader_name: string =
                                    fsys::readall(fsys::normalize(F"{std::host_path()}/builtin/shader/{shader_path_name}.shader"))
                                        ->> \src = create_shader_at(shader_name, src);
                                        ->  or_do(\ = je::logerr(F"打开内置着色器文件{shader_path_name}失败，请检查编辑器目录");)
                                    ;
                                ); // end of inputbox
                                
                    EndMenu();
                }
                if (BeginMenu("动画"))
                {
                    if (MenuItem("2D帧序列"))
                    {
                        jeapi::gui::form::input("新建2D帧动画", F"在{cur_creating_path}新建动画", "NewAnimation",
                            func (filename)
                            {
                                let path = fsys::normalize(cur_creating_path) / F"{filename}.je4animation";
                                if (fsys::exist(path))
                                    jeapi::gui::form::errmsg("创建2D帧动画失败", "可能是同名文件已经存在或文件名路径不合法");
                                else
                                {
                                    assert(new! animation2d::AnimationContext(path)->save);
                                    force_update();
                                }
                            });
                    }
                    if (MenuItem("粒子动画"))
                    {
                        jeapi::gui::form::input("新建粒子动画", F"在{cur_creating_path}新建动画", "NewPartical",
                            func (filename)
                            {
                                let path = fsys::normalize(cur_creating_path) / F"{filename}.je4partical";
                                if (fsys::exist(path))
                                    jeapi::gui::form::errmsg("创建粒子动画失败", "可能是同名文件已经存在或文件名路径不合法");
                                else
                                {
                                    assert(new! particalbaker::ParticalContext(path)->save);
                                    force_update();
                                }
                            });
                    }
                    EndMenu();
                }
                if (MenuItem(F"C++模块"))
                {
                    // 创建C++模块，就跟JoyEngineCSP差不多
                    jeapi::gui::form::input("创建C++模块", F"将在{cur_creating_path}创建，请为项目命名：", "CppModule",
                        \module_name: string = CxxProject::start(module_name, cur_creating_path, context->get_project)
                            ->> \ _ = force_update();
                            ->or_do(\reason = jeapi::gui::form::errmsg("创建C++模块失败", reason);)
                            ;
                        );
                }
                EndMenu();
            }
            
            Separator();
            
            do path
                ->> \p = file_item_menu(p, context);
                ->> \_ = Separator();
                ;
                
            if (MenuItem("在资源管理器中显示"))
                do std::shell(F"explorer \"{fsys::normalize(cur_creating_path)->to_string->replace("/", "\\")}\"");
                
            if (MenuItem(F"刷新"))
            {
                context->get_project->try_update_towoo(false);
                force_update();
            }
            
            EndPopup();
        }
    }
    
    func crc_path(path: fsys::path_t)
    {
        // 给定一个路径，计算整个路径的全部crc
        using fsys;
        using je::internal;
        
        let normalized_path = path;
        let pure_path =
            \p: string = p->begin_with(normalized_path->to_string())
                ? p->sub(normalized_path->to_string()->len)
                | p
                ;
            ;
            
        return normalized_path
            -> allsubpath()
            -> okay
            =>> \childs = childs
                ->> \child = isfile(child)
                    ? fsys::filename(fsys::normalize(pchild)) + crc64file(child->to_string)->unwrap: string
                    | pchild
                        where pchild = pure_path(child->to_string);
                    ->  reduce(\l, r = l + r;)
                    ->> \str = crc64str(str);
                ;
            ->  unwrap;
    }
    
    func try_update_recompile(module: CxxProject)
    {
        // 检查一下引擎的提供的文件，确认是否需要重新编译
        let engine_path_crc64 = crc_path(CxxProject::ENGINE_HEADER_PATH);
        let specify_module_path_crc64 = crc_path(module.path/".engine"/"include");
        
        if (engine_path_crc64 == specify_module_path_crc64)
        {
            module->update_compile(std::platform::runtime_type::DEBUG);
        }
        else
        {
            jeapi::gui::form::ask("模块头文件版本不一致", F"模块{module.path}\n的引擎头文件在尝试重新编译时检测到了不一致。\n是否需要更新？",
                func(choice)
                {
                    if (choice)
                    {
                        let update_result = CxxProject::update_engine_file(module.path);
                        if (!update_result->is_ok)
                        {
                            jeapi::gui::form::errmsg("重新编译失败", F"{module.path}更新引擎文件失败：\n{update_result->error->unwrap}");
                            return;
                        }
                    }
                    else; // 点NO 啥也不干~
                    module->update_compile(std::platform::runtime_type::DEBUG);
                });
        }
    }
    func for_all_entity_in_universe_do(context: EditorContext, dowhat: (je::entity)=>bool)
    {
        return context->get_project->get_env->get_universe
            ->  get_all_worlds
            =>> \w: je::world = w
                ->  get_all_entities([])
                ->> dowhat
                ;
            ->  reduce(\l, r = l && r;)
            ->  or(false)
            ;
    }
    public func update_shader(context: EditorContext, path: string)
    {
        // 从universe中获取所有world，更新world中所有实体
        let wrapped_path = context->get_project->make_path_normalize(fsys::normalize(path));
        
        do je::internal::mark_shared_glresource_outdated(wrapped_path);
        if (!for_all_entity_in_universe_do(context,
                \e: je::entity = e->internal::graphic::try_reload_shaders(wrapped_path, wrapped_path);
                ))
        {
            jeapi::gui::form::errmsg("更新着色器失败", "更新着色器过程中发生了错误，请检查");
        }
    }
    public func update_texture(context: EditorContext, wrapped_path: string)
    {
        // 从universe中获取所有world，更新world中所有实体
        do je::internal::mark_shared_glresource_outdated(wrapped_path);
        if (!for_all_entity_in_universe_do(context,
                \e: je::entity = e->internal::graphic::try_reload_textures(wrapped_path, wrapped_path);
                ))
        {
            jeapi::gui::form::errmsg("更新纹理失败", "更新纹理过程中发生了错误，请检查");
        }
    }
    func file_item_menu(path: PathInfo, context: EditorContext)
    {
        let NOT_MODIFIABLE_FILES = [".je4project", ".je4module"];
        let is_modifiable_file = NOT_MODIFIABLE_FILES->find(path.externname)->is_none;
        
        if (path.externname == ".shader")
        {
            if (MenuItem(F"更新此着色器"))
            {
                update_shader(context, path.path->to_string());
            }
            Separator();
        }
        else if (path.externname == ".je4module")
        {
            if (MenuItem(F"重新编译此模块"))
            {
                match (context->get_project->get_module(path.path))
                {
                    value(module)?
                        try_update_recompile(module);
                    none?
                        jeapi::gui::form::ask("是否加载此模块？",
                            F"正在要求重新编译模块{path.path}\n但此模块尚未被加载。\n是否现在加载并重新编译？",
                            func (sure: bool)
                            {
                                if (!sure) return;
                                match (CxxProject::open_for_loading(path.path, context->get_project))
                                {
                                    ok(module)?
                                        try_update_recompile(module);
                                    err(reason)?
                                        jeapi::gui::form::errmsg("加载模块失败", reason);
                                }
                            });
                }
                
            }
            if (MenuItem(F"组件/系统..."))
            {
                let components = fsys::subpath(path.path/"components")
                    ->map(\s = s
                            ->forall(\f = fsys::extension(f) == ".hpp";)
                            ->map(\f = fname->sub_len(0, fname->len - 4)
                                    where fname = fsys::filename(f);)
                            ;)
                    ->or([])
                    ->to_vec;
                let systems = fsys::subpath(path.path/"systems")
                    ->okay
                    ->map(\s = s
                            ->forall(\f = fsys::extension(f) == ".hpp";)
                            ->map(\f = fname->sub_len(0, fname->len - 4)
                                    where fname = fsys::filename(f);)
                            ;)
                    ->or([])
                    ->to_vec;
                    
                let display_usable_component = func(s: string)
                {
                    do Selectable(s);
                    if (BeginPopupContextItem())
                    {
                        let file_path = path.path/"components"/F"{s}.hpp";
                        
                        if (MenuItem("在VSCode中打开"))
                            do std::shell(F"code {_wrap_path(path.path->to_string())} {_wrap_path(file_path->to_string)}");
                        if (MenuItem("移除此组件"))
                            jeapi::gui::form::ask("确认移除组件？", F"是否从模块{fsys::filename(path.path)}中移除组件{s}?",
                                func(sure: bool){
                                    if (!sure) return;
                                    do components->find(s)->> \idx = components->remove(idx);;
                                    do fsys::remove(file_path)->unwrap;
                                });
                        EndPopup();
                    }
                };
                
                let display_usable_system = func(s: string)
                {
                    do Selectable(s);
                    if (BeginPopupContextItem())
                    {
                        let file_path = path.path/"systems"/F"{s}.cpp";
                        
                        if (MenuItem("在VSCode中打开"))
                            do std::shell(F"code {_wrap_path(path.path->to_string)} {_wrap_path(file_path->to_string)}");
                        if (MenuItem("移除此系统"))
                            jeapi::gui::form::ask("确认移除系统？", F"是否从模块{fsys::filename(path.path)}中移除系统{s}?",
                                func(sure: bool){
                                    if (!sure) return;
                                    
                                    do systems->find(s)->> \idx = systems->remove(idx);;
                                    do fsys::remove(path.path/"systems"/F"{s}.hpp")->unwrap;
                                    do fsys::remove(file_path)->unwrap;
                                });
                        EndPopup();
                    }
                };
                
                launch(func()
                    {
                        let mut open = true;
                        
                        match (BeginAttrOpen(F"模块{fsys::filename(path.path)}当前组件和系统",
                                WindowsAttribute::ImGuiWindowFlags_MenuBar))
                        {
                            value(show)?
                                if (show)
                                {
                                    if (BeginMenuBar())
                                    {
                                        if (BeginMenu("创建..."))
                                        {
                                            if (MenuItem("新系统"))
                                                jeapi::gui::form::input("创建新系统", F"为模块{fsys::filename(path.path)}创建系统", "NewSystem",
                                                    func(name: string)
                                                    {
                                                        if (systems->find(name)->is_value)
                                                        {
                                                            jeapi::gui::form::errmsg("创建系统失败", F"模块{fsys::filename(path.path)}已经存在一个同名系统");
                                                            return;
                                                        }
                                                        
                                                let system_header = 
@"#pragma once
#include "jeecs.hpp"

namespace $$MODULE_NAME$$
{
    struct $$SYSTEM_NAME$$ : public jeecs::game_system
    {
        $$SYSTEM_NAME$$(jeecs::game_world world);
        ~$$SYSTEM_NAME$$();
        
        void OnEnable();
        void OnDisable();

        void PreUpdate(jeecs::selector&);
        void Update(jeecs::selector&);
        void LateUpdate(jeecs::selector&);
    };
}
"@;
                                            let system_src = 
@"#include "$$SYSTEM_NAME$$.hpp"

using namespace std;
using namespace jeecs;

namespace $$MODULE_NAME$$
{
    $$SYSTEM_NAME$$::$$SYSTEM_NAME$$(game_world world)
        : game_system(world)
    {
    }
    $$SYSTEM_NAME$$::~$$SYSTEM_NAME$$()
    {
    }

    void $$SYSTEM_NAME$$::OnEnable()
    {
    }
    void $$SYSTEM_NAME$$::OnDisable()
    {
    }

    void $$SYSTEM_NAME$$::PreUpdate(jeecs::selector& selector)
    {
    }
    void $$SYSTEM_NAME$$::Update(jeecs::selector& selector)
    {
    }
    void $$SYSTEM_NAME$$::LateUpdate(jeecs::selector& selector)
    {
    }
}
"@;
                                                            let module_name = fsys::purename(path.path);
                                                        let system_name = name;
                                                        
                                                        if (!fsys::writeall(path.path/"systems"/F"{system_name}.hpp",
                                                                system_header
                                                                    ->replace("$$MODULE_NAME$$", module_name)
                                                                    ->replace("$$SYSTEM_NAME$$", system_name))
                                                            ||
                                                            !fsys::writeall(path.path/"systems"/F"{system_name}.cpp",
                                                                system_src
                                                                    ->replace("$$MODULE_NAME$$", module_name)
                                                                    ->replace("$$SYSTEM_NAME$$", system_name))
                                                            )
                                                        {
                                                            do fsys::remove(path.path/"systems"/F"{system_name}.hpp")->unwrap;
                                                            do fsys::remove(path.path/"systems"/F"{system_name}.cpp")->unwrap;
                                                            
                                                            jeapi::gui::form::errmsg("创建系统失败", "无法创建和写入系统源文件");
                                                        }
                                                        else
                                                        {
                                                            jeapi::gui::form::errmsg("创建系统成功", "系统已创建到\n"
                                                                + F"{path.path}/systems/{system_name}.hpp\n"
                                                                + F"{path.path}/systems/{system_name}.cpp");
                                                            systems->add(system_name);
                                                        }
                                                    });
                                            //End of create new system
                                            if (MenuItem("新组件"))
                                                jeapi::gui::form::input("创建新组件", F"为模块{fsys::filename(path.path)}创建组件", "NewComponent",
                                                    func(name: string)
                                                    {
                                                        if (components->find(name)->is_value)
                                                        {
                                                            jeapi::gui::form::errmsg("创建组件失败", F"模块{fsys::filename(path.path)}已经存在一个同名组件");
                                                            return;
                                                        }
                                                        
                                                let component_header = 
@"#pragma once
#include "jeecs.hpp"

namespace $$MODULE_NAME$$
{
    struct $$COMPONENT_NAME$$
    {
        JECS_DISABLE_MOVE_AND_COPY_OPERATOR($$COMPONENT_NAME$$);

        $$COMPONENT_NAME$$()= default;
        $$COMPONENT_NAME$$(const $$COMPONENT_NAME$$&) = default;
        $$COMPONENT_NAME$$($$COMPONENT_NAME$$&&) = default;

        static void JERefRegsiter(jeecs::typing::type_unregister_guard* guard)
        {
            using namespace jeecs;

            // Register member in this function.
            // e.g. typing::register_member(guard, &$$COMPONENT_NAME$$::member, "member");
        }
    };
}
"@;
                                                            let module_name = fsys::purename(path.path);
                                                        let component_name = name;
                                                        
                                                        if (!fsys::writeall(path.path/"components"/F"{component_name}.hpp",
                                                                component_header
                                                                    ->replace("$$MODULE_NAME$$", module_name)
                                                                    ->replace("$$COMPONENT_NAME$$", component_name))
                                                            )
                                                        {
                                                            do fsys::remove(path.path/"components"/F"{component_name}.hpp")->unwrap;
                                                            jeapi::gui::form::errmsg("创建组件失败", "无法创建和写入组件源文件");
                                                        }
                                                        else
                                                        {
                                                            jeapi::gui::form::errmsg("创建组件成功", "组件已创建到\n"
                                                                + F"{path.path}/components/{component_name}.hpp");
                                                            components->add(component_name);
                                                        }
                                                    });
                                            // End of create new component
                                            EndMenu();
                                        }
                                        EndMenuBar();
                                    }
                                    
                                    let (available_width, _) = GetContentRegionAvail();
                                    
                                    BeginGroup();
                                    Text("系统");
                                    let (_, avaliable_height) = GetContentRegionAvail();
                                    
                                    if (BeginListBox("##1", available_width/2.-0.5, avaliable_height))
                                    {
                                        do systems->> \s = display_usable_system(s);;
                                        EndListBox();
                                    }
                                    EndGroup();
                                    
                                    SameLine();
                                    
                                    BeginGroup();
                                    Text("组件");
                                    let (_, avaliable_height2) = GetContentRegionAvail();
                                    if (BeginListBox("##2", available_width/2.-0.5, avaliable_height2))
                                    {
                                        do components->> \s = display_usable_component(s);;
                                        EndListBox();
                                    }
                                    EndGroup();
                                }
                            none?
                                open = false;
                        }
                        End();
                        
                        return open;
                    });
            }
            Separator();
        }
        else if (IMAGE_FILE_EXTERN_NAMES->find(path.externname)->is_value)
        {
            // 是图片，在这里编辑图片的采用方法等数据
            if (MenuItem(F"更新此纹理"))
            {
                update_texture(context, context->get_project->make_path_normalize(path.path));
            }
            if (MenuItem("预览并编辑"))
            {
                match (je::graphic::texture::load(
                        option::value(context->get_project->get_env->get_universe),
                        context->get_project->make_path_normalize(path.path)))
                {
                    value(tex)?
                        drawpannel::drawimg(context, tex);
                    none?
                        jeapi::gui::form::errmsg("编辑图片失败", F"无法打开图片纹理:{path.path->to_string}");
                }
                
            }
            Separator();
        }
        
        // 下面是通用的选项
        if (MenuItem("复制路径"))
        {
            SetClipboardText(context->get_project->make_path_normalize(path.path));
        }
        if (MenuItemEnabled("复制文件", is_modifiable_file))
        {
            let fsys_path = path.path;
            let mut target_path = fsys::parent(fsys_path) / (fsys::purename(fsys_path) + "(1)" + fsys::extension(fsys_path));
            
            for (let mut n = 2; ; n += 1)
                if (fsys::exist(target_path))
                    target_path = fsys::parent(fsys_path) / (fsys::purename(fsys_path) + F"({n})" + fsys::extension(fsys_path));
            else break;
            
            match (fsys::copy(fsys_path, target_path))
            {
                ok(_)?
                {
                    context->get_project->try_update_towoo(false);
                    force_update();
                }
                err(errid)?
                    jeapi::gui::form::errmsg("失败", F"复制文件失败({errid})");
            }
        }
        if (MenuItemEnabled("重命名", is_modifiable_file))
        {
            jeapi::gui::form::input("重命名", F"请输入{path.path}的新名称", path.name,
                \new_name = editor::gui::refactor(context, path.path, fsys::parent(path.path)/new_name)
                    -> or_do(\errid = jeapi::gui::form::errmsg("失败", F"重命名失败({errid})");)
                    ;);
        // \new_name: string = fsys::move(path.path, fsys::parent(path.path)/new_name)
        //     ->> func(_){context->get_project->try_update_towoo(false);force_update();}
        //     ->or_do(\errid = jeapi::gui::form::errmsg("失败", F"重命名失败({errid})");););
        }
        if (MenuItemEnabled("移动到...", is_modifiable_file))
        {
            jeapi::gui::form::input("移动到……", F"请输入{path.path}的路径", path.path->to_string,
                \new_path = editor::gui::refactor(context, path.path, fsys::normalize(new_path))
                    -> or_do(\errid = jeapi::gui::form::errmsg("失败", F"重命名失败({errid})");)
                    ;);
        // \new_path: string = fsys::move(path.path, fsys::normalize(new_path))
        //     ->> func(_){context->get_project->try_update_towoo(false);force_update();}
        //     ->or_do(\errid = jeapi::gui::form::errmsg("失败", F"重命名失败({errid})");););
        }
        if (MenuItemEnabled("删除", is_modifiable_file))
        {
            jeapi::gui::form::ask(F"删除{path.path}", F"是否继续删除{path.path}",
                func(sure: bool)
                {
                    if (!sure) return;
                    do fsys::remove(path.path)
                        ->> func(_){context->get_project->try_update_towoo(false);force_update();}
                        ->  or_do(\errid = jeapi::gui::form::errmsg("失败", F"删除失败({errid})");)
                        ;
                    do fsys::remove(fsys::parent(path.path) / (fsys::filename(path.path) + ".je4cache"));
                });
        }
    }
    
    // 带图标的文件按钮
    func FileIcon(path: PathInfo, context: EditorContext)=> Action
    {
        BeginGroup();
        let clicked = ImageButtonSize(
            F"##{path.path->to_string}#imagebutton", get_file_icon_by_extern_name(path, context), 32., 32.);
        let hovered = IsItemHovered();
        let right_click = IsItemClicked(ImGuiMouseButton::ImGuiMouseButton_Right);
        context_menu(option::value(path), context);
        if (BeginDragDropSource())
        {
            let ppath = context->get_project()->make_path_normalize(path.path);
            do SetDragDropPayload("JEDITOR_FILE_PATH", ppath);
            Text(F"File: {ppath}");
            EndDragDropSource();
        }
        
        SameLine();
        Text(path.name);
        EndGroup();
        
        static let mut _last_click_time = std::time();
        
        if(clicked)
        {
            let _current_click_time = std::time();
            if (_current_click_time - _last_click_time < 0.2)
                return Action::DoubleClick;
                
            _last_click_time = _current_click_time;
            return Action::Click;
        }
        else if (right_click)
            return Action::RightClick;
            
        if (hovered)
            return Action::Hovered;
            
        return Action::Nothing;
    }
    
    static let mut force_update_file_group_flag = false;
    static let mut force_update_dir_tree_flag = false;
    static let cached_image_file_mip_map = {}mut: map<fsys::path_t, option<je::graphic::texture>>;
    
    // 刷新显示的目录信息等...
    public func force_update()
    {
        force_update_dir_tree_flag = true;
        force_update_file_group_flag = true;
        cached_image_file_mip_map->clear;
    }
    
    // 右边的文件详情等信息
    func files_group(context: EditorContext)
    {
        static let mut new_showing_path = "";
        static let mut now_item_in_path = []: array<PathInfo>;
        if (new_showing_path != current_work_path || force_update_file_group_flag)
        {
            new_showing_path = current_work_path;
            force_update_file_group_flag = false;
            
            func compare_method (a: PathInfo, b: PathInfo)
            {
                func is_dir(p){match(p.type->get){dir(_)?return true;file?return false;}}
                    if (is_dir(a))
                        return !is_dir(b);
                else if (is_dir(b))
                    return false;
                    
                if (a.externname != b.externname)
                    return a.externname < b.externname;
                return a.name < b.name;
            }
            
            now_item_in_path =
                fsys::subpath(fsys::normalize(current_work_path))
                    ->  unwrap
                    ->> \subpath = PathInfo{
                            path = subpath,
                            name = fsys::filename(subpath),
                            externname = fsys::extension(subpath)->lower,
                            type = new! std::mutable(fsys::isdir(subpath)
                                ? PathType::dir(option::none)
                                | PathType::file),
                        };
                    ->std::sort(compare_method)
                    ;
        }
        
        do BeginChild("files_list");
        context_menu(option::none, context);
        do now_item_in_path
            -> forall(\item = !item->should_hide;)
            ->> func(item)
            {
                let action = FileIcon(item, context);
                
                if (action == Action::Click)
                {
                }
                else if (action == Action::DoubleClick)
                {
                    do item->indir(\_ = set_current_work_path(item.path);)
                        ->infile(\ = do item->get_open_method()(item, context)
                                ->> \err = jeapi::gui::form::errmsg("失败", F"打开文件失败:\n{err}");
                                ;);
                                
                }
                else if (action == Action::Hovered)
                {
                    BeginTooltip();
                    Text(fsys::filename(item.path));
                    if (IMAGE_FILE_EXTERN_NAMES->find(item.externname)->is_value)
                    {
                        let tex = get_file_icon_by_extern_name(item, context);
                        let (w, h) = tex->size;
                        let whratio = w: real / h: real;
                        
                        TextDisabled(F"{w}x{h}");
                        ImageSize(tex, 64. * whratio, 64.);
                    }
                    EndTooltip();
                }
            }
        ;
        EndChild();
        if (BeginDragDropTarget())
        {
            match (AcceptDragDropPayload("JEDITOR_ENTITY_INSTANCE"))
            {
                value(drag_uid)?
                {
                    let eid = drag_uid as string: handle: jeapi::debug::Eeid;
                    eid->justdo(func(e){
                            match (jeapi::serialize::entity::dump(e, false)->>\dat = dat: string;)
                            {
                                value(entity_json)?
                                {
                                    let filepath = fsys::normalize(current_work_path) / (e->internal::name + ".je4entity");
                                    let prefab_data = e->towoo::get_component:<Editor::Prefab>;
                                    if (fsys::exist(filepath))
                                    {
                                        // 如果实体已经是预设体，那么拒绝覆盖已有的预设体以规避蛋疼的循环引用问题
                                        if (prefab_data->is_value)
                                            jeapi::gui::form::errmsg("无法覆盖预设体", "不允许已经为预设体的实体保存覆盖预设体文件");
                                        else
                                            jeapi::gui::form::ask("是否覆盖", F"文件{filepath->to_string}已存在，是否覆盖？",
                                                func(overwrite){
                                                    if (overwrite)
                                                    {
                                                        do fsys::writeall(filepath, entity_json);
                                                        eid->justdo(func(e)
                                                            {
                                                                let prefab = e->towoo::add_component:<Editor::Prefab>->unwrap;
                                                                prefab.path->set(context->get_project->make_path_normalize(filepath));
                                                            });
                                                        force_update();
                                                    }
                                                });
                                    }
                                    else
                                    {
                                        let mut create = true;
                                        if (prefab_data->is_value)
                                        {
                                            if (prefab_data->unwrap.path->get == context->get_project->make_path_normalize(filepath)
                                                || false == fsys::isfile(context->get_project->parse_path_normalize(prefab_data->unwrap.path->get)))
                                            {
                                                create = false;
                                                jeapi::gui::form::errmsg("无法创建预设体", "变体原所属的预设体丢失");
                                            }
                                        }
                                        if (create)
                                        {
                                            do fsys::writeall(filepath, entity_json);
                                            let prefab = e->towoo::add_component:<Editor::Prefab>->unwrap;
                                            prefab.path->set(context->get_project->make_path_normalize(filepath));
                                            force_update();
                                        }
                                    }
                                }
                                none?
                                    jeapi::gui::form::errmsg("失败", F"无法序列化实体{e->internal::name}");
                            }
                        });
                }
                none?
                    ;
            }
            EndDragDropTarget();
        }
    }
    
    // 左侧的目录概况
    func path_tree(context: EditorContext)
    {
        let root_path =
            context->get_project->get_path;
            
        if (current_work_path == "")
            current_work_path = root_path->to_string();
            
        static let _root = PathInfo {
            path = root_path,
            name = fsys::filename(root_path),
            externname = fsys::extension(root_path)->lower,
            type = new! std::mutable(PathType::dir(option::none)),
        };
        
        if (force_update_dir_tree_flag)
        {
            force_update_dir_tree_flag = false;
            
            // 强制更新，直接把缓存的子目录全部干掉
            _root.type->set(PathType::dir(option::none));
        }
        
        // 用于递归展示所有子目录等
        func _show_paths(path: PathInfo)=> void
        {
            match (path.type->get)
            {
                dir(_)?
                {
                    let mut attribute = TreeNodeAttribute::ImGuiTreeNodeFlags_OpenOnArrow
                        + TreeNodeAttribute::ImGuiTreeNodeFlags_OpenOnDoubleClick
                        + TreeNodeAttribute::ImGuiTreeNodeFlags_SpanAvailWidth;
                    if (current_work_path == path.path->to_string)
                        attribute += TreeNodeAttribute::ImGuiTreeNodeFlags_Selected;
                        
                    let show_child = TreeNodeEx(F"{path.name}##p", attribute);
                    if (IsItemClickedLeft() && !IsItemToggledOpen())
                        current_work_path = path.path->to_string;
                        
                    if (show_child)
                    {
                        for (let subpath : path->childs(false))
                            _show_paths(subpath);
                            
                        TreePop();
                    }
                    else
                        // 如果目录被折叠起来，则删除缓存，等待下次展开时重新获取
                        path.type->set(PathType::dir(option::none));
                }
                file?
                    ; // path_tree只显示目录，跳过文件
            }
        }
        
        do BeginChildSize("path_tree", 200., 0.);
        _show_paths(_root);
        EndChild();
    }
    
    using LogHook = struct{
        m_logs: vec<(je::internal::loglevel, string)>,
        m_display_setting: dict<je::internal::loglevel, (string, mut bool, option<(int, int, int, int)>, mut int)>,
    }
    {
        func create()
        {
            return LogHook{
                m_logs = []mut,
                m_display_setting = {
                    [je::internal::loglevel::NORMAL] = ("普通", mut true, option::none: option<(int, int, int, int)>, mut 0),
                    [je::internal::loglevel::INFO] = ("信息", mut true, option::value((0,255,127,255)), mut 0),
                    [je::internal::loglevel::WARNING] = ("警告", mut true, option::value((200,200,0,255)), mut 0),
                    [je::internal::loglevel::ERROR] = ("错误", mut true, option::value((200,0,0,200)), mut 0),
                    [je::internal::loglevel::FATAL] = ("致命", mut true, option::value((200,0,200,255)), mut 0),
                },
            };
        }
        func update(self: LogHook, context: EditorContext)
        {
            for (let e : context->get_logs)
            {
                self.m_logs->add(e);
                self.m_display_setting[e[0]][3] += 1;
            }
        }
        func clear(self: LogHook)
        {
            self.m_logs->clear;
            for (let (_, e): self.m_display_setting)
            {
                e[3] = 0;
            }
        }
        func display_log(self: LogHook)
        {
            if (BeginChild("logbox"))
            {
                if (BeginChildSize("logbox_focus_loglevel", 100., 0.))
                {
                    if (Button("清除"))
                        self->clear;
                        
                    for (let (_, setting): self.m_display_setting)
                    {
                        do CheckBox(setting[0], setting[1])->>\c=setting[1] = c;;
                    }
                }
                EndChild();
                
                SameLine();
                let (avail_width, avail_height) = GetContentRegionAvail();
                if (BeginListBox("##", avail_width, avail_height))
                {
                    for (let mut i = self.m_logs->len; i > 0; i -= 1)
                    {
                        let (level, info) = self.m_logs[i - 1];
                        if (self.m_display_setting[level][1])
                        {
                            let color_setted = self.m_display_setting[level][2]
                                ->> \col = true where _ = PushStyleColor(ImGuiCol::ImGuiCol_Text, col);
                                ->  or(false);
                                
                            do Selectable(F"[{self.m_display_setting[level][0]}] {info}");
                            
                            if (IsItemHovered())
                            {
                                BeginTooltip();
                                Text(info);
                                EndTooltip();
                            }
                            
                            if (color_setted)
                                PopStyleColor(1);
                        }
                    }
                    
                    EndListBox();
                }
            }
            EndChild();
        }
        func get_log_abstract(self: LogHook)
        {
            return self.m_display_setting
                -> forall(\_, v = v[3] > 0;)
                -> unmapping
                ->> \kv = F"{kv[1][0]} {kv[1][3]}";
                -> reduce(\l, r = l + " " + r;)
                -> or("");
        }
    }
    public func show_logger(context: EditorContext, open: std::mutable<bool>)
    {
        if (open->get)
        {
            static let log_displayer = new! LogHook();
            
            je::gui::SetNextWindowSizeConstraints((500., 200.), (2000., 1100.));
            open->set(true);
            match (BeginAttrOpen("日志查看器", WindowsAttribute::ImGuiWindowFlags_NoBringToFrontOnFocus))
            {
                value(show)?
                    if (show)
                    {
                        PushStyleColor(ImGuiCol::ImGuiCol_Text, (75, 120, 200, 255));
                        Text(log_displayer->get_log_abstract);
                        PopStyleColor(1);
                        
                        log_displayer->update(context);
                        
                        log_displayer->display_log();
                    }
                none?
                    open->set(false);
            }
            
            End();
        }
    }
    public func show_browser(context: EditorContext, open: std::mutable<bool>)
    {
        if (open->get)
        {
            je::gui::SetNextWindowSizeConstraints((500., 200.), (2000., 1100.));
            open->set(true);
            match (BeginAttrOpen("资源管理器", WindowsAttribute::ImGuiWindowFlags_NoBringToFrontOnFocus))
            {
                value(show)?
                    if (show)
                    {
                        path_tree(context);
                        SameLine();
                        BeginGroup();
                        do BeginChildSize("tools_bar", 0., 40.);
                        // TODO 此处放一些返回上一层之类的按钮
                        if (Button("U"))
                        {
                            current_work_path =
                                fsys::parent(fsys::normalize(current_work_path))->to_string;
                        }
                        SameLine();
                        Text(current_work_path);
                        SameLine();
                        
                        EndChild();
                        
                        files_group(context);
                        EndGroup();
                    }
                none?
                    open->set(false);
            }
            
            End();
        }
    }
}

import pkg::image;
import pkg::fsys;

import woo::shell;
import builtin::editor::cpp::main;
import builtin::editor::gui::animation2d;
import builtin::editor::gui::particalbaker;

using je::gui;

namespace editor::gui
{
    public let mut editor_need_hiding_file = true;

    func create_font_image(proj: Project, default_name: string, location: string)
    {
        let fonts = fsys::allsubpath(proj.m_path/"resource"/"font")
            -> or(\_=[];)
            -> forall(\path = fsys::isfile(path) && fsys::extension(path)->lower == ".ttf";)
            ->> \path = proj->make_path_normalize(path);
            ;

        if (fonts->empty)
        {
            jeapi::gui::form::errmsg("失败", "没有在 @/resource/font 找到有效的字体");
            return;
        }

        let create_context = (mut default_name, mut "Helloworld", mut 0, mut 16);
        launch(func(){
            let mut open = true;
            je::gui::SetNextWindowSizeConstraints((350., 200.), (350., 200.));
            if (Begin(F"在{location}创建纹理"))
            {
                Text("文件名");
                create_context[0] = InputText("##imagename", create_context[0])->valor(create_context[0]);

                Separator();

                Text("字体");
                SameLine();
                do Combo("##fontname", fonts, create_context[2])->>\id = create_context[2] = id;;
                SameLine();
                do InputInt("##fontsize", create_context[3])->>func(new_size){
                    if (new_size > 0)
                        create_context[3] = new_size;
                };

                let (w, h) = GetContentRegionAvail();
                create_context[1] = InputTextMultilineSize("##imagetext", create_context[1], w, h - 30.)
                    ->valor(create_context[1]);

                if (Button("创建"))
                {
                    match (je::graphic::font::load(fonts[create_context[2]], create_context[3]))
                    {
                    value(font_instance)?
                        {
                            let tex = font_instance->load_string(create_context[1]);
                            // 创建image，然后保存！
                            let (tw, th) = tex->size();
                            let img = new! image(tw, th);
                            for (let mut ix = 0; ix < tw; ix += 1)
                                for (let mut iy = 0; iy < th; iy += 1)
                                    img->setpix((ix, iy), tex->pix((ix, iy))->get_color());
                            
                            let aimpath = F"{location}/{create_context[0]}.png";
                            if (!img->save(aimpath))
                                jeapi::gui::form::errmsg("创建失败", F"无法写入{aimpath}");
                            else
                            {
                                open = false;
                                force_update();
                            }
                        }
                    none?
                        jeapi::gui::form::errmsg("失败", F"无法打开纹理：{fonts[create_context[2]]}");
                    } 
                }
                SameLine();
                if (Button("取消"))
                    open = false;
            }
            End();

            return open;
        }, ());
    }

    func create_image(default_name: string, location: string, generator: (image)=> void)
    {
        let create_context = (mut 16, mut 16, mut default_name);
        launch(
            func(context: (mut int, mut int, mut string))
            {
                let mut open = true;
                je::gui::SetNextWindowSizeConstraints((300., 200.), (300., 200.));
                if (Begin(F"在{location}创建纹理"))
                {
                    Text("文件名");
                    context[2] = InputText("##imagename", context[2])->valor(context[2]);

                    Separator();

                    Text("宽");
                    SameLine();
                    context[0] = InputInt("##width", context[0])->valor(context[0]);

                    Text("高");
                    SameLine();
                    context[1] = InputInt("##height", context[1])->valor(context[1]);

                    if (Button("创建"))
                    {
                        let img = new! image(context[0], context[1]);

                        generator(img);

                        let aimpath = F"{location}/{context[2]}.png";
                        if (!img->save(aimpath))
                            jeapi::gui::form::errmsg("创建失败", F"无法写入{aimpath}");
                        else
                        {
                            open = false;
                            force_update();
                        }
                    }
                    SameLine();

                    if (Button("取消"))
                        open = false;
                }
                End();

                return open;
            }, (create_context, )
        );
    }
    
    // 支持作为图片格式的拓展名
    let IMAGE_FILE_EXTERN_NAMES = [".png", ".jpg", ".bmp", ".psd",];

    // 用于储存文件拓展名和图标的对应关系
    let FILE_TYPE_ICONS = {
        [".png"] = je::graphic::texture::load(F"!/builtin/icon/TextureFile.png")->val,
        [".jpg"] = je::graphic::texture::load(F"!/builtin/icon/TextureFile.png")->val,
        [".bmp"] = je::graphic::texture::load(F"!/builtin/icon/TextureFile.png")->val,
        [".psd"] = je::graphic::texture::load(F"!/builtin/icon/TextureFile.png")->val,
        [".shader"] = je::graphic::texture::load(F"!/builtin/icon/ShaderFile.png")->val,
        [".jemodule4"] = je::graphic::texture::load(F"!/builtin/icon/CppProgram.png")->val,
        [".jecache4"] = je::graphic::texture::load(F"!/builtin/icon/JoyEngineCSP-Dev.png")->val,
        [".jeworld"] = je::graphic::texture::load(F"!/builtin/icon/World.png")->val,
        [".jewo"] = je::graphic::texture::load(F"!/builtin/icon/Plugins.png")->val,
        [".jeanim4"] = je::graphic::texture::load(F"!/builtin/icon/AnimationFile.png")->val,
        
        // 欸嘿还没做呢，先拿joy顶一下
        [".jepartical"] = je::graphic::texture::load(F"!/builtin/icon/joyengine.png")->val,
    };

    // 根据文件拓展名返回文件的类型
    private func get_file_icon_by_extern_name(_path: PathInfo)
    {
        static let default_path_icon 
            = je::graphic::texture::load(F"!/builtin/icon/FilePath.png")->val;
        static let default_file_icon 
            = je::graphic::texture::load(F"!/builtin/icon/File.png")->val;

        let icon = FILE_TYPE_ICONS->get(_path.externname);

        match (icon)
        {
        none?
        {
            match (_path.type->get)
            {
            dir(_)?
                return default_path_icon;
            file?
                return default_file_icon;
            }
        }
        value(i)? return i;
        }
    }

    union PathType
    {
        dir(option<array<PathInfo>>),
        file,
    }

    public using PathInfo = struct {
        path        : fsys::path_t,   // 当前目录/文件的目录
        name        : string,
        externname  : string,
        type        : mutable<PathType>, // 类型，如果是目录，则还包含目录内的子项    
    }
    {
        func should_hide(self: PathInfo)
        {
            static let HIDING_FILE_TYPE = [".jecache4"];
            
            if (editor_need_hiding_file)
            {
                return HIDING_FILE_TYPE->find(self.externname) != -1
                    || self.name->beginwith(".");
            }
            return false;
        }
        func isdir(self : PathInfo)
        {
            match (self.type->get)
            {
            dir(_)? return true;
            file? return false;
            }
        }
        func indir(self : PathInfo, functor: (option<array<PathInfo>>)=>void)
        {
            match (self.type->get)
            {
            dir(subdirs)? functor(subdirs);
            file?;
            }
            return self;
        }
        func infile(self : PathInfo, functor: ()=>void)
        {
            match (self.type->get)
            {
            file? functor();
            dir(_)?;
            }
            return self;
        }
        func childs(self : PathInfo, force_update: bool)
        {
            // 如果没有要求强制更新，有现成的就用现成的
            match (self.type->get)
            {
            dir(_dir)?
                match(_dir)
                {
                value(subdirs)?
                    if (!force_update)
                        return subdirs;
                none?;
                }
            file? // 文件也来获取子目录，搁这儿找茬呢？
                std::panic("Failed to get subpath: is a file.");
            }

            // 当前目录的子项目尚未获取，在这里获取一下塞进去
            let sublist = 
                fsys::subpath(self.path)
                    ->unwarp
                    ->map(\current_subpath = PathInfo{
                        path = current_subpath, 
                        name = fsys::filename(current_subpath),
                        externname = fsys::extension(current_subpath),
                        type = new! mutable(fsys::isdir(current_subpath)?
                                PathType::dir(option::none) | PathType::file),
                    };);

            self.type->set(PathType::dir(option::value(sublist)));
            return sublist;
        }
        func get_open_method(self: PathInfo)
        {
            static let registed_open_method = {
                [".jeworld"] = 
                    \p: PathInfo, context: EditorContext = 
                        context->get_project->load_world(p.path)
                            =>> \w =context->get_project->reset_editing_world(w);
                            ->  error
                    ;,
                [".jeanim4"] = 
                    func(p: PathInfo, context: EditorContext)
                    {
                        match (animation2d::AnimationContext::open(p.path))
                        {
                        ok(ctx)?
                            {
                                animation2d::show(context, ctx);
                                return option::none;
                            }
                        err(_)?
                            return option::value(F"无法打开和编辑帧动画文件：{p.path}");
                        }
                    },
                [".jepartical"] = 
                    func (p: PathInfo, context: EditorContext)
                    {
                        match (particalbaker::ParticalContext::load(p.path))
                        {
                        value(ctx)?
                            {
                                particalbaker::show(context, ctx);
                                return option::none;
                            }
                        none?
                            return option::value(F"无法打开和编辑粒子动画文件：{p.path}");
                        }
                    }
            };

            return registed_open_method
                ->  get(self.externname->lower)
                ->  valor(
                    func (p, _)
                    {
                        do new! thread(func()
                            {
                                let result = std::shell(p.path->tostring());
                                if (0 != result)
                                    jeapi::gui::form::errmsg("失败", F"无法打开'{p.path->tostring()}'({result})");

                            }, ());
                        return option::none;
                    }
                );
        }
    }

    static let mut current_work_path = "";

    public func set_current_work_path(path: fsys::path_t)
    {
        assert(fsys::isdir(path));
        current_work_path = path->tostring();
    }

    enum Action
    {
        Nothing,
        Click,
        DoubleClick,
        RightClick,
    }

    func write_file_if_not_exist(path: fsys::path_t, content: string)
    {
        if (fsys::exist(path))
            return false;
        return fsys::writeall(path, content);
    }

    func context_menu(path: option<PathInfo>, context: EditorContext)
    {
        if (path
            ->map(\_ = BeginPopupContextItem();)
            ->or(\ = BeginPopupContextWindow();))
        {
            if (BeginMenu(F"新建..."))
            {
                if (MenuItem(F"空目录"))
                    jeapi::gui::form::input("新建空目录", F"在{current_work_path}新建空目录", "NewDir",
                        \dirname: string = fsys::mkdir(fsys::normalize(current_work_path) / dirname)
                            ->map(\_ = force_update();)
                            ->or(\errid = jeapi::gui::form::errmsg("失败", F"创建目录失败{errid}");););
                Separator();
                if (MenuItem(F"空文件"))
                {
                    jeapi::gui::form::input("新建空文件", F"在{current_work_path}新建空文件", "NewFile.txt",
                        \filename: string = fsys::exist(file_path)
                            ? jeapi::gui::form::errmsg("创建空文件失败", "同名文件已经存在")
                            | write_file_if_not_exist(file_path, "") 
                                ? force_update()
                                | jeapi::gui::form::errmsg("创建空文件失败", "无法创建文件，可能是文件名非法或磁盘已满")
                        where file_path = fsys::normalize(current_work_path) / filename;);
                }
                if (MenuItem(F"Woolang 脚本"))
                {
                    let default_empty_script = 
@"import woo::std;
import je;

using std;
using je;

using Context = ();

extern func create(_: entity)
{
    return (): Context;
}
extern func update(_: Context, _: entity)
{

}
"@;
                    jeapi::gui::form::input("新建Woolang 脚本", F"在{current_work_path}新建Woolang 脚本", "NewScript",
                        \filename: string = fsys::exist(file_path)
                            ? jeapi::gui::form::errmsg("创建空文件失败", "同名文件已经存在")
                            | write_file_if_not_exist(file_path, F"// {filename}.wo\n{default_empty_script}") 
                                ? force_update()
                                | jeapi::gui::form::errmsg("创建空文件失败", "无法创建文件，可能是文件名非法或磁盘已满")
                        where file_path = fsys::normalize(current_work_path) / (filename + ".wo"););
                }
                if (MenuItem(F"ToWoo Component 声明"))
                {
                    let default_empty_script = 
@"import je::towoo::component;

component!
{
}
"@;
                    jeapi::gui::form::input("新建ToWoo Component 声明", F"在{current_work_path}新建ToWoo Component 脚本", "NewToWooComponent",
                        \filename: string = fsys::exist(file_path)
                            ? jeapi::gui::form::errmsg("创建空文件失败", "同名文件已经存在")
                            | write_file_if_not_exist(file_path, F"// {filename}.wocomponent\n{default_empty_script}") 
                                ? func(){context->get_project->try_update_towoo(false);force_update();}()
                                | jeapi::gui::form::errmsg("创建空文件失败", "无法创建文件，可能是文件名非法或磁盘已满")
                        where file_path = fsys::normalize(current_work_path) / (filename + ".wocomponent"););
                }
                if (MenuItem(F"ToWoo System 脚本"))
                {
                    let default_empty_script = 
@"import woo::std;
import je;
import je::towoo;

import je::towoo::system;

using std;
using je;
using je::towoo;

using Context = struct{
};

extern func create(_: je::world)=> Context
{
    return Context{
    };
}
extern func close(_: Context)
{
}

PRE_UPDATE!
{
}

UPDATE!
{
    system! update()
    {
    }
}

LATE_UPDATE!
{
}
"@;
                    jeapi::gui::form::input("新建ToWoo System 脚本", F"在{current_work_path}新建ToWoo System 脚本", "NewToWooSystem",
                        \filename: string = fsys::exist(file_path)
                            ? jeapi::gui::form::errmsg("创建空文件失败", "同名文件已经存在")
                            | write_file_if_not_exist(file_path, F"// {filename}.wosystem\n{default_empty_script}") 
                                ? func(){context->get_project->try_update_towoo(false);force_update();}()
                                | jeapi::gui::form::errmsg("创建空文件失败", "无法创建文件，可能是文件名非法或磁盘已满")
                        where file_path = fsys::normalize(current_work_path) / (filename + ".wosystem"););
                }
                if (MenuItem(F"编辑器工具脚本"))
                {
                    let default_empty_script = 
@"import woo::std;
import je;

using std;
using je;

extern func main(_: universe, _: option<world>, _: option<entity>)
{

}
"@;
                    jeapi::gui::form::input("新建编辑器工具脚本", F"在{current_work_path}新建编辑器工具脚本", "NewScript",
                        \filename: string = fsys::exist(file_path)
                            ? jeapi::gui::form::errmsg("创建空文件失败", "同名文件已经存在")
                            | write_file_if_not_exist(file_path, F"// {filename}.jewo\n{default_empty_script}") 
                                ? force_update()
                                | jeapi::gui::form::errmsg("创建空文件失败", "无法创建文件，可能是文件名非法或磁盘已满")
                        where file_path = fsys::normalize(current_work_path) / (filename + ".jewo"););
                }
                Separator();
                if (MenuItem(F"世界"))
                {
                    jeapi::gui::form::input("创建世界", F"将在{current_work_path}创建新世界：",
                        "Newworld",
                        \new_world_name = launch(
                            edit_forms::show_world_creator, (context, new! edit_forms::WorldContext(
                                context->get_project(), new_world_name, fsys::normalize(F"{current_work_path}/{new_world_name}.jeworld"),
                                func (w)
                                {
                                    if (context->get_project()->serialize_world(w)
                                            ->> \wdat = write_file_if_not_exist(
                                                fsys::normalize(F"{current_work_path}/{new_world_name}.jeworld"), 
                                                wdat as dict<string, dynamic>: string)
                                                ;
                                            ->  valor(false)
                                        == false)
                                    {
                                        jeapi::gui::form::errmsg("创建世界失败", "无法创建文件，可能是文件名非法或磁盘已满");
                                        return false;
                                    }
                                    force_update();
                                    return true;
                                }
                            )));
                        ); 
                }
                Separator();
                if (BeginMenu(F"纹理"))
                {
                    if (MenuItem(F"空白纹理"))
                        create_image("White", current_work_path, func(img){
                            let (w, h) = img->size;
                            for (let mut x = 0 ; x < w; x += 1)
                                for (let mut y = 0 ; y < h; y += 1)
                                    img->setpix((x, y), (1., 1., 1., 1.));
                        });
                    if (MenuItem(F"透明纹理"))
                        create_image("Empty", current_work_path, func(img){
                            let (w, h) = img->size;
                            for (let mut x = 0 ; x < w; x += 1)
                                for (let mut y = 0 ; y < h; y += 1)
                                    img->setpix((x, y), (0., 0., 0., 0.));
                        });
                    if (MenuItem(F"文本纹理"))
                        create_font_image(context->get_project(), "Text", current_work_path);
                        
                    EndMenu();
                }
                Separator();
                if (BeginMenu("着色器脚本"))
                {
                    static let editor_origin_shaders = [
                        ("单色", "MonoColor"),
                        ("无光", "Unlit"),
                        ("无光混合", "UnlitBlend"),
                        ("2D光照单色", "Forward2DMono"),
                        ("2D光照", "Forward2D"),
                        ("2D光照法线", "Forward2DNormal"),
                        ("2D光照自发光", "SelfGrowingForward2D"),
                        ("2D光照自发光单色", "SelfGrowingForward2DMono"), 
                        ("2D光照自发光法线", "SelfGrowingForward2DNormal"),
                        ("2D光照氛围光", "Light2DAura"),
                        ("2D点光源（光源）", "Light2DPoint"),
                        ("2D平行光源（光源）", "Light2DParallel"),
                        ("2D光照后处理（摄像机）", "Light2DCameraPass"),
                        ("2D光照外发光后处理（摄像机）", "Light2DCameraBloomPass"),
                    ];

                    let create_shader_at = func(shader_name: string, shader_src: string)
                    {
                        let shader_path = fsys::normalize(F"{current_work_path}/{shader_name}.shader");
                        if (!write_file_if_not_exist(shader_path, shader_src))
                            jeapi::gui::form::errmsg("创建着色器失败", F"无法写入{shader_path}");
                        else
                            force_update();
                    };

                    for (let _, (shader_display_name, shader_path_name) : editor_origin_shaders)
                        if (MenuItem(shader_display_name))
                            jeapi::gui::form::input("创建着色器", F"将在{current_work_path}创建{shader_display_name}：",
                                shader_path_name,
                                \shader_name: string = 
                                    fsys::readall(fsys::normalize(F"{std::exepath()}/builtin/shader/{shader_path_name}.shader"))
                                        ->> \src = create_shader_at(shader_name, src);
                                        ->  or(\ = je::logerr(F"打开内置着色器文件{shader_path_name}失败，请检查编辑器目录");)
                                    ;
                                ); // end of inputbox
                  
                    EndMenu();
                }
                if (BeginMenu("动画"))
                {
                    if (MenuItem("2D帧序列"))
                    {
                        jeapi::gui::form::input("新建2D帧动画", F"在{current_work_path}新建动画", "NewAnimation",
                            func (filename)
                            {
                                let path = fsys::normalize(current_work_path) / F"{filename}.jeanim4";
                                if (fsys::exist(path))
                                    jeapi::gui::form::errmsg("创建2D帧动画失败", "可能是同名文件已经存在或文件名路径不合法");
                                else
                                {
                                    assert(new! animation2d::AnimationContext(path)->save);
                                    force_update();
                                }
                            });
                    }
                    if (MenuItem("粒子动画"))
                    {
                        jeapi::gui::form::input("新建粒子动画", F"在{current_work_path}新建动画", "NewPartical",
                            func (filename)
                            {
                                let path = fsys::normalize(current_work_path) / F"{filename}.jepartical";
                                if (fsys::exist(path))
                                    jeapi::gui::form::errmsg("创建粒子动画失败", "可能是同名文件已经存在或文件名路径不合法");
                                else
                                {
                                    assert(new! particalbaker::ParticalContext(path)->save);
                                    force_update();
                                }
                            });
                    }
                    EndMenu();
                }
                if (MenuItem(F"C++模块"))
                {
                    // 创建C++模块，就跟JoyEngineCSP差不多
                    jeapi::gui::form::input("创建C++模块", F"将在{current_work_path}创建，请为项目命名：", "CppModule", 
                        \module_name: string = CxxProject::start(module_name, current_work_path, context->get_project)
                            ->> \ _ = force_update();
                            ->or(\reason = jeapi::gui::form::errmsg("创建C++模块失败", reason);)
                            ;
                        );
                }
                EndMenu();
            }

            Separator();

            do path
                ->> \p = file_item_menu(p, context);
                ->> \_ = Separator();
                ;
                        
            if (MenuItem("在资源管理器中显示"))
                do std::shell(F"explorer \"{fsys::normalize(current_work_path)->tostring->replace("/", "\\")}\"");

            if (MenuItem(F"刷新"))
            {
                context->get_project->try_update_towoo(false);
                force_update();
            }

            EndPopup();
        }
    }

    func crc_path(path: fsys::path_t)
    {
        // 给定一个路径，计算整个路径的全部crc
        using fsys;
        using je::editor;
        let normalized_path = path;
        let pure_path = 
            \p: string = p->beginwith(normalized_path->tostring()) 
                ? p->sub(normalized_path->tostring()->len)
                | p
            ;
        ;

        func debug(msg)
        {
            std::println(msg);
            return msg;
        }

        return normalized_path
            -> allsubpath()
            -> okay
            =>> \childs = childs
                ->> \child = isfile(child)
                    ? fsys::filename(fsys::normalize(pchild)) + crc64file(child->tostring)->val: string 
                    | pchild
                    where pchild = pure_path(child->tostring);
                ->  reduce(\l, r = l + r;)
                ->> \str = crc64str(str);
                ;
            ->  val;
    }

    func try_update_recompile(module: CxxProject)
    {
        // 检查一下引擎的提供的文件，确认是否需要重新编译
        let engine_path_crc64 = crc_path(CxxProject::ENGINE_HEADER_PATH);
        let specify_module_path_crc64 = crc_path(module.path/"engine"/"include");

        if (engine_path_crc64 == specify_module_path_crc64)
        {
            module->update_compile(je::platform());
        }
        else
        {
            jeapi::gui::form::ask("模块头文件版本不一致", F"模块{module.path}\n的引擎头文件在尝试重新编译时检测到了不一致。\n是否需要更新？",
                func(choice)
                {
                    if (choice)
                    {
                        let update_result = 
                            CxxProject::update_engine_file(module.path)
                                =>> \r = CxxProject::generate_module_config(module.project, module.name, module.path, r);;
                        if (!update_result->isok)
                        {
                            jeapi::gui::form::errmsg("重新编译失败", F"{module.path}更新引擎文件失败：\n{update_result->error->val}");
                            return;
                        }
                    }
                    else; // 点NO 啥也不干~
                    module->update_compile(je::platform());
                });
        }
    }
    func for_all_entity_in_universe_do(context: EditorContext, dowhat: (je::entity)=>bool)
    {
        return context->get_project->get_env->get_universe
            ->  get_all_worlds
            =>> \w: je::world = w
                ->  get_all_entities
                ->> dowhat
                ;
            ->  reduce(\l, r = l && r;)
            ->  valor(false)
            ;
    }
    public func update_shader(context: EditorContext, path: string)
    {
        // 从universe中获取所有world，更新world中所有实体
        let wrapped_path = context->get_project->make_path_normalize(fsys::normalize(path));

        do je::editor::mark_shared_glresource_outdated(wrapped_path);
        if (!for_all_entity_in_universe_do(context,
            \e: je::entity = e->editor::graphic::try_reload_shaders(wrapped_path, wrapped_path);
        ))
        {
            jeapi::gui::form::errmsg("更新着色器失败", "更新着色器过程中发生了错误，请检查");
        }
    }
    public func update_texture(context: EditorContext, path: string)
    {
        // 从universe中获取所有world，更新world中所有实体
        let wrapped_path = context->get_project->make_path_normalize(fsys::normalize(path));

        do je::editor::mark_shared_glresource_outdated(wrapped_path);
        if (!for_all_entity_in_universe_do(context,
            \e: je::entity = e->editor::graphic::try_reload_textures(wrapped_path, wrapped_path);
        ))
        {
            jeapi::gui::form::errmsg("更新纹理失败", "更新纹理过程中发生了错误，请检查");
        }
    }
    func file_item_menu(path: PathInfo, context: EditorContext)
    {
        let NOT_MODIFIABLE_FILES = [".jeproj4", ".jemodule4"];
        let is_modifiable_file = NOT_MODIFIABLE_FILES->find(path.externname) == -1;

        if (path.externname == ".shader")
        {
            if (MenuItem(F"更新此着色器"))
            {
                update_shader(context, path.path->tostring());
            }
            Separator();
        }
        else if (path.externname == ".jemodule4")
        {
            if (MenuItem(F"重新编译此模块"))
            {
                match (context->get_project->get_module(path.path))
                {
                value(module)?
                    try_update_recompile(module);
                none?
                    jeapi::gui::form::ask("是否加载此模块？", 
                        F"正在要求重新编译模块{path.path}\n但此模块尚未被加载。\n是否现在加载并重新编译？",
                        func (sure: bool)
                        {
                            if (!sure) return;
                            match (CxxProject::open_for_loading(path.path, context->get_project))
                            {
                            ok(module)?
                                try_update_recompile(module);
                            err(reason)?
                                jeapi::gui::form::errmsg("加载模块失败", reason);
                            }
                        });
                }
                    
            }
            if (MenuItem(F"组件/系统..."))
            {
                let components = fsys::subpath(path.path/"components")
                        ->map(\s = s
                             ->forall(\f = fsys::extension(f) == ".hpp";)
                             ->map(\f = fname->subto(0, fname->len - 4)
                                where fname = fsys::filename(f);)
                            ;)
                        ->or(\_=[];)
                        ->tovec;
                let systems = fsys::subpath(path.path/"systems")
                    ->okay
                    ->map(\s = s
                         ->forall(\f = fsys::extension(f) == ".hpp";)
                         ->map(\f = fname->subto(0, fname->len - 4)
                            where fname = fsys::filename(f);)
                        ;)
                    ->valor([])
                    ->tovec;

                func _wrap_path(path: string)
                {
                    // 根据不同平台，如果路径包含空白分割字符或需要在shell里转义的字符什么的，这里包一下
                    if (path->find(" ") != -1 || path->find("\t") != -1)
                        return F"\"{path}\"";
                    return path;
                }

                let display_usable_component = func(s: string)
                {
                    do Selectable(s);
                    if (BeginPopupContextItem())
                    {
                        let file_path = path.path/"components"/F"{s}.hpp";

                        if (MenuItem("在VSCode中打开"))
                            do std::shell(F"code {_wrap_path(path.path->tostring())} {_wrap_path(file_path->tostring)}");
                        if (MenuItem("移除此组件"))
                            jeapi::gui::form::ask("确认移除组件？", F"是否从模块{fsys::filename(path.path)}中移除组件{s}?",
                                func(sure: bool){
                                    if (!sure) return;
                                    do components->remove(components->find(s));
                                    do fsys::remove(file_path)->unwarp;
                                });
                        EndPopup();
                    }
                };

                let display_usable_system = func(s: string)
                {
                    do Selectable(s);
                    if (BeginPopupContextItem())
                    {
                        let file_path = path.path/"systems"/F"{s}.cpp";

                        if (MenuItem("在VSCode中打开"))
                            do std::shell(F"code {_wrap_path(path.path->tostring)} {_wrap_path(file_path->tostring)}");
                        if (MenuItem("移除此系统"))
                            jeapi::gui::form::ask("确认移除系统？", F"是否从模块{fsys::filename(path.path)}中移除系统{s}?",
                                func(sure: bool){
                                    if (!sure) return;

                                    do systems->remove(systems->find(s));
                                    do fsys::remove(path.path/"systems"/F"{s}.hpp")->unwarp;
                                    do fsys::remove(file_path)->unwarp;
                                });
                        EndPopup();
                    }
                };

                launch(func(mut open: bool)
                {
                    match (BeginAttrOpen(F"模块{fsys::filename(path.path)}当前组件和系统", 
                        WindowsAttribute::ImGuiWindowFlags_MenuBar))
                    {
                    value(show)?
                        if (show)
                        {
                            if (BeginMenuBar())
                            {
                                if (BeginMenu("创建..."))
                                {
                                    if (MenuItem("新系统"))
                                        jeapi::gui::form::input("创建新系统", F"为模块{fsys::filename(path.path)}创建系统", "NewSystem",
                                            func(name: string)
                                            {
                                                if (systems->find(name) != -1)
                                                {
                                                    jeapi::gui::form::errmsg("创建系统失败", F"模块{fsys::filename(path.path)}已经存在一个同名系统");
                                                    return;
                                                }

                                                let system_header = 
@"#pragma once
#include "jeecs.hpp"

namespace $$MODULE_NAME$$
{
    struct $$SYSTEM_NAME$$ : public jeecs::game_system
    {
        $$SYSTEM_NAME$$(jeecs::game_world world);
        ~$$SYSTEM_NAME$$();
        
        void PreUpdate();
        void Update();
        void LateUpdate();
    };
}
"@;
                                            let system_src = 
@"#include "$$SYSTEM_NAME$$.hpp"

using namespace std;
using namespace jeecs;

namespace $$MODULE_NAME$$
{
    $$SYSTEM_NAME$$::$$SYSTEM_NAME$$(game_world world)
        : game_system(world)
    {
        
    }

    $$SYSTEM_NAME$$::~$$SYSTEM_NAME$$()
    {
        
    }

    void $$SYSTEM_NAME$$::PreUpdate()
    {

    }

    void $$SYSTEM_NAME$$::Update()
    {

    }

    void $$SYSTEM_NAME$$::LateUpdate()
    {

    }
}
"@;
                                                let module_name = fsys::purename(path.path);
                                                let system_name = name;

                                                if (!fsys::writeall(path.path/"systems"/F"{system_name}.hpp", 
                                                    system_header
                                                        ->replace("$$MODULE_NAME$$", module_name)
                                                        ->replace("$$SYSTEM_NAME$$", system_name))
                                                    ||
                                                    !fsys::writeall(path.path/"systems"/F"{system_name}.cpp", 
                                                    system_src
                                                        ->replace("$$MODULE_NAME$$", module_name)
                                                        ->replace("$$SYSTEM_NAME$$", system_name))
                                                    )
                                                {
                                                    do fsys::remove(path.path/"systems"/F"{system_name}.hpp")->unwarp;
                                                    do fsys::remove(path.path/"systems"/F"{system_name}.cpp")->unwarp;

                                                    jeapi::gui::form::errmsg("创建系统失败", "无法创建和写入系统源文件");
                                                }
                                                else
                                                {
                                                    jeapi::gui::form::errmsg("创建系统成功", "系统已创建到\n" 
                                                        + F"{path.path}/systems/{system_name}.hpp\n"
                                                        + F"{path.path}/systems/{system_name}.cpp");
                                                    systems->add(system_name);
                                                }
                                            });
                                    //End of create new system
                                    if (MenuItem("新组件"))
                                        jeapi::gui::form::input("创建新组件", F"为模块{fsys::filename(path.path)}创建组件", "NewComponent",
                                            func(name: string)
                                            {
                                                if (components->find(name) != -1)
                                                {
                                                    jeapi::gui::form::errmsg("创建组件失败", F"模块{fsys::filename(path.path)}已经存在一个同名组件");
                                                    return;
                                                }

                                                let component_header = 
@"#pragma once
#include "jeecs.hpp"

namespace $$MODULE_NAME$$
{
    struct $$COMPONENT_NAME$$
    {
        JECS_DISABLE_MOVE_AND_COPY_OPERATOR($$COMPONENT_NAME$$);

        $$COMPONENT_NAME$$()= default;
        $$COMPONENT_NAME$$(const $$COMPONENT_NAME$$&) = default;
        $$COMPONENT_NAME$$($$COMPONENT_NAME$$&&) = default;

        static void JERefRegsiter(jeecs::typing::type_unregister_guard* guard)
        {
            using namespace jeecs;

            // Register member in this function.
            // e.g. typing::register_member(guard, &$$COMPONENT_NAME$$::member, "member");
        }
    };
}
"@;
                                                let module_name = fsys::purename(path.path);
                                                let component_name = name;

                                                if (!fsys::writeall(path.path/"components"/F"{component_name}.hpp", 
                                                    component_header
                                                        ->replace("$$MODULE_NAME$$", module_name)
                                                        ->replace("$$COMPONENT_NAME$$", component_name))
                                                    )
                                                {
                                                    do fsys::remove(path.path/"components"/F"{component_name}.hpp")->unwarp;
                                                    jeapi::gui::form::errmsg("创建组件失败", "无法创建和写入组件源文件");
                                                }
                                                else
                                                {
                                                    jeapi::gui::form::errmsg("创建组件成功", "组件已创建到\n" 
                                                        + F"{path.path}/components/{component_name}.hpp");
                                                    components->add(component_name);
                                                }
                                            });
                                    // End of create new component
                                    EndMenu();
                                }
                                EndMenuBar();
                            }

                            let (available_width, _) = GetContentRegionAvail();

                            BeginGroup();
                            Text("系统");
                            let (_, avaliable_height) = GetContentRegionAvail();

                            if (BeginListBox("##1", available_width/2.-0.5, avaliable_height))
                            {
                                do systems->> \s = display_usable_system(s);;
                                EndListBox();
                            }
                            EndGroup();

                            SameLine();

                            BeginGroup();
                            Text("组件");
                            let (_, avaliable_height2) = GetContentRegionAvail();
                            if (BeginListBox("##2", available_width/2.-0.5, avaliable_height2))
                            {
                                do components->> \s = display_usable_component(s);;
                                EndListBox();
                            }
                            EndGroup();
                        }
                    none?
                        open = false;
                    }
                    End();

                    return open;
                }, (true,));
            }
            Separator();
        }    
        else if (IMAGE_FILE_EXTERN_NAMES->find(path.externname) != -1)
        {
            // 是图片，在这里编辑图片的采用方法等数据
            if (MenuItem(F"更新此纹理"))
            {
                update_texture(context, path.path->tostring());
            }
            if (MenuItem("预览并编辑"))
            {
                match (je::graphic::texture::load(path.path->tostring))
                {
                value(tex)?
                    drawpannel::drawimg(context, tex);
                none?
                    jeapi::gui::form::errmsg("编辑图片失败", F"无法打开图片纹理:{path.path->tostring}");
                }
                
            }
            Separator();
        }

        // 下面是通用的选项
        if (MenuItem("复制路径"))
        {
            SetClipboardText(context->get_project->make_path_normalize(path.path));
        }
        if (MenuItemEnabled("复制文件", is_modifiable_file))
        {
            let path = path.path;
            let mut target_path = fsys::parent(path) / (fsys::purename(path) + "(1)" + fsys::extension(path));

            for (let mut n = 2; ; n += 1)
                if (fsys::exist(target_path))
                    target_path = fsys::parent(path) / (fsys::purename(path) + F"({n})" + fsys::extension(path));
                else break;

            match (fsys::copy(path, target_path))
            {
            ok(_)?
                {
                    context->get_project->try_update_towoo(false);
                    force_update();
                }
            err(errid)?
                jeapi::gui::form::errmsg("失败", F"复制文件失败({errid})");
            }
        }
        if (MenuItemEnabled("重命名", is_modifiable_file))
        {
            jeapi::gui::form::input("重命名", F"请输入{path.path}的新名称", F"{path.name}", 
                \newname: string = fsys::move(path.path, fsys::parent(path.path)/newname)
                    ->> func(_){context->get_project->try_update_towoo(false);force_update();}
                    ->or(\errid = jeapi::gui::form::errmsg("失败", F"重命名失败({errid})");););
        }
        if (MenuItemEnabled("删除", is_modifiable_file))
        {
            jeapi::gui::form::ask(F"删除{path.path}", F"是否继续删除{path.path}",
                func(sure: bool)
                {
                    if (!sure) return;
                    do fsys::remove(path.path)
                        ->> func(_){context->get_project->try_update_towoo(false);force_update();}
                        ->  or(\errid = jeapi::gui::form::errmsg("失败", F"删除失败({errid})");)
                        ;
                    do fsys::remove(fsys::parent(path.path) / (fsys::filename(path.path) + ".jecache4"));
                });
        }        
    }

    // 带图标的文件按钮
    func FileIcon(path: PathInfo, context: EditorContext)=> Action
    {
        BeginGroup();
            PushIDStr(path.path->tostring);
                let clicked = ImageButtonSize(get_file_icon_by_extern_name(path), 32., 32.);
            PopID();
            let right_click = IsItemClicked(ImGuiMouseButton::ImGuiMouseButton_Right);
            context_menu(option::value(path), context);
            if (BeginDragDropSource())
            {
                let ppath = context->get_project()->make_path_normalize(path.path);
                do SetDragDropPayload("JEDITOR_FILE_PATH", ppath);
                    Text(F"File: {ppath}");
                EndDragDropSource();
            }

            SameLine();
            Text(path.name);
        EndGroup();

        static let mut _last_click_time = std::time();

        if(clicked)
        {
            let _current_click_time = std::time();
            if (_current_click_time - _last_click_time < 0.2)
                return Action::DoubleClick;

            _last_click_time = _current_click_time;
            return Action::Click;
        }
        else if (right_click)
            return Action::RightClick;
        
        return Action::Nothing;
    }

    static let mut force_update_file_group_flag = false;
    static let mut force_update_dir_tree_flag = false;
    // 刷新显示的目录信息等...
    public func force_update()
    {
        force_update_dir_tree_flag = true;
        force_update_file_group_flag = true;
    }

    // 右边的文件详情等信息
    func files_group(context: EditorContext)
    {
        static let mut new_showing_path = "";
        static let mut now_item_in_path = []: array<PathInfo>;
        if (new_showing_path != current_work_path || force_update_file_group_flag)
        {
            new_showing_path = current_work_path;
            force_update_file_group_flag = false;
   
            func compare_method (a: PathInfo, b: PathInfo)
            {
                func is_dir(p){match(p.type->get){dir(_)?return true;file?return false;}}
                if (is_dir(a))
                    return !is_dir(b);
                else if (is_dir(b))
                    return false;

                if (a.externname != b.externname)
                    return a.externname < b.externname;
                return a.name < b.name;
            }

            now_item_in_path =
                fsys::subpath(fsys::normalize(current_work_path))
                    ->  unwarp
                    ->> \subpath = PathInfo{ 
                            path = subpath,
                            name = fsys::filename(subpath),
                            externname = fsys::extension(subpath),
                            type = new! mutable(fsys::isdir(subpath)
                                ? PathType::dir(option::none) 
                                | PathType::file),
                        };
                    ->std::sort(compare_method)
                    ;
        }

        do BeginChild("files_list");
            context_menu(option::none, context);
            do now_item_in_path
                -> forall(\item = !item->should_hide;)
                ->> \item = 
                    action == Action::Click 
                    ? (nil: void)
                    | action == Action::DoubleClick ? 
                        (item
                            ->indir(\_ = set_current_work_path(item.path);)
                            ->infile(\ = do item->get_open_method()(item, context)
                                        ->> \err = jeapi::gui::form::errmsg("失败", F"打开文件失败:\n{err}");
                                    ;)
                        ): void
                    | (nil: void) // get void
                    where action = FileIcon(item, context);
                ; 
        EndChild();
        if (BeginDragDropTarget())
        {
            match (AcceptDragDropPayload("JEDITOR_ENTITY_INSTANCE"))
            {
            value(drag_uid)?
                {
                    let eid = drag_uid as string: handle: jeapi::debug::Eeid;
                    eid->justdo(func(e){
                        match (jeapi::serialize::entity(e, false)=>>\dat = dat->serialize;)
                        {
                        value(entity_json)?
                            {
                                let filepath = fsys::normalize(current_work_path) / (e->editor::name + ".jeentity");
                                let prefab_data = e->towoo::get_component:<Editor::Prefab>;
                                if (fsys::exist(filepath))
                                {
                                    // 如果实体已经是预设体，那么拒绝覆盖已有的预设体以规避蛋疼的循环引用问题
                                    if (prefab_data->has)
                                        jeapi::gui::form::errmsg("无法覆盖预设体", "不允许已经为预设体的实体保存覆盖预设体文件");
                                    else
                                        jeapi::gui::form::ask("是否覆盖", F"文件{filepath->tostring}已存在，是否覆盖？",
                                            func(overwrite){
                                                if (overwrite)
                                                {
                                                    do fsys::writeall(filepath, entity_json);
                                                    eid->justdo(func(e)
                                                    {
                                                        let prefab = e->towoo::add_component:<Editor::Prefab>->val;
                                                        prefab.path->set(context->get_project->make_path_normalize(filepath));
                                                    });
                                                    force_update();
                                                }
                                            });
                                }
                                else
                                {
                                    let mut create = true;
                                    if (prefab_data->has)
                                    {
                                        if (prefab_data->val.path->get == context->get_project->make_path_normalize(filepath)
                                            || false == fsys::isfile(context->get_project->parse_path_normalize(prefab_data->val.path->get)))
                                        {
                                            create = false;
                                            jeapi::gui::form::errmsg("无法创建预设体", "变体原所属的预设体丢失");
                                        }
                                    }
                                    if (create)
                                    {
                                        do fsys::writeall(filepath, entity_json);
                                        let prefab = e->towoo::add_component:<Editor::Prefab>->val;
                                        prefab.path->set(context->get_project->make_path_normalize(filepath));
                                        force_update();
                                    }
                                }
                            }
                        none?
                            jeapi::gui::form::errmsg("失败", F"无法序列化实体{e->editor::name}");
                        }
                    });
                }
            none?
                ;
            }
            EndDragDropTarget();
        }
    }

    // 左侧的目录概况
    func path_tree(context: EditorContext)
    {
        let root_path = 
            context->get_project.m_path;

        if (current_work_path == "")
            current_work_path = root_path->tostring();

        static let _root = PathInfo {
                path = root_path,
                name = fsys::filename(root_path),
                externname = fsys::extension(root_path),
                type = new! mutable(PathType::dir(option::none)),
            };

        if (force_update_dir_tree_flag)
        {
            force_update_dir_tree_flag = false;

            // 强制更新，直接把缓存的子目录全部干掉
            _root.type->set(PathType::dir(option::none));
        }

        // 用于递归展示所有子目录等
        func _show_paths(path: PathInfo)
        {
            match (path.type->get)
            {
            PathType::dir(_)?
            {
                let mut attribute = TreeNodeAttribute::ImGuiTreeNodeFlags_OpenOnArrow 
                                + TreeNodeAttribute::ImGuiTreeNodeFlags_OpenOnDoubleClick 
                                + TreeNodeAttribute::ImGuiTreeNodeFlags_SpanAvailWidth;
                if (current_work_path == path.path->tostring)
                    attribute += TreeNodeAttribute::ImGuiTreeNodeFlags_Selected;

                let show_child = TreeNodeEx(F"{path.name}##p", attribute);
                if (IsItemClickedLeft() && !IsItemToggledOpen())
                    current_work_path = path.path->tostring;

                if (show_child)
                {
                    for (let _, subpath : path->childs(false))
                        _show_paths(subpath);

                    TreePop();
                }
                else
                    // 如果目录被折叠起来，则删除缓存，等待下次展开时重新获取
                    path.type->set(PathType::dir(option::none));
            }
            PathType::file?
                ; // path_tree只显示目录，跳过文件
            }
        }

        do BeginChildSize("path_tree", 200., 0.);
            _show_paths(_root);
        EndChild();
    }

    using LogHook = struct{
        m_logs: vec<(je::editor::loglevel, string)>,
        m_display_setting: dict<je::editor::loglevel, (string, mut bool, option<(int, int, int, int)>, mut int)>,
    }
    {
        func create()
        {
            return LogHook{
                m_logs = []mut,
                m_display_setting = {
                    [je::editor::loglevel::NORMAL] = ("普通", mut true, option::none, mut 0),
                    [je::editor::loglevel::INFO] = ("信息", mut true, option::value((0,255,127,255)), mut 0),
                    [je::editor::loglevel::WARNING] = ("警告", mut true, option::value((200,200,0,255)), mut 0),
                    [je::editor::loglevel::ERROR] = ("错误", mut true, option::value((200,0,0,200)), mut 0),
                    [je::editor::loglevel::FATAL] = ("致命", mut true, option::value((200,0,200,255)), mut 0),
                },
            };
        }
        func update(self: LogHook, context: EditorContext)
        {
            for (let _, e : context->get_logs)
            {
                self.m_logs->add(e);
                self.m_display_setting[e[0]][3] += 1;
            }
        }
        func clear(self: LogHook)
        {
            self.m_logs->clear;
            for (let _, e: self.m_display_setting)
            {
                e[3] = 0;
            }
        }
        func display_log(self: LogHook)
        {
            if (BeginChild("logbox"))
            {
                if (BeginChildSize("logbox_focus_loglevel", 100., 0.))
                {
                    if (Button("清除"))
                        self->clear;

                    for (let _, setting: self.m_display_setting)
                    {
                        do CheckBox(setting[0], setting[1])->>\c=setting[1] = c;;
                    }
                }
                EndChild();

                SameLine();
                let (avail_width, avail_height) = GetContentRegionAvail();
                if (BeginListBox("##", avail_width, avail_height))
                {
                    for (let mut i = self.m_logs->len; i > 0; i -= 1)
                    {
                        let (level, info) = self.m_logs[i - 1];
                        if (self.m_display_setting[level][1])
                        {
                            let color_setted = self.m_display_setting[level][2]
                                ->> \col = true where _ = PushStyleColor(ImGuiCol::ImGuiCol_Text, col);
                                ->  valor(false);
                            
                            do Selectable(F"[{self.m_display_setting[level][0]}] {info}");
                           
                            if (color_setted)
                                PopStyleColor();
                        }
                    }                       

                    EndListBox();
                }
            }
            EndChild();
        }
        func get_log_abstract(self: LogHook)
        {
            return self.m_display_setting
                -> forall(\_, v = v[3] > 0;)
                -> unmapping
                ->> \kv = F"{kv[1][0]} {kv[1][3]}";
                -> reduce(\l, r = l + " " + r;)
                -> valor("");
        }
    }
    public func show_logger(context: EditorContext, open: mutable<bool>)
    {
        if (open->get)
        {
            static let log_displayer = new! LogHook();

            je::gui::SetNextWindowSizeConstraints((500., 200.), (2000., 1100.));
            open->set(true);
            match (BeginAttrOpen("日志查看器", WindowsAttribute::ImGuiWindowFlags_NoBringToFrontOnFocus))
            {
            value(show)?
                if (show)
                {
                    PushStyleColor(ImGuiCol::ImGuiCol_Text, (75, 120, 200, 255));
                    Text(log_displayer->get_log_abstract);
                    PopStyleColor();
            
                    log_displayer->update(context);
            
                    log_displayer->display_log();
                }
            none?
                open->set(false);
            }

            End();  
        }
    }
    public func show_browser(context: EditorContext, open: mutable<bool>)
    {
        if (open->get)
        {
            je::gui::SetNextWindowSizeConstraints((500., 200.), (2000., 1100.));
            open->set(true);
            match (BeginAttrOpen("资源管理器", WindowsAttribute::ImGuiWindowFlags_NoBringToFrontOnFocus))
            {
            value(show)?
                if (show)
                {
                    path_tree(context);
                    SameLine();
                    BeginGroup();
                        do BeginChildSize("tools_bar", 0., 40.);
                            // TODO 此处放一些返回上一层之类的按钮
                            if (Button("U"))
                            {
                                current_work_path = 
                                    fsys::parent(fsys::normalize(current_work_path))->tostring;
                            }
                            SameLine();
                            Text(current_work_path);
                            SameLine();

                        EndChild();

                        files_group(context);
                    EndGroup();
                }
            none?
                open->set(false);
            }
                
            End();
        }
    }
}

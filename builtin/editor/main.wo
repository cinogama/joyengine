import pkg.crashhandler;
crashhandler::init();

import woo.std;
import woo.debug;

import pkg.filesystem;

import je;
import je.editor;

import builtin.api.welcome.main;
import builtin.api.gui.widget.icon_button;
import builtin.api.gui.form.msg;
import builtin.api.gui.form.input;
import builtin.editor.environment.main;
import builtin.editor.project.main;
import builtin.editor.gui.main;

jeapi::welcome::display_copyright_msg();

using je::gui;

let mut action_after_guide_form_closed = \ = do nil; as ()=> impure void;

using Path = struct {
    name: string,       // 仅用于显示
    path: filesys::path_t,
    childs: mut option<array<Path>>,
}
{
    func _get_available_root_paths()
    {
        // TODO: 这里只考虑Windows的A-Z盘符，什么AA AB AC，就算windows未来支持也给爷滚
        let arr = ["/"]mut;
        for (let mut ch = "A"->getch(0); ch <= "Z"->getch(0); ch += 1: char)
            arr->add([ch]->str + ":/");

        return arr
            ->  unsafe::cast:<array<string>>
            ->> \pname = filesys::normalize(pname);
            ->  forall(\path = filesys::isdir(path);)
            ->> \rootpath = Path
                {
                    name = rootpath->tostring(),
                    path = rootpath,
                    childs = mut option::none
                }
                ;
            ;
    }
    func childs(path: Path, update: bool)
    {
        if (update || !path.childs->has)
        {
            let arr = 
                filesys::subpath(path.path)
                    ->  unwarp
                    ->  forall(\child_path = filesys::isdir(child_path);)
                    ->> \child_path = Path
                        {
                            name = filesys::filename(child_path),
                            path = child_path,
                            childs = mut option::none
                        }
                        ;
            ;
            path.childs = option::value(arr);            
        }

        return path.childs->val;
    }
    func show(path: Path)=> option<filesys::path_t>
    {
        static let mut selected_path = option::none: option<filesys::path_t>;

        let show_child = TreeNodeEx(path.name, 
                TreeNodeAttribute::ImGuiTreeNodeFlags_OpenOnArrow 
                + TreeNodeAttribute::ImGuiTreeNodeFlags_OpenOnDoubleClick 
                + TreeNodeAttribute::ImGuiTreeNodeFlags_SpanAvailWidth
                + selected_path
                    ->map(\p = p->tostring == path.path->tostring;)
                    ->valor(false)
                    ->\b: bool = 
                        b   ? TreeNodeAttribute::ImGuiTreeNodeFlags_Selected
                            | TreeNodeAttribute::ImGuiTreeNodeFlags_None;);

        if (IsItemClickedLeft() && !IsItemToggledOpen())
            selected_path = option::value(path.path);

        if (show_child)
        {
            for (let _, child_path : path->childs(false))
                match(child_path->show())
                {
                value(result)?
                    selected_path = value(result);
                none?
                    ;
                }

            TreePop();
        }
        return selected_path;
    }
    func show_all()
    {
        static let roots = _get_available_root_paths();

        return roots
            =>> \path = r->has ? [r->val] | [] where r = path->show();
            ->  get(0)
            =>> \p = filesys::isdir(p) ? option::value(p) | option::none;
            ;
    }
}

func open_path_to_do_sth(action_after_choice: (option<filesys::path_t>)=>void)
{
    let mut open = BeginAttrOpen("加载或新建项目", 
        WindowsAttribute::ImGuiWindowFlags_AlwaysAutoResize);
    let (cur_width, _) = GetContentRegionAvail();
    Text("请选择项目文件所在的目录：");

    do BeginChildSize("SelectPathToCreateProject", 0., 300.);
    let select_path_to_create = Path::show_all();
    EndChild();

    if (ButtonSize("确认", (cur_width, 0.) ))
    {
        open = false;
        action_after_choice(select_path_to_create);
    }
    if (ButtonSize("取消", (cur_width, 0.) ))
        open = false;

    End();
    return open;
}

func read_editor_data()
{
    return filesys::readall(filesys::normalize(std::exepath())/"editor.dat")
        =>> \dat = dict::deserialize(dat);
        ->  valor({})
        ;
}

func apply_editor_data_when_start_up_project(dat: dict)
{
    let form_size = dat
        ->  getor("form_size": dynamic, [1344, 768]: dynamic) as array
        ->> \d = d as int;
        ;
    je::input::set_window_size(form_size[0], form_size[1]);
}
func save_editor_data_after_exit(dat: dict, proj_name: string, proj_path: filesys::path_t)
{
    let (win_w, win_h) = je::input::window_size();
    let project_histories = dat->getor("history": dynamic, []: dynamic) as array->unsafe::cast:< array<array<string>> >;
    
    let newdat = dat->tomap();
    newdat->set("form_size": dynamic, [win_w, win_h]: dynamic);
    newdat->set("history": dynamic, project_histories->forall(\record = record[1] != proj_path->tostring;)->inlay(0, [proj_name, proj_path->tostring]): dynamic);

    assert(
        filesys::writeall(filesys::normalize(std::exepath())/"editor.dat", newdat->serialize->val)
    );

    assert(filesys::setworkpath(filesys::normalize(std::exepath())));
}

func my_ask_for_get_yes_no_cancel_result(
    p: editor::Project,
    okevent: (int)=> void)
{
    // What a bull shit!
    
    using je::gui;
    using jeapi::gui;

    launch(func()
    {
        let mut open = BeginAttrOpen(F"退出？##{JobID()}", 
            WindowsAttribute::ImGuiWindowFlags_AlwaysAutoResize);

        if (open == false)
            okevent(-1);

        if (p->is_debugging)
        {
            TextDisabled("正在编辑模式中，请先退出编辑状态");
        }
        else
        {
            Text("即将退出编辑器，是否保存当前项目？");

            if (Button("是") || (IsWindowFocused() && inputmgr::keypush(je::keycode::ENTER)))
            {
                okevent(1);
                open = false;
            }
            SameLine();
            if (Button("否") || (IsWindowFocused() && inputmgr::keypush(je::keycode::BACKSPACE)))
            {
                okevent(0);
                open = false;
            }
            SameLine();
            if (Button("取消") || (IsWindowFocused() && inputmgr::keypush(je::keycode::ESC)))
            {
                okevent(-1);
                open = false;
            }
        }
        End();

        return open;

    }, ());
}

func ask_for_saving_proj_when_exit(p: editor::Project)
{
    static let mut shown = false;

    if (shown == false)
    {
        shown = true;
        my_ask_for_get_yes_no_cancel_result(p,
            func(op)
            {
                shown = false;
                if (op == 1)
                {
                    if (!p->save_project())
                    {
                        // 发生了一些事情，没有保存成功，弹框并且不退出
                        jeapi::gui::form::errmsg("失败", "项目保存未能完成");
                        return;
                    }
                }

                if (op != -1)
                    p->close();
            }
        );
    }
    return false;
}

func create_project_at(path: filesys::path_t, u: editor::Environment, editordat: dict, f: mutable<bool>)
{
    // 确保目录存在
    if (! filesys::exist(path))
        return jeapi::gui::form::errmsg("失败", F"创建项目失败，不存在的目录{path}");

    jeapi::gui::form::input("新项目命名", F"将在{path}创建新项目", "NewProject", 
        func(projname)
        {
            // 再次确保文件存在
            if (! filesys::exist(path))
                return do jeapi::gui::form::errmsg("失败", F"创建项目失败，不存在的目录{path}");

            let project_path = path / projname;
            match (filesys::mkdir(project_path))
            {
            err(errno)?
                return do jeapi::gui::form::errmsg("失败", F"创建项目失败，无法创建目录{project_path} ({errno})");
            ok(regular_path)?
                {
                    // OK, 关闭当前universe，关闭编辑器导航窗口，创建项目并保存到
                    u->close();
                    do f->set(false);
                    
                    je::editor::set_runtime_path(project_path->tostring);

                    action_after_guide_form_closed = 
                        func(){
                            apply_editor_data_when_start_up_project(editordat);

                            let p = editor::Project::create(projname, regular_path);
                            assert(p->save_project());

                            // 在此处创建资源目录，包含一些基本的资源和未来自动创建的资源
                            do filesys::mkdir(p.m_path/"resource");
                            do filesys::mkdir(p.m_path/"resource"/"texture");
                            do filesys::writeall(p.m_path/"resource"/"texture"/"readme.md", 
@"# Texture 目录
---
此目录用于保存引擎自动生成的图像资源
"@);
                            do filesys::copy(filesys::normalize(F"{std::exepath()}/builtin/shader"), filesys::normalize(F"{p.m_path}/resource/shader"));
                            do filesys::copy(filesys::normalize(F"{std::exepath()}/builtin/font"), filesys::normalize(F"{p.m_path}/resource/font"));
                            do filesys::writeall(p.m_path / ".gitignore", 
@"# JoyEngine ECS

/.export/*
imgui.ini
*.dmp
"@);
                            do filesys::writeall(p.m_path / ".gitattributes", 
@"# JoyEngine ECS

project.jeproj4 text eol=lf
config.jeinf text eol=lf
*.jeworld text eol=lf
*.jeentity text eol=lf
*.jecache4 !diff
"@);
                            je::gui::register_exit_callback(\=ask_for_saving_proj_when_exit(p););
                            editor::gui::edit_project(p);
                            save_editor_data_after_exit(editordat, p.m_name, p.m_path);
                            je::gui::unregister_exit_callback();
                        }
                    ;
                }
            }
        });
}

func open_project_at(path: filesys::path_t, u: editor::Environment, editordat: dict, f: mutable<bool>)
{
    let proj_path = path/"project.jeproj4";

    // 确保目录存在
    if (! filesys::exist(proj_path))
        return jeapi::gui::form::errmsg("失败", F"加载项目失败，找不到项目文件{proj_path}");
    
    match (filesys::readall(proj_path)=>> \d = dict::deserialize(d)->> \d = d->> \k,v = (k as string, v);;;)
    {
    value(dat)?
        {
            // OK, 关闭当前universe，关闭编辑器导航窗口，打开项目
            u->close();
            do f->set(false);

            je::editor::set_runtime_path(path->tostring());

            action_after_guide_form_closed = 
                func()
                {
                    apply_editor_data_when_start_up_project(editordat);

                    let p = editor::Project::load(path, dat);

                    je::gui::register_exit_callback(\=ask_for_saving_proj_when_exit(p););
                    editor::gui::edit_project(p);
                    save_editor_data_after_exit(editordat, p.m_name, p.m_path);
                    je::gui::unregister_exit_callback();
                }
            ;
        }
    none?
        return do jeapi::gui::form::errmsg("失败", F"打开项目失败，找不到或无效的项目文件");
    }

}

let u = editor::Environment::create();
{
    let editor_configs = read_editor_data();
    let historys = editor_configs->getor("history": dynamic, []: dynamic) as array->unsafe::cast:< array<array<string>> >;
   
    let w = u->create_world;
    do w->add_system(je::typeinfo::load("Graphic::UnlitGraphicPipelineSystem")->val);
    launch(func(){
        let open = mutable::create(true);

        do BeginAttr("JoyEngineECS 项目导航", WindowsAttribute::ImGuiWindowFlags_AlwaysAutoResize);
        Text("欢迎使用JoyEngine，请选择一项以开始");

        Separator();

        static let create_project_icon = je::graphic::texture::load(F"!/builtin/icon/JoyEngineCSP-Dev.png")->val;
        static let load_project_icon = je::graphic::texture::load(F"!/builtin/icon/JoyEngineCSP.png")->val;
        static let exit_editor_icon = je::graphic::texture::load(F"!/builtin/icon/joyengine.png")->val;
        
        if (jeapi::gui::widget::IconButton(create_project_icon, "创建新项目", (64., 64.), option::none))
        {
            launch(open_path_to_do_sth, (\p: option<filesys::path_t> = do p->> \path = create_project_at(path, u, editor_configs, open);;,));
        }
        if (jeapi::gui::widget::IconButton(load_project_icon, "加载一个项目", (64., 64.), option::none))
        {
            launch(open_path_to_do_sth, (\p: option<filesys::path_t> = do p->> \path = open_project_at(path, u, editor_configs, open);;,));
        }

        TextDisabled("历史项目");
        do BeginChildSize("##history", 0., 100.);

        for (let i, dat : historys)
        {
            if (jeapi::gui::widget::IconButton(load_project_icon, F"{dat[0]} ({dat[1]})", (16., 16.), option::none))
                open_project_at(filesys::normalize(dat[1]), u, editor_configs, open);
        }

        EndChild();

        if (jeapi::gui::widget::IconButton(exit_editor_icon, "退出编辑器", (64., 64.), option::none))
        {
            u->close();
            do open->set(false);
        }

        Separator();
        TextDisabled("(C)Cinogama project. 2022.");

        End();

        return open->get();
    }, ());
    u->wait();
}

action_after_guide_form_closed();
// NOTE: tickline 运行时在打包版本也需要运行，因此
//       不要让tickline依赖package？
import je;
import je.tickline;
import je.gui;

using je::tickline;

// Tickline Global Gaming Controlor.

namespace je::tickline
{
    public using Event = struct {
        m_func: ()=> void,
        m_trigger: ()=> bool,
    }
    {
        public func create(f: ()=> void, t: ()=> bool)
        {
            return Event{
                m_func = f,
                m_trigger = t,
            };
        }
        public func is_triggered(self: Event)
        {
            return self.m_trigger();
        }
        public func launch(self: Event)
        {
            return je::tickline::launch(self.m_func, ());
        }
    }
    public using Layer = struct {
        m_events: array<Event>
    }
    {
        public func create(es: array<Event>)
        {
            return Layer{
                m_events = es,
            };
        }
    }
}

namespace Tickline
{
    namespace Runtime
    {
        public using EventJobState = struct{
            m_event: Event,
            m_vm: je::tickline::VM,
            m_continue: mut bool,   // 当前事件是否执行到一半未执行完成？，
                                    // 如果是，则忽略事件本身的触发器
        }
        {
            public func create(e: Event)
            {
                return EventJobState{
                    m_event = e,
                    m_vm = e->launch(),
                    m_continue = mut false,
                };
            }
            public func dispatch(self: EventJobState)
            {
                if (self.m_continue == false || self.m_event->is_triggered())
                {
                    self.m_continue = false;

                    match (self.m_vm->dispatch())
                    {
                    ok(is_end)?
                        if (is_end == false)
                        {
                            self.m_continue = true;
                            return false;
                        }
                    err(reason)?
                        je::logerr(F"Tickline report an error: {reason}");
                    }
                }
                return true;
            }
        }
        public using LayerJobState = struct{
            m_event_jobs: array<EventJobState>
        }
        {
            public func create(layer : Layer)
            {
                return LayerJobState{
                    m_event_jobs = layer.m_events->>\e = EventJobState::create(e);,
                };
            }
            public func execute(self: LayerJobState)
            {
                let mut continue_next_layer = true;

                for (let _, job : self.m_event_jobs)
                {
                    if (job->dispatch() == false)
                        continue_next_layer = false;
                }

                return continue_next_layer;
            }
        }
        public using LayersAndEventsManager = struct {
            m_layers: array<LayerJobState>,
        }
        {
            public func create(layers : array<Layer>)
            {
                // 创建事件及触发器
                // NOTE: 感觉写得还是太复杂了，这破流程应该是可以简化的
                return LayersAndEventsManager{
                    m_layers = layers->>\layer = LayerJobState::create(layer);,
                };
            }
            public func execute(self: LayersAndEventsManager)
            {
                for (let _, layer : self.m_layers)
                {
                    if (layer->execute() == false)
                        // 如果某一层级报告当前层级事件未执行完毕，则停止执行剩余流程
                        return false;
                }
                return true;
            }
        }
    }

    // extern func Execute()
    // {
    //     // Tickline::Execute 
    //     // 将被引擎自底层的TicklineSystem调用
    //     // 需要注意，Tickline只会在渲染中世界所属的
    // }
}
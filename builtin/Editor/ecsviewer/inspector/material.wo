import woo.std;
import je.gui;
import je;

import builtin.Editor.generic.functions;

import builtin.Editor.generic.form.inputbox;
import builtin.Editor.generic.form.askbox;
import builtin.Editor.generic.form.msgbox;
import builtin.Editor.generic.widget.dragfile;


namespace editor::Inspector::Material
{
    union shader_option
    {
        AddShader(je::graphic::shader),
        DelShader,
        DoNothing,
    }
            
    func show_shader_menu()
    {
        using je::gui;

        let mut menu_option = shader_option::DoNothing;
        if (BeginPopupContextItem())
        {
            if (MenuItem("移除"))
                menu_option = shader_option::DelShader;

            EndPopup();
        }

        return menu_option;
    }

    func show_shader(entity: je::entity, shader: je::graphic::shader, index: int, expand: bool)=> shader_option
    {
        using je::gui;

        let attribute = 
              TreeNodeAttribute::ImGuiTreeNodeFlags_OpenOnArrow 
            + TreeNodeAttribute::ImGuiTreeNodeFlags_OpenOnDoubleClick 
            + TreeNodeAttribute::ImGuiTreeNodeFlags_SpanAvailWidth;

        let textures = entity->editor::graphic::get_textures();

        if (expand)
            SetNextItemOpen(true);

        let show_uniforms = TreeNodeEx(utils::ShortString(shader->path(), 25) + "##" + index:string, attribute);
        let mut shader_operation = show_shader_menu();

        match (generic::AcceptFileForCurrentWidget())
        {
            Drag(shader_path)?
            {
                let drag_append_new_shader = je::graphic::shader(shader_path);
                if (!drag_append_new_shader->has())
                    launch(generic::MsgBox, ("加载着色器失败", F"无法加载着色器: {shader_path}"));
                else
                    shader_operation = shader_option::AddShader(drag_append_new_shader->val());
            }
            None? /* 没有文件拖入，不干任何事情 */;
        }
        if (IsItemClicked() && !IsItemToggledOpen())
        {
            // TODO: 总得放点什么在这儿
        }
        if (show_uniforms)
        {
            let uniforms = shader->get_uniforms();
            for(let name, uniform_val : uniforms)
            {
                if (name->beginwith("JOYENGINE_"))
                    continue; // 引擎的内置shader-uniform变量，跳过显示

                match (uniform_val)
                {
                    integer(n)?
                        ;
                    float(x)?
                        ;
                    float2((x, y))?
                        ;
                    float3((x, y, z))?
                        ;
                    float4((x, y, z, w))?
                        ;
                    texture(id)?
                    {
                        let texture_path = 
                            textures->get(id)
                                    ->map(func(tex: je::graphic::texture){return tex->path()})
                                    ->valor(F"<没有绑定到通道{id}的纹理>");
                                
                        match (generic::DragFile(name, texture_path))
                        {
                            Drag(path)?
                            {
                                // 拖动文件到这里，加载这个纹理，然后绑定
                                let new_texture = je::graphic::texture(path);
                                match (new_texture)
                                {
                                    value(tex)?
                                        entity->editor::graphic::bind_texture(id, tex);
                                    none?
                                        launch(generic::MsgBox, ("加载纹理失败", F"无法加载纹理: {path}"));
                                }
                            }
                            None?
                                ; // 没任何变化，啥也不干
                        }
                    }
                    others?
                        Text(F"<不受支持的uniform类型> {name}");
                }
            }
            TreePop();
        }
        return shader_operation;
    }
    public func show(cur_entity : option<je::entity>, max_height: real)
    {
        using je::gui;

        static let mut _last_display_entity = option::none: option<je::entity>;

        let _display_entity_changed = 
            _last_display_entity
                ->map(\e: je::entity = cur_entity->map(\ce: je::entity = e != ce;);)
                ->reduce()
                ->valor(true);

        _last_display_entity = cur_entity; // 

        BeginChild("material_editor", 0., max_height);
            Text("材质编辑器");
            Separator();
            match (cur_entity)
            {
                value(current_entity)?
                {
                    static let ShadersTypeID = je::typeinfo("Renderer::Shaders")->val();
                    match (current_entity->editor::get_component(ShadersTypeID))
                    {
                        value(shaders)?
                        {
                            let shaders = current_entity->editor::graphic::get_shaders();

                            let mut index = 0, mut shaders_has_updated = false;
                            for (let shader : shaders->dup())
                            {
                                match (show_shader(current_entity, shader, index, _display_entity_changed))
                                {
                                    AddShader(shad)?
                                    {
                                        shaders->insert(index, shad);
                                        shaders_has_updated = true;
                                    }
                                    DelShader?
                                    {
                                        shaders->remove(index);
                                        shaders_has_updated = true;
                                    }
                                    DoNothing? /* 没有动作 */;
                                }
                                index += 1;
                            } // end show shader.

                            Text("[拖动shader文件到此处添加新的pass]");
                            match (generic::AcceptFileForCurrentWidget())
                            {
                                Drag(shader_path)?
                                {
                                    let drag_append_new_shader = je::graphic::shader(shader_path);
                                    if (!drag_append_new_shader->has())
                                        launch(generic::MsgBox, ("加载着色器失败", F"无法加载着色器: {shader_path}"));
                                    else
                                    {
                                        // 强行让编辑器展开所有shader
                                        _last_display_entity = option::none;

                                        shaders->add(drag_append_new_shader->val());
                                        shaders_has_updated = true;
                                    }
                                }
                                None? /* 没有文件拖入，不干任何事情 */;
                            }

                            if (shaders_has_updated)
                                current_entity->editor::graphic::set_shaders(shaders);
                        }
                        none?
                            Text("当前实体没有Renderer::Shaders组件");
                    }
                }
                none?
                    Text("<没有选中可编辑的实体>");
            } // end match
        EndChild();
    }
}
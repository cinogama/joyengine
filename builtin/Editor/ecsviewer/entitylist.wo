import woo.std;
import je.gui;
import je;

import builtin.Editor.generic.form.inputbox;
import builtin.Editor.generic.form.askfor;

import entitycreator;

namespace editor::EntityList
{
    // 当前世界列表是否显示有当前选中的实体，如果没有就重设当前实体，防止错误的显示
    private let mut _has_selected_entity = false;

    private func menu()
    {
        using je::gui;
        if (BeginMenuBar())
        {
            if (MenuItem("创建新实体"))
                launch(EntityCreator::show, (EntityCreator::create_context(),));

            EndMenuBar();
        }
    }

    private func context_menu(entity: je::entity)
    {
        using je::gui;
        if (BeginPopupContextItem())
        {
            MenuItem(F"实体 {entity->editor::chunkinfo()}", false);
            Separator();
            if (MenuItem(F"删除 {entity->editor::name()}"))
            {
                launch(generic::AskFor, ("删除实体",
                                        F"确认要删除实体{entity->editor::name()}吗？",
                                        \ = entity->close();));
            }
            if (MenuItem("重命名"))
            {
                launch(generic::InputBox, ("重命名实体",
                                        F"请输入新名称",
                                        entity->editor::name(),
                                        \text: string = entity->editor::name(text);));
            }
            if (MenuItem("编辑组件"))
            {
                launch(EntityCreator::show, (EntityCreator::edit_context(entity),));
            }
            EndPopup();
        }
    }

    func show(ref open: bool)
    {
        using je::gui;
        if(!open) return FormAction::Close;

        _has_selected_entity = false;
        Begin("层级面板", WindowsAttribute::ImGuiWindowFlags_MenuBar
                        + WindowsAttribute::ImGuiWindowFlags_AlwaysAutoResize
                    , ref open);
            menu();
                
            match(je::world::rend())
            {
                value(current_world)?
                {
                    let top_entity_walker = current_world->editor::top_entity_iter();
                    if (_display_entity_with_iter(top_entity_walker) == 0)
                        Text("当前世界没有实体");
                } 
                none?
                    ; // do nothing
            }  
                
        End();
        if (!_has_selected_entity)
            set_current_entity(option::none:<je::entity>);
                
        if (!open)
            return FormAction::Close;
        return FormAction::Nothing;
    }

    func set_current_entity(current_entity: option<je::entity>)
    {
        je::entity::editor::set_editing(current_entity);
    }

    func get_current_entity()
    {
        return je::entity::editor::editing();
    }

    // 实体的UID表，根据uid获取实体实例
    private let mut uid_entity_map = {}: map<string, je::entity>;

    // 检查给定checking实体是否是cur实体的祖实体
    private func is_ancestor(cur: je::entity, checking: je::entity)
    {
        match(checking->editor::get_uid())
        {
        value(uid)?
        {
            let mut e = option::value(cur);
            while(true)
            {
                match (e->map(\ent: je::entity = ent->editor::get_uid();)->reduce())
                {
                value(current_uid)?
                    if (current_uid == uid)
                        return true;
                    else
                        e = e->map(\ent: je::entity = ent->editor::get_parent_uid();)
                             ->reduce()
                             ->map(\puid: string = uid_entity_map->get(puid);)
                             ->reduce();
                none?
                    return false;
                }
            }
        }
        none?
            // 指定的祖实体没有锚点，肯定没有子实体
            return false;
        }
    }

    private func set_parent(child: je::entity, parent: je::entity)
    {
        using je::gui;

        static let ChildAnchor   = je::typeinfo("Transform::ChildAnchor")->val(),
                   LocalToParent = je::typeinfo("Transform::LocalToParent")->val(),
                   LocalToWorld  = je::typeinfo("Transform::LocalToWorld")->val();

        let add_to_e_component_t = []: array<je::typeinfo>;
        let remove_from_e_component_t = []: array<je::typeinfo>;
        let add_to_c_component_t = []: array<je::typeinfo>;

        // 移除子实体的L2W组件
        if (child->editor::get_component(LocalToWorld)->has())
            remove_from_e_component_t->add(LocalToWorld);

        // 向子实体添加L2P组件
        if (!child->editor::get_component(LocalToParent)->has())
            add_to_e_component_t->add(LocalToParent);

        // 向父实体添加ChildAnchor
        if (!parent->editor::get_component(ChildAnchor)->has())
            add_to_c_component_t->add(ChildAnchor);

        if (add_to_e_component_t->empty() && remove_from_e_component_t->empty() && add_to_c_component_t->empty())
            // 待添加/移除的组件都已经处理，直接变更父子关系
            child->editor::set_parent(parent, false);
        else
        {
            let mut msg = "即将变更父子变换实体，以下变更将会发生：\n";

            msg += F"父实体 {parent->editor::name()}\n";
            if (!add_to_c_component_t->empty())
            {
                msg += " 添加以下组件\n";
                for (let ctype : add_to_c_component_t)
                    msg += F"  {ctype->name()}\n";
            }

            msg += F"子实体 {child->editor::name()}\n";
            if (!add_to_e_component_t->empty() || !remove_from_e_component_t->empty())
            {
                if (!add_to_e_component_t->empty())
                {
                    msg += " 添加以下组件\n";
                    for (let ctype : add_to_e_component_t)
                        msg += F"  {ctype->name()}\n";
                }
                if (!remove_from_e_component_t->empty())
                {
                    msg += " 移除以下组件\n";
                    for (let ctype : remove_from_e_component_t)
                        msg += F"  {ctype->name()}\n";
                }
            }
                                
            launch(generic::AskFor, ("变更父子实体", msg + "是否确认?", \ = child->editor::set_parent(parent, true);));
        }
    }
    private func _display_entity_with_iter(entity_iter: je::entity::editor::entity_iter)=> int
    {
        using je::gui;

        let mut current_uid_entity_map = {}: map<string, je::entity>;
        
        let mut display_count = 0;
        for (let entity : entity_iter)
        {
            // 如果当前实体有uid组件，那么添加一下
            entity
                ->editor::get_uid()
                ->map(\x: string = current_uid_entity_map[x] = entity;);

            display_count += 1;
            
            // 如果实体有 Editor::Invisable 这个组件，就跳过显示
            static let INVISABLE = je::typeinfo("Editor::Invisable")->val();
            if (entity->editor::get_component(INVISABLE)->has())
                continue;

            let mut entity_name = entity->editor::name();
            if (entity_name == "")
                entity_name = "<匿名实体>";

            let mut attribute = 
                TreeNodeAttribute::ImGuiTreeNodeFlags_OpenOnArrow 
                + TreeNodeAttribute::ImGuiTreeNodeFlags_OpenOnDoubleClick 
                + TreeNodeAttribute::ImGuiTreeNodeFlags_SpanAvailWidth;

            match (get_current_entity())
            {
                value(selected_entity)?
                    if (selected_entity == entity)
                    {
                        _has_selected_entity = true;
                        attribute += TreeNodeAttribute::ImGuiTreeNodeFlags_Selected;
                    }
                none?
                    ; // 没有选中的实体，啥也不干
            }

            let shown_child = TreeNodeEx(F"{entity_name}##{entity->editor::chunkinfo()}", attribute);
            // 支持拖动和接受，用于快速变更子实体
            if (BeginDragDropSource())
            {
                SetDragDropPayload("JEDITOR_ENTITY_INSTANCE", entity->editor::chunkinfo());
                    Text(F"Entity: {entity->editor::name()}");
                EndDragDropSource();
            }
            if(BeginDragDropTarget())
            {
                let mut drag_entity_chunkinfo = "";
                if (AcceptDragDropPayload("JEDITOR_ENTITY_INSTANCE", ref drag_entity_chunkinfo))
                {
                    if (drag_entity_chunkinfo != entity->editor::chunkinfo())
                    {
                        // 自己拖到自己身上肯定就寄了，只处理不同的实体。
                        // TODO: 支持逆转父子关系

                        match(je::entity::editor::find_entity_by_chunkinfo(drag_entity_chunkinfo))
                        {
                        value(child_e)?
                            set_parent(child_e, entity);
                        none? /*拖过来的实体已经寄了，跳过*/ ;
                        }
                    }
                }
                EndDragDropTarget();
            }

            context_menu(entity);
            if (IsItemClicked() && !IsItemToggledOpen())
            {
                _has_selected_entity = true; // 也在这里设置一下
                set_current_entity(option::value(entity));
            }

            if(shown_child)
            {
                _display_entity_with_iter(entity_iter->childs());
                TreePop();
            }
        }
        uid_entity_map = current_uid_entity_map;

        return display_count;
    }
}

import woo.std;
import woo.debug;

import je.gui;
import je;
import je.filesys;

import ecsviewer.worldlist;
import ecsviewer.entitylist;
import ecsviewer.inspector;

import system.browser;

import script_editor;

import generic.form.askbox;           
import generic.form.msgbox;
import generic.shortcut;

import project.config;
import project.init;
import project.serialize;

import test.memleak_component_modify;
import test.memleak_world_lifecycle;
import test.memleak_graphic_resource;

using je::gui;
using editor;
using generic;

shortcut::register([je::keycode::L_CTRL, je::keycode::W,], func(){
    static let mut shown = false;
    shown = !shown;
    if (shown)
        launch(WorldList::show, (ref shown,));
});
shortcut::register([je::keycode::L_CTRL, je::keycode::E,], func(){
    static let mut shown = false;
    shown = !shown;
    if (shown)
        launch(EntityList::show, (ref shown,));
});
shortcut::register([je::keycode::L_CTRL, je::keycode::I,], func(){
    static let mut shown = false;
    shown = !shown;
    if (shown)
        launch(Inspector::show, (ref shown,));
});
shortcut::register([je::keycode::L_CTRL, je::keycode::B,], func(){
    static let mut shown = false;
    shown = !shown;
    if (shown)
        launch(Browser::show, (ref shown,));
});
shortcut::register([je::keycode::L_CTRL, je::keycode::A,], 
    \=je::logfatal("TODO: 添加实体菜单尚未实现"););
shortcut::register([je::keycode::L_CTRL, je::keycode::S,], func(){
    match(Project::GetCurrentProject()->SaveProject())
    {
    ok(_)?
        launch(MsgBox, ("保存项目成功", "项目及世界的变更已应用"));
    err(msg)?
        launch(MsgBox, ("保存项目失败", msg));
    }
});

namespace logmgr
{
    let log_buffers = {
        [je::editor::loglevel::NORMAL]  = []mut,
        [je::editor::loglevel::INFO]    = []mut,
        [je::editor::loglevel::WARNING] = []mut,
        [je::editor::loglevel::ERROR]   = []mut,
        [je::editor::loglevel::FATAL]   = []mut,
    }: dict<je::editor::loglevel, vec<string>>;

    let log_level_name = {
        [je::editor::loglevel::NORMAL]  = "普通",
        [je::editor::loglevel::INFO]    = "信息",
        [je::editor::loglevel::WARNING] = "警告",
        [je::editor::loglevel::ERROR]   = "错误",
        [je::editor::loglevel::FATAL]   = "致命",
    };

    let mut last_log = option::none: option<(je::editor::loglevel, string)>;

    // 拉取日志，更新到buffers里面
    func update_buffers()
    {
        let this_time_log = je::editor::getlogs();
        for (let (t, s) : this_time_log)
            log_buffers[t]->insert(0, s);

        if (!this_time_log->empty)
            return last_log = option::value(this_time_log[this_time_log->len - 1]);

        return last_log;
    }
    // 获取日志的数量
    func get_log_count()=> (int, int, int, int, int)
    {
        let result = [mut 0, 0, 0, 0, 0];

        // 如果level超出0-5的范围，直接panic
        log_buffers
            ->unmapping
            ->trans(\logs: (je::editor::loglevel, vec<string>) = 
                result[logs[0]:int] = logs[1]->len;);

        return (result[0], result[1], result[2], result[3], result[4]);
    }

    // log显示菜单，仅用于展示log列表信息
    func show_log()
    {
        if (MenuItem("清除所有"))
        {
            last_log = option::none;
            log_buffers
                ->vals
                ->trans(\v: vec<anything> = v->clear;);
        }
        Separator();
        for (let k, v : log_buffers)
        {
            if (BeginMenu(F"{log_level_name[k]}({v->len})", !v->empty))
            {
                func get_title_of_error(msg: string)
                {
                    let switch_line_place = msg->find("\n");
                    if (switch_line_place !=- 1)
                        return msg->sub(0, switch_line_place);
                    return msg;
                }
                for (let msg : v)
                {
                    MenuItem(msg->get_title_of_error->utils::ShortStringCutEnd(60));
                    if (IsItemHovered())
                        SetTooltip(msg);
                }
                EndMenu();
            }
        }

        
        return FormAction::Nothing;
    }
}

// 这个是编辑器上方的主菜单栏
func Editor_MainMenuBar()
{
    using je::gui;

    let mut show_main_menu = true;

    // 刷新检测热键
    shortcut::update();

    // 拉取一下log信息
    let last_log_info = logmgr::update_buffers();

    BeginMainMenuBar();
    if (BeginMenu("JoyEngine"))
    {
        MenuItem("新建");
        MenuItem("打开");
        if (MenuItem("保存", "Ctrl + S"))
            shortcut::active([je::keycode::L_CTRL, je::keycode::S]);

        Separator();
        if (MenuItem("退出"))
            checkbox("确认退出", "即将关闭JoyEngine，是否需要保存项目？", 
            // 选择是，执行保存操作，完成后退出
            func(){
                match(Project::GetCurrentProject()->SaveProject())
                {
                ok(_)?
                    je::exit();
                err(msg)?
                    launch(MsgBox, ("保存项目失败", msg));
                }
            }, 
            // 选择否，直接退出
            je::exit);

        EndMenu();
    }
    if (BeginMenu("编辑", false))
    {
        EndMenu();
    }
    if (BeginMenu("视图"))
    {
        if (MenuItem("世界列表", "Ctrl + W"))
            shortcut::active([je::keycode::L_CTRL, je::keycode::W]);
        if (MenuItem("层级面板", "Ctrl + E"))
            shortcut::active([je::keycode::L_CTRL, je::keycode::E]);
        if (MenuItem("检视面板", "Ctrl + I"))
            shortcut::active([je::keycode::L_CTRL, je::keycode::I]);
        Separator();
        if (MenuItem("文件管理器", "Ctrl + B"))
            shortcut::active([je::keycode::L_CTRL, je::keycode::B]);


        EndMenu();
    }
     if (BeginMenu("脚本"))
    {
        static let mut editor_opened = false;

        if (MenuItem("打开快捷编辑器", ref editor_opened, true) && editor_opened)
            launch(Editor_ScriptEditor, (ref editor_opened,));

        EndMenu();
    }
    if (BeginMenu("帮助"))
    {
        static let mut about_shown = false;
        if (MenuItem("关于", ref about_shown, true) && about_shown)
            launch(Editor_Welcome, (ref about_shown,));

        EndMenu();
    }
    if (BeginMenu("DEBUG"))
    {
        if (MenuItem("关闭主菜单栏"))
            show_main_menu = false;

        if (MenuItem("序列化当前世界"))
            match (je::world::rend())
            {
                value(w)?
                    std::println(
                        editor::Serialize::save_project_world(
                            Project::GetCurrentProject()->FindWorld(w)->val()));
                none?
                    std::println("序列化个锤子！没有世界！");
            }
        if (MenuItem("内存泄漏测试（组件增删改查）"))
            launch(test::memory_leak::ComponentModify::show, ());
        if (MenuItem("内存泄漏测试（世界生命周期）"))
            launch(test::memory_leak::WorldLifecycle::show, ());
        if (MenuItem("内存泄漏测试（图形系统资源）"))
            launch(test::memory_leak::GraphicResource::show, ());
        if (MenuItem("启用全屏"))
            je::editor::restart_graphic_interface("DEBUG",
                1920, 1080, 60, true);
        if (MenuItem("还原窗口"))
        {
            let (win_width, win_height) = je::input::windowsize();
            je::editor::restart_graphic_interface("DEBUG",
                win_width, win_height, 60, false);
        }
            
        EndMenu();
    }
    let (normal, info, warning, error, fatal) = logmgr::get_log_count();

    // todo 这个返回一个元组的设计太蠢了
    let msg = [("普通", normal), ("信息", info), ("警告", warning), ("错误", error), ("致命", fatal)]
        ->forall(\msg: (string, int) = msg[1] > 0;)
        ->trans(\msg: (string, int) = F"{msg[0]}:{msg[1]} ";)
        ->reduce(\lmsg: string, rmsg: string = lmsg + rmsg;);

    if (BeginMenu(msg->valor("暂无日志")->trim 
        + last_log_info
            ->map(\loginfo:(je::editor::loglevel, string)=
                F" [{logmgr::log_level_name[loginfo[0]]}: {loginfo[1]}]";)
            ->valor("")
            ->utils::ShortStringCutEnd(60)))
    {
        logmgr::show_log();
        EndMenu();
    } 

    EndMainMenuBar();

    if (!show_main_menu)
        return FormAction::Close;
    return FormAction::Nothing;
}

// 关于信息窗口
func Editor_Welcome(ref open: bool)
{
    if (!open)
        return FormAction::Close;

    Begin("欢迎", WindowsAttribute::ImGuiWindowFlags_NoResize);
    Text("欢迎使用JoyEngineECS.");
    Separator();
    Text("Copyright (C)Cinogama project. 2022.");
    Text("Powered by WooLang (C)Cinogama project. 2022.");
    Text("所使用的第三方库包括glew、glfw、imgui及stb的相关信息见版权页");
    if (Button("确认"))
        open = false;
    End();

    if (!open)
        return FormAction::Close;
    return FormAction::Nothing;
}

/////////////////////

func display_icon_in_console()
{
    using je::graphic;

    func display_text(f: font, msg: string)
    {
        let chtex = f->load_string(msg);
        let (width, height) = chtex->size;

        let mut display_bar = "-";
        for (let mut x = 0; x < width; x += 1)
            display_bar += "--";

        je::log(display_bar);
        for (let mut y = 0; y < height; y += 1)
        {
            let mut out_line = "";
            for (let mut x = 0; x < width; x += 1)
                out_line += chtex->pix(x, y)->color[3] <= 0.175 ? "  " | "■";

            je::log(F"{out_line}|");
        }
        je::log(display_bar);

        chtex: gchandle->close();
        f: gchandle->close();
    }

    font(@"builtin/cino_ipix_12px.ttf"@, 14)
        ->map(\f: font = display_text(f, text)
                where text = "Joy{scale:0.75}{offset:(0.2, -0.1)}4.x{scale:1}\nEngine";);
    je::log("");
    je::log("JoyEngine 4.x (C)Cinogama project. 2022.");
    je::log("Powered by woolang, (C)Cinogama project. 2021-2022.");
}

/////////////////////

/////////////////////

display_icon_in_console();
editor::Project::Start(Editor_MainMenuBar, ());

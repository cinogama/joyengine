import woo.std;
import je;
import je.gui;

import serialize;

namespace editor
{
    public using Project = struct {
        name : string,          // 项目名称
        path : option<string>,  // 项目文件的路径，默认项目没有这个值
        worlds : vec<Project::World>,

        graphic_system : je::typeinfo,    // 默认使用的图形系统类型
        editor_system  : je::typeinfo,    // 默认使用的编辑器系统类型
    };
}

const let  
    DEFAULT_GRAPHIC_SYSTEM_NAME = "Graphic::DefaultGraphicPipelineSystem",
    DEFAULT_EDITOR_SYSTEM_NAME = "Editor::DefaultEditorSystem";

let mut hooked_log_handle = (-1): handle;

namespace editor::Project
{
    // 用于储存项目中的世界信息，包括世界所在的路径和运行时系统信息
    public using World = struct {
        mut path : option<string>, // 已经保存的世界会有路径，在关闭世界时，如果一个世界没有路径，那么这个世界会从项目里移除
        instance : je::world,  // 世界实例
        runtime_systems : vec<je::typeinfo>, // 运行时系统列表，世界载入作为游戏运行时就会把里面的系统实例化出来
    }
    {
        public func Save(self: World)
        {
            // Saving 
            // 肯定要有路径，不然直接爆炸
            if (!je::file::writeall(self.path->val, 
                Serialize::save_project_world(self): string))
            {
                je::gui::launch(generic::MsgBox, 
                    (F"保存世界{self.instance->editor::name()}失败",
                     F"无法写入世界数据到{self.path->val}"));
                return false;
            }
            return true;
        }
        public func SaveTo(self: World, path: string)
        {
            let real_saving_path = je::filesys::isdir(path) 
                ? F"{path}/{self.instance->editor::name()}.jeworld" 
                | path ;
            let save_request =
                self.path
                    ->map(\oldpath: string = 
                        oldpath == real_saving_path 
                        ? result::ok(oldpath)
                        | result::err((oldpath, real_saving_path));)
                    ->or(\=result::ok(real_saving_path);)
                    ->val;

            let mut ask_msg = "";

            match(save_request)
            {
            ok(saving_path)?
            {
                // 目录符合或者干脆是尚未保存的世界，简单询问一下
                ask_msg = F"正在将世界{self.instance->editor::name()}保存到{
                     saving_path}\n是否继续？";
            }
            err((oldpath, saving_path))?
                // 目录存疑，弹个框框问一下
                ask_msg = 
                     F"正在将世界{self.instance->editor::name()}保存到{
                     saving_path}\n但此前这个世界已被保存到{
                     oldpath}\n是否继续？";
            }

            generic::askbox("保存世界？", ask_msg, func(){
                self.path = option::value(real_saving_path);
                self->Save();
            });
        }
    }

    // 在当前项目中创建一个世界，世界会被保存进项目的世界列表中
    public func CreateWorld(self: Project)
    {
        let world_instance = je::universe::current()->create_world();

        // 创建调试摄像机组
        // 父对象，负责带着摄像机运动，同时负责y轴旋转
        let camera_walker = world_instance->add_entity([
            // Transform 族组件
            je::typeinfo("Transform::LocalPosition")->val,
            je::typeinfo("Transform::LocalRotation")->val,
            je::typeinfo("Transform::LocalToWorld")->val,
            je::typeinfo("Transform::Translation")->val,
            je::typeinfo("Transform::ChildAnchor")->val,
            // Editor 族组件
            je::typeinfo("Editor::Invisable")->val,
            je::typeinfo("Editor::EditorWalker")->val,
        ]);
        // 摄像机，同时负责x轴旋转
        let editor_camera = world_instance->add_entity([
            // Transform 族组件
            je::typeinfo("Transform::LocalRotation")->val,
            je::typeinfo("Transform::LocalToParent")->val,
            je::typeinfo("Transform::Translation")->val,
            // Editor 族组件
            je::typeinfo("Editor::Invisable")->val,
            je::typeinfo("Editor::EditorWalker")->val,
            // Camera 族组件
            je::typeinfo("Camera::PerspectiveProjection")->val,
            je::typeinfo("Camera::Projection")->val,
        ]);
        editor_camera->editor::set_parent(camera_walker, true);
        camera_walker->editor::name("调试摄像机组");
        editor_camera->editor::name("调试摄像机");

        // 移动器，这里只创建根实体，具体的轴由编辑器系统生成
        let entity_mover = world_instance->add_entity([
            // Transform 族组件
            je::typeinfo("Transform::LocalPosition")->val,
            je::typeinfo("Transform::LocalRotation")->val,
            je::typeinfo("Transform::LocalScale")->val,
            je::typeinfo("Transform::ChildAnchor")->val,
            je::typeinfo("Transform::Translation")->val,
            je::typeinfo("Transform::LocalToWorld")->val,
            // Editor 族组件
            je::typeinfo("Editor::Invisable")->val,
            je::typeinfo("Editor::EntityMoverRoot")->val,
        ]);

        let world = World{
            path = option::none,
            instance = world_instance,
            runtime_systems = []mut,
        };

        self.worlds->add(world);
        return world;
    }

    // 从文件中读取世界数据
    public func LoadWorld(self: Project, path: string)=> option<World>
    {
        // 检查一下项目里是不是已经有同路径的世界在运行了
        let index = self.worlds->findif(\w: World = w.path->has 
            ? w.path->val == path
            | false;);
        if (index != -1)
        {
            generic::msgbox("加载世界失败", F"世界'{path}'已在编辑中，不能重复加载");
            return option::none;
        }

        return je::file::readall(path)
            ->bind(\d: string = d->todict;)
            ->bind(\d: dict<dynamic, dynamic> = Serialize::restore_world(self, d););
    }

    public func CloseWorld(self: Project, world: je::world)
    {
        self->FindWorld(world)
            ->map(\w: World = self.worlds->remove(self.worlds->find(w)););

        world->close;
    }

    public func FindWorld(self: Project, world: je::world)=> option<World>
    {
        for (let project_world : self.worlds)
            if (project_world.instance == world)
                return option::value(project_world);

        je::logwarn("发现一个未被列入项目中的游离世界：", world->editor::name());
        return option::none;
    }

    private let mut _current_project = option::none : option<Project>;

    public func SetCurrentProject(self: Project)
    {
        // 不可以重复设置当前项目，设置前应当清除旧的项目
        assert(false == _current_project->has);

        _current_project = option::value(self);
        return self;
    }

    func RemoveCurrentProject()
    {
        assert(_current_project->has);

        let proj = _current_project->val;
        je::loginfo(F"关闭当前项目: {proj.name}");
        for (let w : proj.worlds)
        {
            je::loginfo(F"关闭项目中所属的世界：{w.instance->editor::name}");
            w.instance->close;
        }

        _current_project = option::none;
    }

    private func CreateDefaultProject()
    {
        return SetCurrentProject(Project{
            name = "Default project",
            path = option::none, // 默认项目不带有path信息，这种项目是不可以被用于保存的
            // NOTE: 默认系统应该内置在引擎里，如果获取不到这里直接爆炸
            graphic_system = je::typeinfo(DEFAULT_GRAPHIC_SYSTEM_NAME)->val,
            editor_system = je::typeinfo("Editor::DefaultEditorSystem")->val,
            worlds = []mut,
        });
    }

    public func CreateProject(name: string, path: string, create_file: bool)
    {
        let created_project = Project{
            name = name,
            path = option::value(je::filesys::normalize(path)),
            graphic_system = je::typeinfo(DEFAULT_GRAPHIC_SYSTEM_NAME)->val,
            editor_system = je::typeinfo(DEFAULT_EDITOR_SYSTEM_NAME)->val,
            worlds = []mut,
        };

        if (create_file)
        {        
            assert(!je::filesys::exist(path));

            // 1. 创建项目目录，把所需的文件拷贝进去
            if (!je::filesys::mkdir(path))
                return result::err("创建项目目录失败");

            // 2. 写入项目数据文件
            match (created_project->SaveProject)
            {
            ok(projdat)?
                ;
            err(msg)?
                return result::err(msg);
            }
        }
        else
            assert(je::filesys::isdir(path));

        // ok 创建完成，销毁之前的项目上下文
        RemoveCurrentProject();

        if (hooked_log_handle == (-1): handle)
            hooked_log_handle = je::editor::hooklog();
        return result::ok(SetCurrentProject(created_project));
    }
    public func UnhookLogWhenExit()
    {
        if (hooked_log_handle != (-1): handle)
            je::editor::unhooklog(hooked_log_handle);
        hooked_log_handle = (-1): handle;
    }
    public func LoadProject(data: dict<dynamic, dynamic>)
    {
        using je;

        // 从项目信息加载并创建项目
        let proj_name = data["name": dynamic] as string->trim;
        let proj_path = data["path": dynamic] as string;

        match (CreateProject(proj_name, proj_path, false))
        {
        ok(proj)?
        {
            let runtime_worlds = data["worlds": dynamic] as array<dynamic>;

            let window_info = data->get("window": dynamic, {}: dynamic) as map<dynamic, dynamic>;
            let window_size = window_info->get("size": dynamic, [640, 480]: dynamic) as array<dynamic>;

            // 加载自定义的图形和编辑时系统
            let graphic_system = data
                ->get("graphic_system": dynamic)
                ->map(\n: dynamic = typeinfo(n as string);)
                ->or(\ = je::typeinfo(DEFAULT_GRAPHIC_SYSTEM_NAME);)
                ->reduce
                ->val;
            let editor_system = data
                ->get("editor_system": dynamic)
                ->map(\n: dynamic = typeinfo(n as string);)
                ->or(\ = je::typeinfo(DEFAULT_EDITOR_SYSTEM_NAME);)
                ->reduce
                ->val;

            je::editor::restart_graphic_interface(F"JoyEngine 4.0 - {proj_name}",
                window_size[0]: int, window_size[1]: int, 60, false);
            // je::input::windowsize(window_size[0]: int, window_size[1]: int);

            runtime_worlds
                ->trans(\p: dynamic = p as string;)
                ->trans(\path: string = proj->LoadWorld(path););

            if (proj.worlds->empty)
            {
                // 无论何种原因导致没有正在编辑的世界，给他创建一个
                let default_world = proj->CreateWorld().instance;
                default_world->editor::name("Root");
                default_world->add_system(je::typeinfo("Translation::TranslationUpdatingSystem")->val);
            }

            // 选一个世界去渲染， TODO: 在项目里记录一下？
            let rendworld = proj.worlds[0].instance;
            rendworld->add_system(proj.graphic_system);
            rendworld->add_system(proj.editor_system);

            return ok(proj);
        }
        err(msg)?
            return err(msg);
        }
    }

    public func GetCurrentProject()=> Project
    {
        match(_current_project)
        {
            value(proj)?
                return proj;
            none?
            {
                je::logwarn("没有正在编辑中的项目，将创建默认的项目上下文，此项目上下文不可以用于保存");
                return CreateDefaultProject();
            }
        }
    }

    public func SaveProject(self: Project)=>result<dict<string, dynamic>, string>
    {
        match(self.path)
        {
        value(path)?
        {
            using Serialize;
            let worlds_dumped_data = 
                self.worlds
                    ->trans(\w: World = save_project_world(w););

            // 1. 检查所有世界是否已经有路径信息，如果没有则说明有新建的世界没有保存过，要求保存
            let worlds = []mut: vec<string>;
            for (let world_data : worlds_dumped_data)
            {
                if (world_data["path"] is typeof(nil))
                    return result::err(F"存在尚未保存的世界: {world_data["name"]}");

                worlds->add(world_data["path"] as string);
            }

            // OK，看上去该保存的都保存上了，调World的Save方法写入世界数据
            self.worlds
                ->trans(\w: World = w->Save(););

            let (win_width, win_height) = je::input::windowsize();

            let window_info = {
                ["size"] = [win_width, win_height]
            };

            let project_dat = {
                // 这四个字段必须存在，其他的都是可选的，之后再说
                ["name"] = self.name: dynamic,
                ["path"] = path: dynamic,
                ["worlds"] = worlds: dynamic,

                // 可选的项目信息
                ["window"] = window_info: dynamic,
                ["graphic_system"] = self.graphic_system->name: dynamic,
                ["editor_system"] = self.editor_system->name: dynamic,
            };

            if (!je::file::writeall(F"{path}/{self.name}.jeproj4", project_dat: string))
                return result::err(F"项目工程文件'{path}/{self.name}.jeproj4'写入失败");

            return result::ok(project_dat);
        }
        none?
            // 没有保存路径，直接抛点东西让外边处理
            return result::err("当前项目是编辑器创建的默认项目，无法保存");
        }
    }
}
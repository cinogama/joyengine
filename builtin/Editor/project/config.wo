import woo.std;
import je;

import serialize;

namespace editor
{
    public using Project = struct {
        name : string,          // 项目名称
        path : option<string>,  // 项目文件的路径，默认项目没有这个值
        graphic_system : je::typeinfo,    // 默认使用的图形系统类型
        editor_system  : je::typeinfo,    // 默认使用的编辑器系统类型
        worlds : array<Project::World>,
    };
}

namespace editor::Project
{
    // 用于储存项目中的世界信息，包括世界所在的路径和运行时系统信息
    public using World = struct {
        path : option<string>, // 已经保存的世界会有路径，在关闭世界时，如果一个世界没有路径，那么这个世界会从项目里移除
        instance : je::world,  // 世界实例
        runtime_systems : array<je::typeinfo>, // 运行时系统列表，世界载入作为游戏运行时就会把里面的系统实例化出来
    };

    // 在当前项目中创建一个世界，世界会被保存进项目的世界列表中
    public func CreateWorld(self: Project)
    {
        let world_instance = je::universe::current()->create_world();

        // 创建调试摄像机组
        // 父对象，负责带着摄像机运动，同时负责y轴旋转
        let camera_walker = world_instance->add_entity([
            // Transform 族组件
            je::typeinfo("Transform::LocalPosition")->val,
            je::typeinfo("Transform::LocalRotation")->val,
            je::typeinfo("Transform::LocalToWorld")->val,
            je::typeinfo("Transform::Translation")->val,
            je::typeinfo("Transform::ChildAnchor")->val,
            // Editor 族组件
            je::typeinfo("Editor::Invisable")->val,
            je::typeinfo("Editor::EditorWalker")->val,
        ]);
        // 摄像机，同时负责x轴旋转
        let editor_camera = world_instance->add_entity([
            // Transform 族组件
            je::typeinfo("Transform::LocalRotation")->val,
            je::typeinfo("Transform::LocalToParent")->val,
            je::typeinfo("Transform::Translation")->val,
            // Editor 族组件
            je::typeinfo("Editor::Invisable")->val,
            je::typeinfo("Editor::EditorWalker")->val,
            // Camera 族组件
            je::typeinfo("Camera::PerspectiveProjection")->val,
            je::typeinfo("Camera::Projection")->val,
        ]);
        editor_camera->editor::set_parent(camera_walker);
        camera_walker->editor::name("调试摄像机组");
        editor_camera->editor::name("调试摄像机");

        // 移动器，这里只创建根实体，具体的轴由编辑器系统生成
        let entity_mover = world_instance->add_entity([
            // Transform 族组件
            je::typeinfo("Transform::LocalPosition")->val,
            je::typeinfo("Transform::LocalRotation")->val,
            je::typeinfo("Transform::LocalScale")->val,
            je::typeinfo("Transform::ChildAnchor")->val,
            je::typeinfo("Transform::Translation")->val,
            je::typeinfo("Transform::LocalToWorld")->val,
            // Editor 族组件
            je::typeinfo("Editor::Invisable")->val,
            je::typeinfo("Editor::EntityMoverRoot")->val,
        ]);

        let world = World{
            name = option::none,
            path = option::none,
            instance = world_instance,
            runtime_system = [],
        };

        self.worlds->add(world);
        return world;
    }

    public func FindWorld(self: Project, world: je::world)=> option<World>
    {
        for (let project_world : self.worlds)
            if (project_world.instance == world)
                return option::value(project_world);

        je::logwarn("发现一个未被列入项目中的游离世界：", world->editor::name());
        return option::none;
    }

    private let mut _current_project = option::none : option<Project>;

    public func SetCurrentProject(self: Project)
    {
        // 不可以重复设置当前项目，设置前应当清除旧的项目
        assert(false == _current_project->has);

        _current_project = option::value(self);
        return self;
    }

    func RemoveCurrentProject()
    {
        assert(_current_project->has);

        let proj = _current_project->val;
        je::loginfo(F"关闭当前项目: {proj.name}");
        for (let w : proj.worlds)
        {
            je::loginfo(F"关闭项目中所属的世界：{w.instance->editor::name}");
            w.instance->close;
        }

        _current_project = option::none;
    }

    private func CreateDefaultProject()
    {
        return SetCurrentProject(Project{
            name = "Default project",
            path = option::none, // 默认项目不带有path信息，这种项目是不可以被用于保存的
            // NOTE: 默认系统应该内置在引擎里，如果获取不到这里直接爆炸
            graphic_system = je::typeinfo("Graphic::DefaultGraphicPipelineSystem")->val,
            editor_system = je::typeinfo("Editor::DefaultEditorSystem")->val,
            worlds = [],
        });
    }

    public func CreateProject(name: string, path: string, create_file: bool)=> result<Project, string>
    {
        let proj_path = F"{path}/{name}";
        let created_project = Project{
            name = name,
            path = option::value(proj_path),
            graphic_system = je::typeinfo("Graphic::DefaultGraphicPipelineSystem")->val,
            editor_system = je::typeinfo("Editor::DefaultEditorSystem")->val,
            worlds = [],
        };

        assert(je::filesys::isdir(path));

        if (create_file)
        {
            // 1. 创建项目目录，把所需的文件拷贝进去
            if (!je::filesys::mkdir(proj_path))
                return result::err("创建项目目录失败");

            // 2. 写入项目数据文件
            match (created_project->SaveProject)
            {
            ok(projdat)?
                if (!je::file::writeall(F"{proj_path}/{name}.jeproj4", projdat: string))
                    return result::err("项目工程文件创建失败");
            err(msg)?
                return result::err(msg);
            }
        }
        // ok 创建完成，销毁之前的项目上下文
        RemoveCurrentProject();
        return result::ok(SetCurrentProject(created_project));
    }

    public func LoadProject(data: map<dynamic, dynamic>)=> result<Project, string>
    {
        // 从项目信息加载并创建项目
        let proj_name = (data["name": dynamic] as string)->trim;
        let proj_path = data["path": dynamic] as string;

        match (CreateProject(proj_name, proj_path, false))
        {
        ok(proj)?
        {
            let runtime_worlds = data["worlds": dynamic] as array<dynamic>;

            let window_info = data->get("window": dynamic, {}: dynamic) as map<dynamic, dynamic>;
            let window_size = window_info->get("size": dynamic, [640, 480]: dynamic) as array<dynamic>;

            je::input::windowsize(window_size[0]: int, window_size[1]: int);

            if (runtime_worlds->empty)
            {
                // 没有正在编辑的世界，给他创建一个
                let default_world = proj->CreateWorld().instance;
                default_world->editor::name("Root");
                default_world->add_system(proj.graphic_system);
                default_world->add_system(proj.editor_system);
                default_world->add_system(je::typeinfo("Translation::TranslationUpdatingSystem")->val);
            }
            else
            {
                // TODO; 加载每一个编辑中世界
                std::panic("TODO;");
            }
            return ok(proj);
        }
        err(msg)?
            return err(msg);
        }
    }

    public func GetCurrentProject()=> Project
    {
        match(_current_project)
        {
            value(proj)?
                return proj;
            none?
            {
                je::logwarn("没有正在编辑中的项目，将创建默认的项目上下文，此项目上下文不可以用于保存");
                return CreateDefaultProject();
            }
        }
    }

    public func SaveProject(self: Project)=>result<map<string, dynamic>, string>
    {
        match(self.path)
        {
        value(path)?
        {
            using Serialize;
            let worlds_dumped_data = 
                self.worlds
                    ->trans(\w: World = save_project_world(w);)
                    ->forall(\data: option<map<string, dynamic>> = data->has;)
                    ->trans(\data: option<map<string, dynamic>> = data->val;);

            // 1. 检查所有世界是否已经有路径信息，如果没有则说明有新建的世界没有保存过，要求保存
            let worlds = []: array<string>;
            for (let world_data : worlds_dumped_data)
            {
                if (world_data["path"] is typeof(nil))
                {
                    // TODO:
                    return result::err(F"存在尚未保存的世界: {world_data["name"]}");
                }
                worlds->add(world_data["path"] as string);
            }

            let (win_width, win_height) = je::input::windowsize();

            let window_info = {
                {"size", [win_width, win_height]}
            };

            let project_dat = {
                // 这四个字段必须存在，其他的都是可选的，之后再说
                {"name", self.name: dynamic},
                {"path", path: dynamic},
                {"window", window_info: dynamic},
                {"worlds", worlds: dynamic},
                // {"graphic_system", TODO},
                // {"editor_system", TODO},
            };
            return result::ok(project_dat);
        }
        none?
            // 没有保存路径，直接抛点东西让外边处理
            return result::err("当前项目是编辑器创建的默认项目，无法保存");
        }
    }
}
// 序列化，提供对实体/世界的序列化
// 实体不保存所有Editor组件，有额外的字段保存实体的Editor::Name
// 世界不保存Invisable的实体，不保存Editor系统和Graphic系统，此系统由编辑器负责重新创建和附加

import woo.std;
import je;
import config;

using je;

namespace editor::Serialize
{
	public func save_entity(saving_entity: entity)
	{	
		return
            saving_entity
                ->editor::get_components_types()
                ->forall(\t: typeinfo = !t->name->beginwith("Editor::");)
                ->collect(\t: typeinfo = component->has ? [(t, component->val)] | []
                    where
                        component = saving_entity->editor::get_component(t);)
                ->trans(\tc: (typeinfo, component) = (t->name, collect_members())
                    where 
                        collect_members = func(){
                            let result = {}: map<string, string>; 
                            for (let name, type, addr : c->editor::iter_member(t))
                                result[name] = addr->to_string(type);
                            return result;
                        },
                        (t, c) = tc;)
                ->mapping
                ->\m : map<string, map<string, string>> = m->empty? option::none | option::value(m);
                ->map(\m: map<string, map<string, string>> = 
                    {
                        ["name"] = saving_entity->editor::name: dynamic, 
                        ["components"] = m: dynamic
                    };);
	}

    public func save_project_world(world: Project::World)
    {
        static let INVISABLE = je::typeinfo("Editor::Invisable")->val;

        alias entity_info_t = map<string, dynamic>;

        let w = world.instance;

        let entities_json_list = 
            w->editor::get_all_entities
                // 跳过编辑器上的不可见实体
                ->forall(\e: entity = !e->editor::get_component(INVISABLE)->has;)
                ->trans(\e: entity = save_entity(e);)
                ->collect(\oe: option<entity_info_t> = oe->has ? [oe->val] | [];);

        let editing_systems_type_list = 
            w->editor::get_systems_types
                ->trans(\st: typeinfo = st->name;)
                ->forall(\n: string = !n->beginwith("Graphic::") && !n->beginwith("Editor::"););

        let runtime_systems_type_list = 
            world.runtime_systems
                ->trans(\st: typeinfo = st->name;)
                ->forall(\n: string = !n->beginwith("Graphic::") && !n->beginwith("Editor::"););
 
        return option::value({
            ["name"] = w->editor::name: dynamic,
            // 不是所有world都有path值，如果没有说明这个world不是从文件中载入的，塞一个nil进去意思一下
            ["path"] = world.path->has ? world.path->val: dynamic | nil: dynamic,
            ["entities"] = entities_json_list: dynamic,
            ["edit_systems"] = editing_systems_type_list: dynamic,
            ["runtime_systems"] = runtime_systems_type_list: dynamic,
        });
    }
}
import woo.std;
import je.gui;
import je.filesys;

namespace editor
{
    namespace Browser
    {
        union FileType
        {
            path(je::graphic::texture),
            image(je::graphic::texture),
            shader(je::graphic::texture),
            others(je::graphic::texture),
        }
        namespace FileType
        {
            func get_texture(var self: FileType)
            {
                match (self)
                {
                    path(t)?
                        return t;
                    image(t)?
                        return t;
                    shader(t)?
                        return t;
                    others(t)?
                        return t;
                }
            }
        }

        var FILE_TYPE_ICONS = {} : map<string, FileType>;

        func _load_default_icons()
        {
            FILE_TYPE_ICONS["png"] = 
            FILE_TYPE_ICONS["jpg"] = 
            FILE_TYPE_ICONS["bmp"] = 
            FILE_TYPE_ICONS["psd"] = 
                FileType::image(je::graphic::texture(F"{std::exepath()}builtin/Editor/icon/TextureFile.png")->val());

            FILE_TYPE_ICONS["shader"] = 
                FileType::image(je::graphic::texture(F"{std::exepath()}builtin/Editor/icon/ShaderFile.png")->val());
        }
        _load_default_icons();

        private func get_file_icon_by_extern_name(var _path: PathInfo) : FileType
        {
            static var default_path_icon 
                = FileType::path(
                    je::graphic::texture(F"{std::exepath()}builtin/Editor/icon/FilePath.png")->val());
            static var default_file_icon 
                = FileType::others(
                    je::graphic::texture(F"{std::exepath()}builtin/Editor/icon/File.png")->val());

            match (_path.type)
            {
                dir(_)?
                    return default_path_icon;
                file?
                    return FILE_TYPE_ICONS->get_or_default(_path.externname, default_file_icon);
            }
        }

        union SubPath
        {
            subpath(array<PathInfo>),
            notfetch,
        }
        union PathType
        {
            dir(SubPath),
            file,
        }
        using PathInfo = struct {
            path        : string,            // 当前目录/文件的目录
            name        : string,
            externname    : string,
            type        : PathType,            // 类型，如果是目录，则还包含目录内的子项    
        };

        static var current_work_path = "";        

        func FileIcon(var path: PathInfo)
        {
            using je::gui;
            
            BeginGroup();
                PushID(path.path);
                    var clicked = ImageButtom(get_file_icon_by_extern_name(path)->get_texture(), 0.125);
                PopID();
                if (BeginDragDropSource())
                {
                    SetDragDropPayload("JEDITOR_FILE_PATH", path.path);
                        Text(F"File: {path.path}");
                    EndDragDropSource();
                }

                SameLine();
                Text(path.name);
            EndGroup();

            return clicked;
        }

        func files_group()
        {
            using je::gui;

            static var new_showing_path = "";
            static var now_item_in_path = []: array<PathInfo>;
            if (new_showing_path != current_work_path)
            {
                new_showing_path = current_work_path;
                now_item_in_path->clear();
                for (var subpath : je::filesys::path(current_work_path))
                    now_item_in_path->add(
                        PathInfo{ 
                            path = subpath,
                            name = je::filesys::filename(subpath),
                            externname = je::filesys::externname(subpath),
                            type =  func(){
                                if (je::filesys::isdir(subpath))
                                    return PathType::dir(SubPath::notfetch);
                                return PathType::file;
                            }() });
            }

            BeginChild("files_list");
                for (var subpath : now_item_in_path)
                    FileIcon(subpath);
            EndChild();
        }

        func path_tree()
        {
            using je::gui;
    
            if (current_work_path == "")
                current_work_path = std::exepath();

            static var _root = PathInfo {
                    path = std::exepath(),
                    name = je::filesys::filename(std::exepath()),
                    externname = je::filesys::externname(std::exepath()),
                    type = PathType::dir(SubPath::notfetch),
                };

            func _show_paths(var path: PathInfo, var noself :bool)
            {
                match (path.type)
                {
                    PathType::dir(subpath)?
                    {
                        var attribute = TreeNodeAttribute::ImGuiTreeNodeFlags_OpenOnArrow 
                                      + TreeNodeAttribute::ImGuiTreeNodeFlags_OpenOnDoubleClick 
                                      + TreeNodeAttribute::ImGuiTreeNodeFlags_SpanAvailWidth;
                        if (current_work_path == path.path)
                            attribute += TreeNodeAttribute::ImGuiTreeNodeFlags_Selected;
                        
                        var show_child = TreeNodeEx(path.name, attribute);
                        if (IsItemClicked() && !IsItemToggledOpen())
                            current_work_path = path.path;

                        if (show_child)
                        {
                            match (subpath)
                            {
                                SubPath::subpath(itemlist)?
                                {
                                    for (var subpath : itemlist)
                                        _show_paths(subpath, false);
                                }    
                                SubPath::notfetch?
                                {
                                    // 当前目录的子项目尚未获取，在这里获取一下塞进去
                                    var sublist = []: array<PathInfo>;
                                    for (var current_subpath : je::filesys::path(path.path))
                                        sublist->add(
                                            PathInfo{
                                                path = current_subpath, 
                                                name = je::filesys::filename(current_subpath),
                                                externname = je::filesys::externname(current_subpath),
                                                type = func(){
                                                    if (je::filesys::isdir(current_subpath))
                                                        return PathType::dir(SubPath::notfetch);
                                                    return PathType::file;
                                                }() 
                                            });
                                    path.type =  PathType::dir(SubPath::subpath(sublist));
                                }
                            }
                            TreePop();
                        }
                        else
                            path.type = PathType::dir(SubPath::notfetch);
                    }
                    PathType::file?
                        ; // path_tree只显示目录，跳过文件
                }
                

            }

            BeginChild("path_tree", 200., 0.);
                _show_paths(_root, true);
            EndChild();
        }

        func show(ref open: bool)
        {
            using je::gui;

            if (!open) return !open;

            Begin("资源管理器", WindowsAttribute::ImGuiWindowFlags_None, ref open);
                path_tree();
                SameLine();
                files_group();
            End();

            return !open;
        }
    }
}
import woo.std;
import je.gui;
import je.filesys;

import openfile;
import cxxproject;

using je::gui;

namespace editor::Browser
{
    union FileType
    {
        path(je::graphic::texture),
        image(je::graphic::texture),
        shader(je::graphic::texture),
        others(je::graphic::texture),
    }
    namespace FileType
    {
        func get_texture(self: FileType)
        {
            match (self)
            {
                path(t)? return t;
                image(t)? return t;
                shader(t)? return t;
                others(t)? return t;
            }
        }
    }
    
    // 用于储存文件拓展名和图标的对应关系
    let FILE_TYPE_ICONS = {
        ["png"] = FileType::image(je::graphic::texture(F"{std::exepath()}builtin/Editor/icon/TextureFile.png")),
        ["jpg"] = FileType::image(je::graphic::texture(F"{std::exepath()}builtin/Editor/icon/TextureFile.png")),
        ["bmp"] = FileType::image(je::graphic::texture(F"{std::exepath()}builtin/Editor/icon/TextureFile.png")),
        ["psd"] = FileType::image(je::graphic::texture(F"{std::exepath()}builtin/Editor/icon/TextureFile.png")),
        ["shader"] = FileType::shader(je::graphic::texture(F"{std::exepath()}builtin/Editor/icon/ShaderFile.png")),
        ["jemodule4"] = FileType::shader(je::graphic::texture(F"{std::exepath()}builtin/Editor/icon/CppProgram.png")),
    };

    // 根据文件拓展名返回文件的类型
    private func get_file_icon_by_extern_name(_path: PathInfo)=> FileType
    {
        static let default_path_icon 
            = FileType::path(je::graphic::texture(F"{std::exepath()}builtin/Editor/icon/FilePath.png"));
        static let default_file_icon 
            = FileType::others(je::graphic::texture(F"{std::exepath()}builtin/Editor/icon/File.png"));

        let icon = FILE_TYPE_ICONS->get(_path.externname);

        match (icon)
        {
        none?
        {
            match (_path.type->get)
            {
            dir(_)?
                return default_path_icon;
            file?
                return default_file_icon;
            }
        }
        value(i)? return i;
        }
    }

    union PathType
    {
        dir(option<array<PathInfo>>),
        file,
    }

    public using PathInfo = struct {
        path        : string,   // 当前目录/文件的目录
        name        : string,
        externname  : string,
        type        : mutable<PathType>, // 类型，如果是目录，则还包含目录内的子项    
    }
    {
        func indir(self : PathInfo, functor: (option<array<PathInfo>>)=>void)
        {
            match (self.type->get)
            {
            dir(subdirs)? functor(subdirs);
            file?;
            }
            return self;
        }
        func infile(self : PathInfo, functor: ()=>void)
        {
            match (self.type->get)
            {
            dir(subdirs)?;
            file? functor();
            }
            return self;
        }
        func childs(self : PathInfo, force_update: bool)
        {
            // 如果没有要求强制更新，有现成的就用现成的
            match (self.type->get)
            {
            dir(_dir)?
                match(_dir)
                {
                value(subdirs)?
                    if (!force_update)
                        return subdirs;
                none?;
                }
            file? // 文件也来获取子目录，搁这儿找茬呢？
                std::panic("Failed to get subpath: is a file.");
            }

            // 当前目录的子项目尚未获取，在这里获取一下塞进去
            let sublist = 
                je::filesys::childs(self.path)
                    ->unwarp
                    ->trans(\current_subpath: string = PathInfo{
                        path = current_subpath, 
                        name = je::filesys::filename(current_subpath),
                        externname = je::filesys::externname(current_subpath),
                        type = mutable(je::filesys::isdir(current_subpath)?
                                PathType::dir(option::none) | PathType::file),
                    };);

            self.type->set(PathType::dir(option::value(sublist)));
            return sublist;
        }
    }

    static let mut current_work_path = "";        

    func set_current_work_path(path: string)
    {
        assert(je::filesys::isdir(path));
        current_work_path = path;
    }

    enum Action
    {
        Nothing,
        Click,
        DoubleClick,
        RightClick,
    }

    func context_menu(path: option<PathInfo>)
    {
        let mut shown_context = false;

        if (path
            ->map(\_: anything = BeginPopupContextItem();)
            ->or(\ = BeginPopupContextWindow();)
            ->val)
        {
            if (BeginMenu(F"新建..."))
            {
                if (MenuItem(F"目录"))
                    generic::inputbox("新建目录", F"在{current_work_path}新建目录", "NewDir",
                        \dirname: string = je::filesys::mkdir(je::filesys::normalize(current_work_path) + dirname)
                            ->map(\_:anything = force_update();)
                            ->or(\reason: string = generic::msgbox("创建目录失败", reason);););
                if (MenuItem(F"空文件"))
                {
                    generic::inputbox("新建空文件", F"在{current_work_path}新建空文件", "NewFile.txt",
                        \filename: string = je::filesys::exist(file_path)
                            ? generic::msgbox("创建空文件失败", "同名文件已经存在")
                            | je::file::writeall(file_path, "") 
                                ? force_update()
                                | generic::msgbox("创建空文件失败", "无法创建文件，可能是文件名非法或磁盘已满")
                        where file_path = je::filesys::normalize(current_work_path) + filename;);
                }
                Separator();
                if (BeginMenu("着色器脚本"))
                {
                    let create_shader_at = func(shader_name: string, shader_src: string)
                    {
                        let shader_path = je::filesys::normalize(F"{current_work_path}/{shader_name}.shader");
                        if (!je::file::writeall(shader_path, shader_src))
                            generic::msgbox("创建着色器失败", F"无法写入{shader_path}");
                        else
                            force_update();
                    };

                    if (MenuItem(F"空白着色器"))
                        generic::inputbox("创建着色器", F"将在{current_work_path}创建空白着色器：", "MonoColor",
                            \shader_name: string = create_shader_at(shader_name, shader_src) 
                                where shader_src = 
@"import je.shader;

ZTEST   (LESS);
ZWRITE  (ENABLE);
BLEND   (ONE, ZERO);
CULL    (NONE);

VAO_STRUCT vin {
    vertex  : float3,
};

using v2f = struct {
    pos     : float4,
};

using fout = struct {
    color: float4
};

public func vert(v: vin)
{
    return v2f {
        pos = je_mvp * float4(v.vertex, 1.)
    };
}

public func frag(vf: v2f)
{
    return fout {
        color = float4(1., 1., 1., 1.)
    };
}
"@                          ;);
                    if (MenuItem(F"无光着色器"))
                        generic::inputbox("创建着色器", F"将在{current_work_path}创建无光着色器：", "Unlit",
                            \shader_name: string = create_shader_at(shader_name, shader_src) 
                                where shader_src = 
@"import je.shader;

ZTEST   (LESS);
ZWRITE  (ENABLE);
BLEND   (ONE, ZERO);
CULL    (NONE);

VAO_STRUCT vin {
    vertex  : float3,
    uv      : float2,
};

using v2f = struct {
    pos     : float4,
    uv      : float2,
};

using fout = struct {
    color: float4
};

public func vert(v: vin)
{
    return v2f {
        pos = je_mvp * float4(v.vertex, 1.),
        uv  = v.uv,
    };
}

public func frag(vf: v2f)
{
    let tex = uniform:<texture2d>("MainTexture")->channel(0);

    return fout {
        color = texture(tex, vf.uv),
    };
}
"@                          ;);
                    EndMenu();
                }
                if (MenuItem(F"C++模块"))
                {
                    // 创建C++模块，就跟JoyEngineCSP差不多
                    generic::inputbox("创建C++模块", F"将在{current_work_path}创建，请为项目命名：", "CppModule", 
                        \module_name: string = CxxProject::start(module_name, current_work_path)
                            ->map(\_: anything = force_update();)
                            ->or(\reason: string = generic::msgbox("创建C++模块失败", reason););)
                }
                EndMenu();
            }

            Separator();

            path->map(\p: PathInfo = file_item_menu(p);)
            ->map(\_: anything = Separator(););
                        
            if (MenuItem("在资源管理器中显示"))
                je::filesys::open(F"explorer \"{je::filesys::normalize(current_work_path)->replace("/", "\\")}\"");

            if (MenuItem(F"刷新"))
                force_update();

            EndPopup();
        }
    }
    func file_item_menu(path: PathInfo)
    {
        let NOT_MODIFIABLE_FILES = ["jeproj4", "jemodule4"];
        let is_modifiable_file = NOT_MODIFIABLE_FILES->find(path.externname) == -1;

        if (path.externname == "shader")
        {
            if (MenuItem(F"更新此着色器"))
            {
                // 从universe中获取所有world，更新world中所有实体的shader
                je::universe::current()
                    ->editor::worlds_list
                    ->trans(\w: je::world = w
                        ->editor::get_all_entities
                        ->trans(\e: je::entity = 
                            e->editor::graphic::try_reload_shaders(path.path, path.path)
                        ;)
                    ;);
            }
            Separator();
        }
        if (path.externname == "jemodule4")
        {
            if (MenuItem(F"重新编译此模块"))
            {
                match(Project::GetCurrentProject().native_modules
                    ->get(je::filesys::normalize(path.path)))
                {
                value(mod)?
                    mod->update_compile(je::editor::platform());
                none?
                    generic::askbox("是否加载此模块？", 
                        F"正在要求重新编译模块{path.path}，但此模块尚未被加载\n是否现在加载并重新编译？",
                        func ()
                        {
                            match (CxxProject::load(path.path))
                            {
                            ok(mod)?
                                mod->update_compile(je::editor::platform());
                            err(reason)?
                                generic::msgbox("加载模块失败", reason);
                            }
                        });
                }
                    
            }
            if (MenuItem(F"组件/系统..."))
            {
                let components = je::filesys::childs(F"{path.path}components")
                        ->okay
                        ->map(\s: array<string> = s
                             ->forall(\f: string = je::filesys::externname(f) == "hpp";)
                             ->trans(\f: string = fname->sub(0, fname->len - 4)
                                where fname = je::filesys::filename(f);)
                            ;)
                        ->valor([])
                        ->tovec;
                let systems = je::filesys::childs(F"{path.path}systems")
                    ->okay
                    ->map(\s: array<string> = s
                         ->forall(\f: string = je::filesys::externname(f) == "hpp";)
                         ->trans(\f: string = fname->sub(0, fname->len - 4)
                            where fname = je::filesys::filename(f);)
                        ;)
                    ->valor([])
                    ->tovec;

                let display_usable_component = func(s: string)
                {
                    Selectable(s);
                    if (BeginPopupContextItem())
                    {
                        let file_path = F"{path.path}components/{s}.hpp";

                        if (MenuItem("在VSCode中打开"))
                            je::filesys::open(F"code {utils::WrapPath(path.path)} {utils::WrapPath(file_path)}");
                        if (MenuItem("移除此组件"))
                            generic::askbox("确认移除组件？", F"是否从模块{je::filesys::filename(path.path)}中移除组件{s}?",
                                func(){
                                    components->remove(components->find(s));
                                    je::filesys::delete(file_path);
                                });
                        EndPopup();
                    }
                };

                let display_usable_system = func(s: string)
                {
                    Selectable(s);
                    if (BeginPopupContextItem())
                    {
                        let file_path = F"{path.path}systems/{s}.cpp";

                        if (MenuItem("在VSCode中打开"))
                            je::filesys::open(F"code {utils::WrapPath(path.path)} {utils::WrapPath(file_path)}");
                        if (MenuItem("移除此系统"))
                            generic::askbox("确认移除系统？", F"是否从模块{je::filesys::filename(path.path)}中移除系统{s}?",
                                func(){
                                    systems->remove(systems->find(s));
                                    je::filesys::delete(F"{path.path}systems/{s}.hpp");
                                    je::filesys::delete(file_path);
                                });
                        EndPopup();
                    }
                };

                launch(func(mut open: bool)
                {
                    Begin(F"模块{je::filesys::filename(path.path)}当前组件和系统", 
                        WindowsAttribute::ImGuiWindowFlags_MenuBar
                        + WindowsAttribute::ImGuiWindowFlags_AlwaysAutoResize, ref open);
                    if (BeginMenuBar())
                    {
                        if (BeginMenu("创建..."))
                        {
                            if (MenuItem("新系统"))
                                generic::inputbox("创建新系统", F"为模块{je::filesys::filename(path.path)}创建系统", "NewSystem",
                                    func(name: string)
                                    {
                                        if (systems->find(name) != -1)
                                        {
                                            generic::msgbox("创建系统失败", F"模块{je::filesys::filename(path.path)}已经存在一个同名系统");
                                            return;
                                        }

                                        let system_header = 
@"#include "jeecs.hpp"

namespace $$MODULE_NAME$$
{
    struct $$SYSTEM_NAME$$ : public jeecs::game_system
    {
        $$SYSTEM_NAME$$(jeecs::game_world world);
        void PreUpdate();
        void Update();
        void LateUpdate();
    };
}
"@;
                                    let system_src = 
@"#include "$$SYSTEM_NAME$$.hpp"

using namespace std;
using namespace jeecs;

namespace $$MODULE_NAME$$
{
    $$SYSTEM_NAME$$::$$SYSTEM_NAME$$(game_world world)
        : game_system(world)
    {
        
    }

    void $$SYSTEM_NAME$$::PreUpdate()
    {

    }

    void $$SYSTEM_NAME$$::Update()
    {

    }

    void $$SYSTEM_NAME$$::LateUpdate()
    {

    }
}
"@;
                                        let module_name = je::filesys::purename(path.path);
                                        let system_name = name;

                                        if (!je::file::writeall(F"{path.path}systems/{system_name}.hpp", 
                                            system_header
                                                ->replace("$$MODULE_NAME$$", module_name)
                                                ->replace("$$SYSTEM_NAME$$", system_name))
                                            ||
                                            !je::file::writeall(F"{path.path}systems/{system_name}.cpp", 
                                            system_src
                                                ->replace("$$MODULE_NAME$$", module_name)
                                                ->replace("$$SYSTEM_NAME$$", system_name))
                                            )
                                        {
                                            je::filesys::delete(F"{path.path}systems/{system_name}.hpp");
                                            je::filesys::delete(F"{path.path}systems/{system_name}.cpp");

                                            generic::msgbox("创建系统失败", "无法创建和写入系统源文件");
                                        }
                                        else
                                        {
                                            generic::msgbox("创建系统成功", "系统已创建到\n" 
                                                + F"{path.path}systems/{system_name}.hpp\n"
                                                + F"{path.path}systems/{system_name}.cpp");
                                            systems->add(system_name);
                                        }
                                    });
                            //End of create new system
                            if (MenuItem("新组件"))
                                generic::inputbox("创建新组件", F"为模块{je::filesys::filename(path.path)}创建组件", "NewComponent",
                                    func(name: string)
                                    {
                                        if (components->find(name) != -1)
                                        {
                                            generic::msgbox("创建组件失败", F"模块{je::filesys::filename(path.path)}已经存在一个同名组件");
                                            return;
                                        }

                                        let component_header = 
@"#include "jeecs.hpp"

namespace $$MODULE_NAME$$
{
    struct $$COMPONENT_NAME$$
    {
        static void JERefRegsiter()
        {
            using namespace jeecs;

            // Register member in this function.
            // e.g. typing::register_member(&$$COMPONENT_NAME$$::member, "member");
        }
    };
}
"@;
                                        let module_name = je::filesys::purename(path.path);
                                        let component_name = name;

                                        if (!je::file::writeall(F"{path.path}components/{component_name}.hpp", 
                                            component_header
                                                ->replace("$$MODULE_NAME$$", module_name)
                                                ->replace("$$COMPONENT_NAME$$", component_name))
                                            )
                                        {
                                            je::filesys::delete(F"{path.path}components/{component_name}.hpp");
                                            generic::msgbox("创建组件失败", "无法创建和写入组件源文件");
                                        }
                                        else
                                        {
                                            generic::msgbox("创建组件成功", "组件已创建到\n" 
                                                + F"{path.path}components/{component_name}.hpp");
                                            components->add(component_name);
                                        }
                                    });
                            // End of create new component
                            EndMenu();
                        }
                        EndMenuBar();
                    }
                    if (BeginListBox("##1", 350.0, 400.0))
                    {
                        systems->trans(\s: string = display_usable_system(s););
                        EndListBox();
                    }
                    SameLine();
                    if (BeginListBox("##2", 350.0, 400.0))
                    {
                        components->trans(\s: string = display_usable_component(s););
                        EndListBox();
                    }
                    End();

                    if (open)
                        return FormAction::Nothing;
                    return FormAction::Close;
                }, (true,));
            }
            Separator();
        }
        if (MenuItem("重命名", is_modifiable_file))
        {
            generic::inputbox("重命名", F"请输入{path.path}的新名称", F"{path.name}", 
                \newname: string = je::filesys::move(path.path, je::filesys::parent(path.path) + newname)
                    ->map(\_: anything = force_update();)
                    ->or(\reason: string = generic::msgbox("重命名失败", reason);););
        }
        if (MenuItem("删除", is_modifiable_file))
        {
            generic::askbox(F"删除{path.path}", F"是否继续删除{path.path}",
                \=je::filesys::delete(path.path)
                    ->map(\_: anything = force_update();)
                    ->or(\reason: string = generic::msgbox("删除失败", reason);););
        }
    }

    // 带图标的文件按钮
    func FileIcon(path: PathInfo)=> Action
    {
        BeginGroup();
            PushID(path.path);
                let clicked = ImageButton(get_file_icon_by_extern_name(path)->get_texture, 0.125);
            PopID();
            let right_click = IsItemClicked(ImGuiMouseButton::ImGuiMouseButton_Right);
            context_menu(option::value(path));
            if (BeginDragDropSource())
            {
                SetDragDropPayload("JEDITOR_FILE_PATH", path.path);
                    Text(F"File: {path.path}");
                EndDragDropSource();
            }

            SameLine();
            Text(path.name);
        EndGroup();

        static let mut _last_click_time = std::time();

        if(clicked)
        {
            let _current_click_time = std::time();
            if (_current_click_time - _last_click_time < 0.2)
                return Action::DoubleClick;

            _last_click_time = _current_click_time;
            return Action::Click;
        }
        else if (right_click)
            return Action::RightClick;
        
        return Action::Nothing;
    }

    static let mut force_update_file_group_flag = false;
    static let mut force_update_dir_tree_flag = false;
    // 刷新显示的目录信息等...
    public func force_update()
    {
        force_update_dir_tree_flag = true;
        force_update_file_group_flag = true;
    }

    // 右边的文件详情等信息
    func files_group()
    {
        static let mut new_showing_path = "";
        static let mut now_item_in_path = []: array<PathInfo>;
        if (new_showing_path != current_work_path || force_update_file_group_flag)
        {
            new_showing_path = current_work_path;
            force_update_file_group_flag = false;

            now_item_in_path =
                je::filesys::childs(current_work_path)
                    ->unwarp
                    ->trans(\subpath: string = PathInfo{ 
                        path = subpath,
                        name = je::filesys::filename(subpath),
                        externname = je::filesys::externname(subpath),
                        type = mutable(je::filesys::isdir(subpath)
                            ? PathType::dir(option::none) 
                            | PathType::file),
                    };);
        }

        BeginChild("files_list");
            context_menu(option::none);
            now_item_in_path
                ->trans(\subpath: PathInfo = 
                    action == Action::Click ? 0
                    | action == Action::DoubleClick ? 
                        subpath
                            ->indir(\_:void = set_current_work_path(subpath.path);)
                            ->infile(\= OpenFile::open(subpath);)   
                    /* | action == Action::RightClick ? je::logfatal("TODO; 打开右键菜单") */
                    | func(){}() // get void
                    where action = FileIcon(subpath);
                ); 
        EndChild();

        // 允许各种乱七八糟的东西拖到这里
        AcceptDrag(["JEEDITOR_WORLD"])
            ->map(\msg: (string, string) = 
                    type == "JEEDITOR_WORLD" 
                    ? Project::GetCurrentProject()
                        ->FindWorld(data: handle: je::world)
                        ->map(\w: Project::World = w->SaveTo(new_showing_path);)
                        ->or(\=launch(generic::MsgBox, ("保存世界失败", "没有在项目中找到此实例对应的信息"));)
                    | std::panic(F"Unhandler drag type: '{type}'.")
                    where (type, data) = msg;);
    }

    // 左侧的目录概况
    func path_tree()
    {
        let root_path = 
            Project::GetCurrentProject().path
                ->valor(std::exepath());

        if (current_work_path == "")
            current_work_path = root_path;

        static let _root = PathInfo {
                path = root_path,
                name = je::filesys::filename(root_path),
                externname = je::filesys::externname(root_path),
                type = mutable(PathType::dir(option::none)),
            };

        if (force_update_dir_tree_flag)
        {
            force_update_dir_tree_flag = false;

            // 强制更新，直接把缓存的子目录全部干掉
            _root.type->set(PathType::dir(option::none));
        }

        // 用于递归展示所有子目录等
        func _show_paths(path: PathInfo)
        {
            match (path.type->get)
            {
            PathType::dir(subpath)?
            {
                let mut attribute = TreeNodeAttribute::ImGuiTreeNodeFlags_OpenOnArrow 
                                + TreeNodeAttribute::ImGuiTreeNodeFlags_OpenOnDoubleClick 
                                + TreeNodeAttribute::ImGuiTreeNodeFlags_SpanAvailWidth;
                if (current_work_path == path.path)
                    attribute += TreeNodeAttribute::ImGuiTreeNodeFlags_Selected;
                        
                let show_child = TreeNodeEx(path.name, attribute);
                if (IsItemClicked() && !IsItemToggledOpen())
                    current_work_path = path.path;

                if (show_child)
                {
                    for (let subpath : path->childs(false))
                        _show_paths(subpath);

                    TreePop();
                }
                else
                    // 如果目录被折叠起来，则删除缓存，等待下次展开时重新获取
                    path.type->set(PathType::dir(option::none));
            }
            PathType::file?
                ; // path_tree只显示目录，跳过文件
            }
        }

        BeginChild("path_tree", 200., 0.);
            _show_paths(_root);
        EndChild();
    }

    public func show(ref open: bool)
    {
        if (!open) return FormAction::Close;

        Begin("资源管理器", WindowsAttribute::ImGuiWindowFlags_None, ref open);
            path_tree();
            SameLine();
            BeginGroup();
                BeginChild("tools_bar", 0., 40.);
                    // TODO 此处放一些返回上一层之类的按钮
                    if (Button("U"))
                        current_work_path = je::filesys::parent(current_work_path);
                    SameLine();
                    Text(current_work_path);
                EndChild();
                files_group();
                
            EndGroup();
        End();

        if (!open)
            return FormAction::Close;
        return FormAction::Nothing;
    }
}

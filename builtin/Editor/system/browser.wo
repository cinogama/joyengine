import woo.std;
import je.gui;
import je.filesys;

import openfile;

using je::gui;

namespace editor::Browser
{
    union FileType
    {
        path(je::graphic::texture),
        image(je::graphic::texture),
        shader(je::graphic::texture),
        others(je::graphic::texture),
    }
    namespace FileType
    {
        func get_texture(self: FileType)
        {
            match (self)
            {
                path(t)? return t;
                image(t)? return t;
                shader(t)? return t;
                others(t)? return t;
            }
        }
    }
    
    // 用于储存文件拓展名和图标的对应关系
    let FILE_TYPE_ICONS = {
        ["png"] = FileType::image(je::graphic::texture(F"{std::exepath()}builtin/Editor/icon/TextureFile.png")),
        ["jpg"] = FileType::image(je::graphic::texture(F"{std::exepath()}builtin/Editor/icon/TextureFile.png")),
        ["bmp"] = FileType::image(je::graphic::texture(F"{std::exepath()}builtin/Editor/icon/TextureFile.png")),
        ["psd"] = FileType::image(je::graphic::texture(F"{std::exepath()}builtin/Editor/icon/TextureFile.png")),
        ["shader"] = FileType::shader(je::graphic::texture(F"{std::exepath()}builtin/Editor/icon/ShaderFile.png")),
    };

    // 根据文件拓展名返回文件的类型
    private func get_file_icon_by_extern_name(_path: PathInfo)=> FileType
    {
        static let default_path_icon 
            = FileType::path(je::graphic::texture(F"{std::exepath()}builtin/Editor/icon/FilePath.png"));
        static let default_file_icon 
            = FileType::others(je::graphic::texture(F"{std::exepath()}builtin/Editor/icon/File.png"));

        match (_path.type->get)
        {
        dir(_)?
            return default_path_icon;
        file?
            return FILE_TYPE_ICONS->get(_path.externname, default_file_icon);
        }
    }

    union PathType
    {
        dir(option<array<PathInfo>>),
        file,
    }

    public using PathInfo = struct {
        path        : string,   // 当前目录/文件的目录
        name        : string,
        externname  : string,
        type        : mutable<PathType>, // 类型，如果是目录，则还包含目录内的子项    
    };

    namespace PathInfo
    {
        func indir(self : PathInfo, functor: (option<array<PathInfo>>)=>void)
        {
            match (self.type->get)
            {
            dir(subdirs)? functor(subdirs);
            file?;
            }
            return self;
        }
        func infile(self : PathInfo, functor: ()=>void)
        {
            match (self.type->get)
            {
            dir(subdirs)?;
            file? functor();
            }
            return self;
        }
        func childs(self : PathInfo, force_update: bool)
        {
            // 如果没有要求强制更新，有现成的就用现成的
            match (self.type->get)
            {
            dir(_dir)?
                match(_dir)
                {
                value(subdirs)?
                    if (!force_update)
                        return subdirs;
                none?;
                }
            file? // 文件也来获取子目录，搁这儿找茬呢？
                std::panic("Failed to get subpath: is a file.");
            }

            // 当前目录的子项目尚未获取，在这里获取一下塞进去
            let sublist = 
                je::filesys::childs(self.path)
                    ->unwarp
                    ->trans(\current_subpath: string = PathInfo{
                        path = current_subpath, 
                        name = je::filesys::filename(current_subpath),
                        externname = je::filesys::externname(current_subpath),
                        type = mutable(je::filesys::isdir(current_subpath)?
                                PathType::dir(option::none) | PathType::file),
                    };);

            self.type->set(PathType::dir(option::value(sublist)));
            return sublist;
        }
    }

    static let mut current_work_path = "";        

    func set_current_work_path(path: string)
    {
        assert(je::filesys::isdir(path));
        current_work_path = path;
    }

    enum Action
    {
        Nothing,
        Click,
        DoubleClick,
        RightClick,
    }

    union FileOrForm
    {
        File(PathInfo),
        Form(string),
    }

    func context_menu(path: FileOrForm)
    {
        let mut shown_context = false;
        match (path)
        {
        File(_)? shown_context = BeginPopupContextItem();
        Form(id)? shown_context = BeginPopupContextItem(id);
        }
        if (shown_context)
        {
            match (path)
            {
            File(p)?
            {
                file_item_menu(p);
                Separator();
            }
            Form(id)? ;
            }

            if (BeginMenu(F"新建..."))
            {
                if (MenuItem(F"目录"))
                    generic::inputbox("新建目录", F"在{current_work_path}新建目录", "NewDir",
                        \dirname: string = je::filesys::mkdir(dirname)
                            ->map(\_:anything = force_update_file_group();)
                            ->or(\reason: string = generic::msgbox("创建目录失败", reason);););

                Separator();
                if (BeginMenu(F"着色器脚本"))
                {
                    // TODO;
                    EndMenu();
                }
                EndMenu();
            }

            EndPopup();
        }
    }
    func file_item_menu(path: PathInfo)
    {
        let NOT_MODIFIABLE_FILES = ["jeproj4"];
        let is_modifiable_file = NOT_MODIFIABLE_FILES->find(path.externname) == -1;

        if (path.externname == "shader")
        {
            if (MenuItem(F"更新此着色器"))
            {
                // 从universe中获取所有world，更新world中所有实体的shader
                je::universe::current()
                    ->editor::worlds_list
                    ->trans(\w: je::world = w
                        ->editor::get_all_entities
                        ->trans(\e: je::entity = 
                            e->editor::graphic::try_reload_shaders(path.path, path.path)
                        ;)
                    ;);
            }
            Separator();
        }
        if (MenuItem("在资源管理器中显示"))
        {
            let command = F"explorer \"{je::filesys::parent(path.path)->replace("/", "\\")}\"";
            je::filesys::open(command);
        }
        Separator();
        if (MenuItem("重命名", is_modifiable_file))
        {
            generic::inputbox("重命名", F"请输入文件{path.path}的新名称", F"{path.name}", 
                \newname: string = je::filesys::move(path.path, je::filesys::parent(path.path) + newname)
                    ->map(\_: anything = force_update_file_group();)
                    ->or(\reason: string = generic::msgbox("重命名失败", reason);););
        }
        if (MenuItem("删除", is_modifiable_file))
        {
            generic::askbox(F"删除文件{path.path}", F"是否继续删除文件{path.path}",
                \=je::filesys::delete(path.path)
                    ->map(\_: anything = force_update_file_group();)
                    ->or(\reason: string = generic::msgbox("删除失败", reason);););
        }
    }

    // 带图标的文件按钮
    func FileIcon(path: PathInfo)=> Action
    {
        BeginGroup();
            PushID(path.path);
                let clicked = ImageButton(get_file_icon_by_extern_name(path)->get_texture, 0.125);
            PopID();
            let right_click = IsItemClicked(ImGuiMouseButton::ImGuiMouseButton_Right);
            context_menu(FileOrForm::File(path));
            if (BeginDragDropSource())
            {
                SetDragDropPayload("JEDITOR_FILE_PATH", path.path);
                    Text(F"File: {path.path}");
                EndDragDropSource();
            }

            SameLine();
            Text(path.name);
        EndGroup();

        static let mut _last_click_time = std::time();

        if(clicked)
        {
            let _current_click_time = std::time();
            if (_current_click_time - _last_click_time < 0.2)
                return Action::DoubleClick;

            _last_click_time = _current_click_time;
            return Action::Click;
        }
        else if (right_click)
            return Action::RightClick;
        
        return Action::Nothing;
    }

    static let mut force_update_file_group_flag = false;
    // 刷新显示的目录信息等...
    func force_update_file_group()
    {
        force_update_file_group_flag = true;
    }

    // 右边的文件详情等信息
    func files_group()
    {
        static let mut new_showing_path = "";
        static let mut now_item_in_path = []: array<PathInfo>;
        if (new_showing_path != current_work_path || force_update_file_group_flag)
        {
            new_showing_path = current_work_path;
            force_update_file_group_flag = false;

            now_item_in_path =
                je::filesys::childs(current_work_path)
                    ->unwarp
                    ->trans(\subpath: string = PathInfo{ 
                        path = subpath,
                        name = je::filesys::filename(subpath),
                        externname = je::filesys::externname(subpath),
                        type = mutable(je::filesys::isdir(subpath)
                            ? PathType::dir(option::none) 
                            | PathType::file),
                    };);
        }

        BeginChild("files_list");
            now_item_in_path
                ->trans(\subpath: PathInfo = 
                    action == Action::Click ? 0
                    | action == Action::DoubleClick ? 
                        subpath
                            ->indir(\_:void = set_current_work_path(subpath.path);)
                            ->infile(\= OpenFile::open(subpath);)   
                    /* | action == Action::RightClick ? je::logfatal("TODO; 打开右键菜单") */
                    | func(){}() // get void
                    where action = FileIcon(subpath);
                );       
        EndChild();
        context_menu(FileOrForm::Form("files_list"));
        // 允许各种乱七八糟的东西拖到这里
        AcceptDrag(["JEEDITOR_WORLD"])
            ->map(\msg: (string, string) = 
                    type == "JEEDITOR_WORLD" 
                    ? Project::GetCurrentProject()
                        ->FindWorld(data: handle: je::world)
                        ->map(\w: Project::World = w->SaveTo(new_showing_path);)
                        ->or(\=launch(generic::MsgBox, ("保存世界失败", "没有在项目中找到此实例对应的信息"));)
                    | std::panic(F"Unhandler drag type: '{type}'.")
                    where (type, data) = msg;);
    }

    // 左侧的目录概况
    func path_tree()
    {
        let root_path = 
            Project::GetCurrentProject().path
                ->valor(std::exepath());

        if (current_work_path == "")
            current_work_path = root_path;

        static let _root = PathInfo {
                path = root_path,
                name = je::filesys::filename(root_path),
                externname = je::filesys::externname(root_path),
                type = mutable(PathType::dir(option::none)),
            };

        // 用于递归展示所有子目录等
        func _show_paths(path: PathInfo)
        {
            match (path.type->get)
            {
            PathType::dir(subpath)?
            {
                let mut attribute = TreeNodeAttribute::ImGuiTreeNodeFlags_OpenOnArrow 
                                + TreeNodeAttribute::ImGuiTreeNodeFlags_OpenOnDoubleClick 
                                + TreeNodeAttribute::ImGuiTreeNodeFlags_SpanAvailWidth;
                if (current_work_path == path.path)
                    attribute += TreeNodeAttribute::ImGuiTreeNodeFlags_Selected;
                        
                let show_child = TreeNodeEx(path.name, attribute);
                if (IsItemClicked() && !IsItemToggledOpen())
                    current_work_path = path.path;

                if (show_child)
                {
                    for (let subpath : path->childs(false))
                        _show_paths(subpath);

                    TreePop();
                }
                else
                    // 如果目录被折叠起来，则删除缓存，等待下次展开时重新获取
                    path.type->set(PathType::dir(option::none));
            }
            PathType::file?
                ; // path_tree只显示目录，跳过文件
            }
        }

        BeginChild("path_tree", 200., 0.);
            _show_paths(_root);
        EndChild();
    }

    public func show(ref open: bool)
    {
        if (!open) return FormAction::Close;

        Begin("资源管理器", WindowsAttribute::ImGuiWindowFlags_None, ref open);
            path_tree();
            SameLine();
            BeginGroup();
                BeginChild("tools_bar", 0., 40.);
                    // TODO 此处放一些返回上一层之类的按钮
                    if (Button("U"))
                        current_work_path = je::filesys::parent(current_work_path);
                    SameLine();
                    Text(current_work_path);
                EndChild();
                files_group();
                
            EndGroup();
        End();

        if (!open)
            return FormAction::Close;
        return FormAction::Nothing;
    }
}

// 这个倒霉文件用于管理项目中使用的C++模块，负责指导模块元数据读取载入编辑等

import woo.std;
import je.filesys;
import je.gui;

import platform;

using je::gui;

using CxxProjectBuildConfig = struct {
    // 配置名称
    config: string,

    // 生成的cmake内容
    cmake: string,

    // 当前配置编译前，CMake需要的命令行参数
    cmake_option: string,

    // 当前配置编译时执行的命令
    built_command: string,
};

public using CxxProject = struct {
    name: string, // 模块的名称
    path: string, // 模块所在路径，仅此而已
    configs: dict<string, CxxProjectBuildConfig>, // 可用的生成配置
    mut module_instance: option<handle>,
}
{
    // Cmake所在路径，项目会使用此路径指示的cmake
    let CMAKE_PATH = F"{je::filesys::env("CMAKE_PATH")}/cmake.exe";
    let MSVC_PATH = F"{je::filesys::env("MSBUILD")}/devenv.exe";

    // C++模块样例，创建项目文件时会复制这个目录
    let CXX_PROJECT_EXAMPLE_PATH = F"{std::exepath()}builtin/cxxproject/";

    // 引擎的头文件路径
    let ENGINE_HEADER_PATH = F"{std::exepath()}builtin/include/";

    // 引擎的库目录
    let ENGINE_CORE_LIBRARYS_LOCATE_PATH = std::exepath();
    let ENGINE_CORE_LIBRARYS_PATHS =
        {
            ["win32_debug_x86"] = [
                F"libwoo32_debug.dll",
                F"libwoo32_debug.lib",
                F"libjoyecs32_debug.dll",
                F"libjoyecs32_debug.lib",
            ],
            ["win32_release_x86"] = [
                F"libwoo32.dll",
                F"libwoo32.lib",
                F"libjoyecs32.dll",
                F"libjoyecs32.lib",
            ],
            ["win32_debug_x64"] = [
                F"libwoo_debug.dll",
                F"libwoo_debug.lib",
                F"libjoyecs_debug.dll",
                F"libjoyecs_debug.lib",
            ],
            ["win32_release_x64"] = [
                F"libwoo.dll",
                F"libwoo.lib",
                F"libjoyecs.dll",
                F"libjoyecs.lib",
            ],
        }: dict<string, array<string>>;

    public func start(name: string, locpath: string)=> result<CxxProject, string>
    {
        using je::file;
        using je::filesys;

        // 在指定目录下创建Cxx项目目录
        let cxx_proj_path = F"{normalize(locpath)}{name}.jemodule4/";
        if (exist(cxx_proj_path))
            return result::err(F"无法创建C++模块项目，{cxx_proj_path}目录已经存在");

        let r = 
            // 0. 把项目所需的预设文件结构复制到指定目录
            copy(CXX_PROJECT_EXAMPLE_PATH, cxx_proj_path)
            // 1. 继续，把引擎的头文件复制过来
            ->bind(\_: anything = copy(ENGINE_HEADER_PATH, F"{cxx_proj_path}engine/include"););

        if (r->iserr)
        {
            delete(cxx_proj_path);
            return r->fail;
        }
        // 2. 开始复制库文件, 顺便确认支持的平台
        alias platform_t = string;
        let platform_support = {}mut : map<platform_t, bool>;
        for (let platform, files : ENGINE_CORE_LIBRARYS_PATHS)
        {
            files
                ->trans(\name: string = copy(F"{ENGINE_CORE_LIBRARYS_LOCATE_PATH}{name}", F"{cxx_proj_path}engine/library/{name}");)
                ->trans(\r: result<anything, anything> = r->isok;)
                ->reduce(\l: bool, r: bool = l ? r | l;)
                ->map(\r: bool = platform_support->set(platform, r););
        }

        let enabled_generating = platform_support
            ->forall(\_: anything, enable: bool = enable;)
            ->unmapping
            ->trans(\conf_enab: (string, anything) = conf_enab[0];);
            
        let generating_results = enabled_generating
            ->trans(\conf: string = (conf, generate_cmake_doc(conf)););

        let failed_generating = generating_results
            ->forall(\r: (anything, result<anything, anything>) = r[1]->iserr;);

        if (!failed_generating->empty)
        {
            for (let r : failed_generating->trans(\r: (anything, result<anything, string>)
                = r[1]->error->val;))
                je::logerr(r);

            delete(cxx_proj_path);
            return result::err(F"创建模块的CMake文件时失败：\n{
                failed_generating
                    ->trans(\r: (anything, result<anything, string>) = r[1]->error->val;)
                    ->reduce(\l: string, r: string = l + "\n" + r;)
                    ->val
            }");
        }

        let created_module = CxxProject{ 
            name = name, 
            path = normalize(cxx_proj_path), 
            configs = generating_results
                ->mapping
                ->trans(\k: string, v: result<CxxProjectBuildConfig, string> 
                    = (k, v->okay->val);),
            module_instance = option::none,
            };

        // 3. 给支持的平台生成CMake文件，并且把配置信息存档
        writeall(F"{cxx_proj_path}config.inf", {
            ["name"] = created_module.name: dynamic,
            ["path"] = created_module.path: dynamic,
            ["conf"] = created_module.configs
                ->unmapping
                ->trans(\conf: (string, anything) = conf[0];): dynamic
        }: string);

        for (let config : generating_results->trans(
            \c: (anything, result<CxxProjectBuildConfig, anything>) = c[1]->okay->val;))
        {
            // 3.1 把生成出来的CMake保存起来
            let aim_cmake_dir = F"{cxx_proj_path}builder/{config.config}";
            if (!exist(aim_cmake_dir))
            {
                // 对应目录不存在，在这里创建一下，失败就寄掉
                let mkdir_result = mkdir(aim_cmake_dir);
                if (mkdir_result->iserr)
                {
                    delete(cxx_proj_path);
                    return mkdir_result->fail;
                }
            }
            if (!writeall(F"{aim_cmake_dir}/CMakeLists.txt", 
                config.cmake
                    ->replace("$$JEMODULE_PROJECT_NAME", name)
                    ->replace("$$JEMODULE_BUILD_CONFIG", config.config)))
            {
                delete(cxx_proj_path);
                return result::err(F"无法写入'{aim_cmake_dir}/CMakeLists.txt'");
            }
        }

        // 4. 生成主CMakeLists
        let cmake_head = 
@"# C++ Module for JoyECS
cmake_minimum_required (VERSION 3.8)

project ("$$JEMODULE_PROJECT_NAME")
set(CMAKE_CXX_STANDARD 17)

if(MSVC) 
    add_compile_options("$<$<CXX_COMPILER_ID:MSVC>:/source-charset:utf-8>")
    add_compile_options("$<$<C_COMPILER_ID:MSVC>:/source-charset:utf-8>")
endif()

set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/build/${JEMODULE_BUILT_AIM}")
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/build/${JEMODULE_BUILT_AIM}")
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/build/${JEMODULE_BUILT_AIM}")
set(LIBRARY_OUTPUT_PATH "${CMAKE_CURRENT_SOURCE_DIR}/build")
"@;
        let cmake_subdirs = enabled_generating
            ->trans(func(conf: string){
                let check_if_need_build = F"if ($\{JEMODULE_BUILT_AIM\} STREQUAL \"{conf}\")";
                let include_subdir = F"    add_subdirectory(\"builder/{conf}\")";
                return F"{check_if_need_build}\n{include_subdir}";
            })
            ->reduce(\l: string, r: string = F"{l}\nelse{r}";)
            ->map(\s: string = F"{s}\nelse()\n    message(FATAL_ERROR \"Unknown built aim.\")\nendif()";);

        if (!cmake_subdirs->has)
        {
            delete(cxx_proj_path);
            std::panic("没有可用的配置，这绝不应该发生");
            return result::err("没有可用的配置，请检查引擎目录相关文件是否丢失");
        }

        if (!writeall(F"{cxx_proj_path}CMakeLists.txt", 
                F"{cmake_head}\n{cmake_subdirs->val}\n"
                    ->replace("$$JEMODULE_PROJECT_NAME", name)))
        {
            delete(cxx_proj_path);
            return result::err(F"无法写入'{cxx_proj_path}CMakeLists.txt'");
        }

        // 最后，编译一下当前平台
        created_module->update_compile(je::editor::platform());

        return result::ok(created_module);
    }

    func search_dll_in(dir: string)=> option<string>
    {
        using je::filesys;

        for (let p : childs(dir)->okay->val)
        {
            if (isdir(p))
            {
                let r = search_dll_in(p);
                if (r->has)
                    return r;
            }
            else if (externname(p) == "dll")
                return option::value(p);
        }
        return option::none;
    }
    func load_library_of_platform(self: CxxProject, platform: string)
    {
        assert(!self.module_instance->has);
        match (search_dll_in(F"{self.path}runtime/{platform}"))
        {
        value(p)? 
            return self.module_instance = je::editor::load_module(self.name, p);
        none? 
            return self.module_instance = option::none;
        }
    }
    func update_library_of_platform(self: CxxProject, config: string)
    {
        using je::filesys;

        // 获取编译出来的二进制，移动到一个统一的位置
        if (!exist(F"{self.path}runtime/{config}"))
            mkdir(F"{self.path}runtime/{config}");

        assert(exist(F"{self.path}runtime/{config}"));

        match (search_dll_in(F"{self.path}build/{config}"))
        {
        value(p)? 
        {
            delete(F"{self.path}runtime/{config}/{filename(p)}");
            assert(copy(p, F"{self.path}runtime/{config}/{filename(p)}")->isok);
        }
        none? std::panic("Output binary file not found;");
        }

    }
    public func load(path: string)
    {
        using je::filesys;
        using je::file;

        // 加载指定路径的 CXX 项目信息
        if (!exist(path))
            return result::err(F"找不到模块{path}，请检查文件是否丢失");
        if (!exist(F"{normalize(path)}config.inf"))
            return result::err(F"找不到配置文件{normalize(path)}config.inf，请检查文件是否丢失");

        let readdat = readall(F"{normalize(path)}config.inf")
            ->bind(\d: string = d->todict;);
        if (!readdat->has)
            return result::err(F"模块{path}的配置文件无法读取或格式不正确");

        let created_module = CxxProject{ 
            name = readdat->val["name": dynamic] as string, 
            path = normalize(readdat->val["path": dynamic] as string), 
            configs = readdat
                ->val["conf": dynamic] as array
                ->trans(\d: dynamic = d as string;)
                // 如果文件打不开，直接在这里爆炸
                ->trans(\conf: string = (conf, generate_cmake_doc(conf)->okay->val);)
                ->mapping,
            module_instance = option::none,
            };
        
        let current_je_proj = editor::Project::GetCurrentProject();
        current_je_proj.native_modules->get(created_module.path)
                    ->or(\ = current_je_proj.native_modules->set(created_module.path, created_module););

        if (!created_module->load_library_of_platform(je::editor::platform())->has)
            return result::err(F"无法为当前运行时{je::editor::platform()}加载模块，请检查");

        return result::ok(created_module);
    }

    func generate_cmake_doc(conf: string)=> result<CxxProjectBuildConfig, string>
    {
        let win32_cmake = @"
# Build config for $$JEMODULE_PROJECT_NAME
cmake_minimum_required (VERSION 3.8)

include_directories("../../engine/include")
include_directories("../../systems")
include_directories("../../components")

find_library(joyengine_lib $$JE_ENGINE_LIB ../../engine/library)
find_library(woolang_lib $$JE_WOOLANG_LIB ../../engine/library)

file(GLOB_RECURSE module_systems_sources ../../systems/*.cpp)
file(GLOB_RECURSE module_systems_headers ../../systems/*.hpp)
file(GLOB_RECURSE module_components_headers ../../components/*.hpp)        

add_library($$JEMODULE_PROJECT_NAME SHARED 
    ${module_systems_sources}
    ${module_systems_headers}
    ${module_components_headers}
    ../../main.cpp
    ../../loader.hpp)

set_target_properties($$JEMODULE_PROJECT_NAME PROPERTIES OUTPUT_NAME lib$$JEMODULE_PROJECT_NAME)
set_target_properties($$JEMODULE_PROJECT_NAME PROPERTIES PREFIX "")

set_target_properties($$JEMODULE_PROJECT_NAME PROPERTIES RELEASE_POSTFIX "$$JE_POSTFIX")
set_target_properties($$JEMODULE_PROJECT_NAME PROPERTIES DEBUG_POSTFIX "$$JE_POSTFIX")

target_link_libraries($$JEMODULE_PROJECT_NAME ${joyengine_lib} ${woolang_lib})
        "@;
        
        // 根据给定的配置和项目路径等信息，生成CMake文档
        let static config_cmake_file = {
            ["win32_debug_x86"] = CxxProjectBuildConfig{ 
                config = "win32_debug_x86",
                cmake = win32_cmake
                    ->replace("$$JE_ENGINE_LIB",  "libjoyecs32_debug")
                    ->replace("$$JE_WOOLANG_LIB", "libwoo32_debug")
                    ->replace("$$JE_POSTFIX", "32_debug"),
                cmake_option = "-G \"Visual Studio 16 2019\" -A x86 -DCMAKE_BUILD_TYPE=DEBUG",
                built_command = "/Build Debug",
            },
            ["win32_release_x86"] = CxxProjectBuildConfig{ 
                config = "win32_release_x86",
                cmake = win32_cmake
                    ->replace("$$JE_ENGINE_LIB",  "libjoyecs32")
                    ->replace("$$JE_WOOLANG_LIB", "libwoo32")
                    ->replace("$$JE_POSTFIX", "32"),
                cmake_option = "-G \"Visual Studio 16 2019\" -A x86 -DCMAKE_BUILD_TYPE=RELEASE",
                built_command = "/Build Release",
            },
            ["win32_debug_x64"] = CxxProjectBuildConfig{ 
                config = "win32_debug_x64",
                cmake = win32_cmake
                    ->replace("$$JE_ENGINE_LIB",  "libjoyecs_debug")
                    ->replace("$$JE_WOOLANG_LIB", "libwoo_debug")
                    ->replace("$$JE_POSTFIX", "_debug"),
                cmake_option = "-G \"Visual Studio 16 2019\" -A x64 -DCMAKE_BUILD_TYPE=DEBUG",
                built_command = "/Build Debug",
            },
            ["win32_release_x64"] = CxxProjectBuildConfig{ 
                config = "win32_release_x64",
                cmake = win32_cmake
                    ->replace("$$JE_ENGINE_LIB",  "libjoyecs")
                    ->replace("$$JE_WOOLANG_LIB", "libwoo")
                    ->replace("$$JE_POSTFIX", ""),
                cmake_option = "-G \"Visual Studio 16 2019\" -A x64 -DCMAKE_BUILD_TYPE=RELEASE",
                built_command = "/Build Release",
            } 
        };

        return
            config_cmake_file->get(conf)
                ->map(\c: CxxProjectBuildConfig = result::ok(c): result<typeof(c), string>;)
                ->valor(result::err(F"未知的配置{conf}"));
    }

    func fuck_windows_cmd(path: string)
    {
        if (path->find(" ") != -1 || path->find("\t") != -1)
            return F"\"{path}\"";
        return path;
    }

    using compile_context = struct {
        mut display_msg : string,
        mut progress    : int,
        mut show        : bool,
        mut compile_thread  : option<std::thread>,
        mut compile_result  : option<result<result<string, string>, string>>,
    };
    func update_compile(self: CxxProject, config: string)
    {
        // 起个线程跑编译，然后弄个窗口显示一下进度

        let context = compile_context{
            display_msg = "正在开始编译，请稍等……", 
            progress = 0, 
            show = true,
            compile_thread = option::none,
            compile_result = option::none,
            };
        je::gui::launch(func(){
            Begin(F"编译C++模块##{JobID()}", WindowsAttribute::ImGuiWindowFlags_AlwaysAutoResize, ref context.show);
                Text(F"正在编译C++模块：{self.name}");
                Text(context.display_msg);
                ProgressBar(context.progress: real / 100.);
            End();
            if (context.show)
                return FormAction::Nothing;
            return FormAction::Close;
        }, ());

        context.compile_thread = 
            option::value(std::thread(func ()
            {
                match (self->_compile(config, context))
                {
                ok(compile_result)?
                    match(compile_result)
                    {
                    ok(_)?
                    {
                        // 起个协程同步去更新一下
                        je::gui::launch(
                            func(){
                                let proj = editor::Project::GetCurrentProject();
                                let dump_worlds = proj->DumpAllWorlds();

                                proj->CloseAllWorlds();

                                self.module_instance = 
                                    self.module_instance
                                        ->map(\m: handle = je::editor::unload_module(m);)
                                        ->bind(\_: anything = option::none;);

                                // 编译成功，更新文件到runtime
                                self->update_library_of_platform(config);

                                // 加载模块！
                                assert(self->load_library_of_platform(config)->has);

                                proj->RestoreAllWorlds(dump_worlds);

                                return FormAction::Close;
                            },() );
                        
                    }
                    err(_)?;
                    }
                err(_)?;
                }
            }));
    }
    func _compile(self: CxxProject, config: string, context: compile_context)
    {
        // 输入所需的配置，如果项目支持这个配置，则编译模块
        let current_je_proj = editor::Project::GetCurrentProject();

        let conf = self.configs->get(config);
        if (!conf->has)
        {
            context.show = false;
            return result::err("不支持的配置");
        }

        using je::file;
        using je::filesys;

        context.display_msg = "正在检查工具链";
        context.progress = 0;

        if (!exist(CMAKE_PATH))
        {
            context.display_msg = F"无法找到{CMAKE_PATH}，请检查CMake配置和环境变量";
            return result::err(context.display_msg);
        }
        if (!exist(MSVC_PATH))
        {
            context.display_msg = F"无法找到{MSVC_PATH}，请检查工具链环境变量";
            return result::err(context.display_msg);
        }

        assert(self.path->endwith("/"));

        context.display_msg = "正在扫描并生成loader.hpp";
        context.progress = 5;

        let components = childs(F"{self.path}components")
            ->okay
            ->map(\childs: array<string> = childs
                 ->forall(\f: string = externname(f) == "hpp";)
                 ->trans(\f: string = filename(f);)
                 ->trans(\f: string = f->sub(0, f->len - 4);)
                ;)
            ->valor([]);
           
        let systems = childs(F"{self.path}systems")
            ->okay
            ->map(\childs: array<string> = childs
                 ->forall(\f: string = externname(f) == "hpp";)
                 ->trans(\f: string = filename(f);)
                 ->trans(\f: string = f->sub(0, f->len - 4);)
                ;)
            ->valor([]);

        let loader_header = 
@"#pragma once

// Do not modify this file
// 'loader.hpp' will be generated by editor.

// Headers of components/systems
// E.G. #include "ExampleComponent.hpp"
$$INCLUDE_COMPONENT_HEADERS
$$INCLUDE_SYSTEM_HEADERS

namespace jemodule
{
    void register_types()
    {
        // Here to load components/system
        // e.g. jeecs::typing::type_info::of<Module::ExampleComponent>("Module::ExampleComponent");
$$REGISTER_COMPONENT_TYPES
$$REGISTER_SYSTEM_TYPES
    }
}
        "@;
        let import_component_headers = 
            components
                ->trans(\f: string = F"#include \"{f}.hpp\"";)
                ->reduce(\l: string, r: string = l + "\n" + r;)
                ->valor("");
        let import_system_headers = 
            systems
                ->trans(\f: string = F"#include \"{f}.hpp\"";)
                ->reduce(\l: string, r: string = l + "\n" + r;)
                ->valor("");

        let register_component_types =
            components
                ->trans(\f: string = F"jeecs::typing::type_info::of<{self.name}::{f}>(\"{self.name}::{f}\");";)
                ->trans(\f: string = "        " + f;)
                ->reduce(\l: string, r: string = l + "\n" + r;)
                ->valor("");
        let register_system_types = 
            systems
                ->trans(\f: string = F"jeecs::typing::type_info::of<{self.name}::{f}>(\"{self.name}::{f}\");";)
                ->trans(\f: string = "        " + f;)
                ->reduce(\l: string, r: string = l + "\n" + r;)
                ->valor("");

        let loader_src = 
            loader_header
                ->replace("$$INCLUDE_COMPONENT_HEADERS", import_component_headers)
                ->replace("$$INCLUDE_SYSTEM_HEADERS", import_system_headers)
                ->replace("$$REGISTER_COMPONENT_TYPES", register_component_types)
                ->replace("$$REGISTER_SYSTEM_TYPES", register_system_types);

        if (!writeall(F"{self.path}loader.hpp", loader_src))
        {
            context.display_msg = F"无法写入'{self.path}loader.txt'";
            return result::err(context.display_msg);
        }

        let cmake_command = F"{fuck_windows_cmd(CMAKE_PATH)} \"{fuck_windows_cmd(self.path)}\" -B \"{fuck_windows_cmd(self.path + "msvcbuild")}\" {conf->val.cmake_option} -DJEMODULE_BUILT_AIM=\"{config}\"";
        
        context.display_msg = F"正在使用CMake生成编译配置\n{cmake_command}";
        context.progress = 15;

        if (open(cmake_command) != 0)
        {
            context.display_msg = "CMake生成失败";
            return result::err(context.display_msg);
        }

        let msvc_proj_path = fuck_windows_cmd(F"{self.path}msvcbuild/builder/{config}/{self.name}.vcxproj");
        let msvc_compile_result_path = F"{self.path}msvcbuild/compile.log";

        delete(msvc_compile_result_path);

        let build_command = F"{fuck_windows_cmd(MSVC_PATH)} {msvc_proj_path} {conf->val.built_command} /out {fuck_windows_cmd(msvc_compile_result_path)} && echo Finished";

        context.display_msg = F"正在构建二进制文件\n{build_command}";
        context.progress = 45;

        if (open(build_command) != 0)
        {
            context.display_msg = "C++编译失败";
            return result::err(context.display_msg);
        }

        while(true)
        {
            std::sleep(1.);

            let compile_result = readall(msvc_compile_result_path);
            if (!compile_result->has)
                continue;

            context.progress = 100;

            if (compile_result->val->find("error") == -1)
            {
                current_je_proj.native_modules->get(self.path)
                    ->or(\ = current_je_proj.native_modules->set(self.path, self););

                context.display_msg = F"编译完成\n{compile_result->val}";
                return result::ok(result::ok(context.display_msg));
            }
            context.display_msg = F"编译失败\n{compile_result->val}";
            return result::ok(result::err(context.display_msg));
        }
        std::panic("Should not be here.");
    }

}
// 这个倒霉文件用于管理项目中使用的C++模块，负责指导模块元数据读取载入编辑等

import woo.std;
import je.filesys;
import je.gui;

import platform;

using je::gui;

using CxxProjectBuildConfig = struct {
    // 配置名称
    config: string,

    // 生成的cmake内容
    cmake: string,

    // 当前配置编译前，CMake需要的命令行参数
    cmake_option: string,

    // 当前配置编译时执行的命令
    built_command: string,
};

using CxxProject = struct {
    name: string, // 模块的名称
    path: string, // 模块所在路径，仅此而已
    configs: dict<string, CxxProjectBuildConfig> // 可用的生成配置
}
{
    // Cmake所在路径，项目会使用此路径指示的cmake
    let CMAKE_PATH = F"{je::filesys::env("CMAKE_PATH")}/cmake.exe";
    let MSVC_PATH = F"{je::filesys::env("MSBUILD")}/devenv.exe";

    // C++模块样例，创建项目文件时会复制这个目录
    let CXX_PROJECT_EXAMPLE_PATH = F"{std::exepath()}builtin/cxxproject/";

    // 引擎的头文件路径
    let ENGINE_HEADER_PATH = F"{std::exepath()}builtin/include/";

    // 引擎的库目录
    let ENGINE_CORE_LIBRARYS_LOCATE_PATH = std::exepath();
    let ENGINE_CORE_LIBRARYS_PATHS =
        {
            ["win32_debug_x86"] = [
                F"libwoo32_debug.dll",
                F"libwoo32_debug.lib",
                F"libjoyecs32_debug.dll",
                F"libjoyecs32_debug.lib",
            ],
            ["win32_release_x86"] = [
                F"libwoo32.dll",
                F"libwoo32.lib",
                F"libjoyecs32.dll",
                F"libjoyecs32.lib",
            ],
            ["win32_debug_x64"] = [
                F"libwoo_debug.dll",
                F"libwoo_debug.lib",
                F"libjoyecs_debug.dll",
                F"libjoyecs_debug.lib",
            ],
            ["win32_release_x64"] = [
                F"libwoo.dll",
                F"libwoo.lib",
                F"libjoyecs.dll",
                F"libjoyecs.lib",
            ],
        }: dict<string, array<string>>;

    // 测试一下，别无它用
    public func display_cmake_info()
    {
        je::filesys::open(F"{CMAKE_PATH} --version");
    }

    public func start(name: string, locpath: string)=> result<CxxProject, string>
    {
        using je::file;
        using je::filesys;

        // 在指定目录下创建Cxx项目目录
        let cxx_proj_path = F"{normalize(locpath)}{name}.jemodule4/";
        if (exist(cxx_proj_path))
            return result::err(F"无法创建C++模块项目，{cxx_proj_path}目录已经存在");

        let r = 
            // 0. 把项目所需的预设文件结构复制到指定目录
            copy(CXX_PROJECT_EXAMPLE_PATH, cxx_proj_path)
            // 1. 继续，把引擎的头文件复制过来
            ->bind(\_: anything = copy(ENGINE_HEADER_PATH, F"{cxx_proj_path}engine/include"););

        if (r->iserr)
        {
            delete(cxx_proj_path);
            return r->fail;
        }
        // 2. 开始复制库文件, 顺便确认支持的平台
        alias platform_t = string;
        let platform_support = {}mut : map<platform_t, bool>;
        for (let platform, files : ENGINE_CORE_LIBRARYS_PATHS)
        {
            files
                ->trans(\name: string = copy(F"{ENGINE_CORE_LIBRARYS_LOCATE_PATH}{name}", F"{cxx_proj_path}engine/library/{name}");)
                ->trans(\r: result<anything, anything> = r->isok;)
                ->reduce(\l: bool, r: bool = l ? r | l;)
                ->map(\r: bool = platform_support->set(platform, r););
        }

        let enabled_generating = platform_support
            ->forall(\_: anything, enable: bool = enable;)
            ->unmapping
            ->trans(\conf_enab: (string, anything) = conf_enab[0];);
            
        let generating_results = enabled_generating
            ->trans(\conf: string = (conf, generate_cmake_doc(conf)););

        let failed_generating = generating_results
            ->forall(\r: (anything, result<anything, anything>) = r[1]->iserr;);

        if (!failed_generating->empty)
        {
            for (let r : failed_generating->trans(\r: (anything, result<anything, string>)
                = r[1]->error->val;))
                je::logerr(r);

            delete(cxx_proj_path);
            return result::err(F"创建模块的CMake文件时失败：\n{
                failed_generating
                    ->trans(\r: (anything, result<anything, string>) = r[1]->error->val;)
                    ->reduce(\l: string, r: string = l + "\n" + r;)
                    ->val
            }");
        }

        let created_module = CxxProject{ 
            name = name, 
            path = normalize(cxx_proj_path), 
            configs = generating_results
                ->mapping
                ->trans(\k: string, v: result<CxxProjectBuildConfig, string> 
                    = (k, v->okay->val);),
            };

        // 3. 给支持的平台生成CMake文件，并且把配置信息存档
        writeall(F"{cxx_proj_path}config.inf", {
            ["name"] = created_module.name: dynamic,
            ["path"] = created_module.path: dynamic,
            ["conf"] = created_module.configs
                ->unmapping
                ->trans(\conf: (string, anything) = conf[0];): dynamic
        }: string);

        for (let config : generating_results->trans(
            \c: (anything, result<CxxProjectBuildConfig, anything>) = c[1]->okay->val;))
        {
            // 3.1 把生成出来的CMake保存起来
            let aim_cmake_dir = F"{cxx_proj_path}builder/{config.config}";
            if (!exist(aim_cmake_dir))
            {
                // 对应目录不存在，在这里创建一下，失败就寄掉
                let mkdir_result = mkdir(aim_cmake_dir);
                if (mkdir_result->iserr)
                {
                    delete(cxx_proj_path);
                    return mkdir_result->fail;
                }
            }
            if (!writeall(F"{aim_cmake_dir}/CMakeLists.txt", 
                config.cmake
                    ->replace("$$JEMODULE_PROJECT_NAME", name)
                    ->replace("$$JEMODULE_BUILD_CONFIG", config.config)))
            {
                delete(cxx_proj_path);
                return result::err(F"无法写入'{aim_cmake_dir}/CMakeLists.txt'");
            }
        }

        // 4. 生成主CMakeLists
        let cmake_head = 
@"# C++ Module for JoyECS
cmake_minimum_required (VERSION 3.8)

project ("$$JEMODULE_PROJECT_NAME")
set(CMAKE_CXX_STANDARD 17)

if(MSVC) 
    add_compile_options("$<$<CXX_COMPILER_ID:MSVC>:/source-charset:utf-8>")
    add_compile_options("$<$<C_COMPILER_ID:MSVC>:/source-charset:utf-8>")
endif()

set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/build/${JEMODULE_BUILT_AIM}")
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/build/${JEMODULE_BUILT_AIM}")
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/build/${JEMODULE_BUILT_AIM}")
set(LIBRARY_OUTPUT_PATH "${CMAKE_CURRENT_SOURCE_DIR}/build")
"@;
        let cmake_subdirs = enabled_generating
            ->trans(func(conf: string){
                let check_if_need_build = F"if ($\{JEMODULE_BUILT_AIM\} STREQUAL \"{conf}\")";
                let include_subdir = F"    add_subdirectory(\"builder/{conf}\")";
                return F"{check_if_need_build}\n{include_subdir}";
            })
            ->reduce(\l: string, r: string = F"{l}\nelse{r}";)
            ->map(\s: string = F"{s}\nelse()\n    message(FATAL_ERROR \"Unknown built aim.\")\nendif()";);

        if (!cmake_subdirs->has)
        {
            delete(cxx_proj_path);
            std::panic("没有可用的配置，这绝不应该发生");
            return result::err("没有可用的配置，请检查引擎目录相关文件是否丢失");
        }

        if (!writeall(F"{cxx_proj_path}CMakeLists.txt", 
                F"{cmake_head}\n{cmake_subdirs->val}\n"
                    ->replace("$$JEMODULE_PROJECT_NAME", name)))
        {
            delete(cxx_proj_path);
            return result::err(F"无法写入'{cxx_proj_path}CMakeLists.txt'");
        }

        // 最后，编译一下当前平台
        created_module->update_compile(je::editor::platform());

        return result::ok(created_module);
    }
    public func load(path: string)
    {
        // 加载指定路径的 CXX 项目信息
    }

    func generate_cmake_doc(conf: string)=> result<CxxProjectBuildConfig, string>
    {
        let win32_cmake = @"
# Build config for $$JEMODULE_PROJECT_NAME
cmake_minimum_required (VERSION 3.8)

include_directories("../../engine/include")
find_library(joyengine_lib $$JE_ENGINE_LIB ../../engine/library)
find_library(woolang_lib $$JE_WOOLANG_LIB ../../engine/library)

file(GLOB_RECURSE module_sources systems/*.cpp)
file(GLOB_RECURSE module_headers components/*.hpp)        

add_library($$JEMODULE_PROJECT_NAME SHARED ${module_sources} ${module_headers} ../../main.cpp)
set_target_properties($$JEMODULE_PROJECT_NAME PROPERTIES OUTPUT_NAME lib$$JEMODULE_PROJECT_NAME)
set_target_properties($$JEMODULE_PROJECT_NAME PROPERTIES PREFIX "")

set_target_properties($$JEMODULE_PROJECT_NAME PROPERTIES RELEASE_POSTFIX "$$JE_POSTFIX")
set_target_properties($$JEMODULE_PROJECT_NAME PROPERTIES DEBUG_POSTFIX "$$JE_POSTFIX")

target_link_libraries($$JEMODULE_PROJECT_NAME ${joyengine_lib} ${woolang_lib})
        "@;
        
        // 根据给定的配置和项目路径等信息，生成CMake文档
        let static config_cmake_file = {
            ["win32_debug_x86"] = CxxProjectBuildConfig{ 
                config = "win32_debug_x86",
                cmake = win32_cmake
                    ->replace("$$JE_ENGINE_LIB",  "libjoyecs32_debug")
                    ->replace("$$JE_WOOLANG_LIB", "libwoo32_debug")
                    ->replace("$$JE_POSTFIX", "32_debug"),
                cmake_option = "-G \"Visual Studio 16 2019\" -A x86 -DCMAKE_BUILD_TYPE=DEBUG",
                built_command = "/Build Debug",
            },
            ["win32_release_x86"] = CxxProjectBuildConfig{ 
                config = "win32_release_x86",
                cmake = win32_cmake
                    ->replace("$$JE_ENGINE_LIB",  "libjoyecs32")
                    ->replace("$$JE_WOOLANG_LIB", "libwoo32")
                    ->replace("$$JE_POSTFIX", "32"),
                cmake_option = "-G \"Visual Studio 16 2019\" -A x86 -DCMAKE_BUILD_TYPE=RELEASE",
                built_command = "/Build Release",
            },
            ["win32_debug_x64"] = CxxProjectBuildConfig{ 
                config = "win32_debug_x64",
                cmake = win32_cmake
                    ->replace("$$JE_ENGINE_LIB",  "libjoyecs_debug")
                    ->replace("$$JE_WOOLANG_LIB", "libwoo_debug")
                    ->replace("$$JE_POSTFIX", "_debug"),
                cmake_option = "-G \"Visual Studio 16 2019\" -A x64 -DCMAKE_BUILD_TYPE=DEBUG",
                built_command = "/Build Debug",
            },
            ["win32_release_x64"] = CxxProjectBuildConfig{ 
                config = "win32_release_x64",
                cmake = win32_cmake
                    ->replace("$$JE_ENGINE_LIB",  "libjoyecs")
                    ->replace("$$JE_WOOLANG_LIB", "libwoo")
                    ->replace("$$JE_POSTFIX", ""),
                cmake_option = "-G \"Visual Studio 16 2019\" -A x64 -DCMAKE_BUILD_TYPE=RELEASE",
                built_command = "/Build Release",
            } 
        };

        return
            config_cmake_file->get(conf)
                ->map(\c: CxxProjectBuildConfig = result::ok(c): result<typeof(c), string>;)
                ->valor(result::err(F"未知的配置{conf}"));
    }

    func fuck_windows_cmd(path: string)
    {
        if (path->find(" ") != -1 || path->find("\t") != -1)
            return F"\"{path}\"";
        return path;
    }

    using compile_context = struct {
        mut display_msg : string,
        mut progress    : int,
        mut show        : bool,
    };
    func update_compile(self: CxxProject, config: string)
    {
        // 起个线程跑编译，然后弄个窗口显示一下进度

        let context = compile_context{display_msg = "正在开始编译，请稍等……", progress = 0, show = true};
        je::gui::launch(func(){
            Begin(F"编译C++模块##{JobID()}", WindowsAttribute::ImGuiWindowFlags_AlwaysAutoResize, ref context.show);
                Text(F"正在编译C++模块：{self.name}");
                Text(context.display_msg);
                Text(F"进度：{context.progress}%");
            End();
            if (context.show)
                return FormAction::Nothing;
            return FormAction::Close;
        }, ());
        std::thread(_update_compile, (self, config, context));
    }
    func _update_compile(self: CxxProject, config: string, context: compile_context)
    {
        // 输入所需的配置，如果项目支持这个配置，则编译模块

        let conf = self.configs->get(config);
        if (!conf->has)
        {
            context.show = false;
            return result::err("不支持的配置");
        }

        using je::file;
        using je::filesys;

        context.display_msg = "正在检查工具链";
        context.progress = 5;

        if (!exist(CMAKE_PATH))
        {
            context.display_msg = F"无法找到{CMAKE_PATH}，请检查CMake配置和环境变量";
            delete(self.path);
            return result::err(context.display_msg);
        }
        if (!exist(MSVC_PATH))
        {
            context.display_msg = F"无法找到{MSVC_PATH}，请检查工具链环境变量";
            delete(self.path);
            return result::err(context.display_msg);
        }

        assert(self.path->endwith("/"));

        let cmake_command = F"{fuck_windows_cmd(CMAKE_PATH)} \"{fuck_windows_cmd(self.path)}\" -B \"{fuck_windows_cmd(self.path + "msvcbuild")}\" {conf->val.cmake_option} -DJEMODULE_BUILT_AIM=\"{config}\"";
        
        context.display_msg = F"正在使用CMake生成编译配置\n{cmake_command}";
        context.progress = 15;

        if (open(cmake_command) != 0)
        {
            context.display_msg = "CMake生成失败";
            delete(self.path);
            return result::err(context.display_msg);
        }

        let msvc_proj_path = fuck_windows_cmd(F"{self.path}msvcbuild/builder/{config}/{self.name}.vcxproj");
        let msvc_compile_result_path = F"{self.path}msvcbuild/compile.log";

        delete(msvc_compile_result_path);

        let build_command = F"{fuck_windows_cmd(MSVC_PATH)} {msvc_proj_path} {conf->val.built_command} /out {fuck_windows_cmd(msvc_compile_result_path)} && echo Finished";

        context.display_msg = F"正在构建二进制文件\n{build_command}";
        context.progress = 45;

        if (open(build_command) != 0)
        {
            context.display_msg = "C++编译失败";
            delete(self.path);
            return result::err(context.display_msg);
        }

        while(true)
        {
            std::sleep(1.);

            let compile_result = readall(msvc_compile_result_path);
            if (!compile_result->has)
                continue;

            context.progress = 100;

            if (compile_result->val->find("error") == -1)
            {
                // 获取编译出来的二进制，移动到一个统一的位置
                if (!exist(F"{self.path}runtime/{config}"))
                    mkdir(F"{self.path}runtime/{config}");

                assert(exist(F"{self.path}runtime/{config}"));

                func search_dll_in(dir: string)=> option<string>
                {
                    for (let p : childs(dir)->okay->val)
                    {
                        if (isdir(p))
                        {
                            let r = search_dll_in(p);
                            if (r->has)
                                return r;
                        }
                        else if (externname(p) == "dll")
                            return option::value(p);
                    }
                    return option::none;
                }

                // TODO; 在这个地方保存编辑环境，然后卸载模块，变更二进制，然后恢复上下文

                match (search_dll_in(F"{self.path}build/{config}"))
                {
                value(p)? assert(copy(p, F"{self.path}runtime/{config}/{filename(p)}")->isok);
                none? std::panic("Binary file not found;");
                }

                context.display_msg = F"编译完成\n{compile_result->val}";
                return result::ok(result::ok(context.display_msg));
            }
            context.display_msg = F"编译失败\n{compile_result->val}";
            return result::ok(result::err(context.display_msg));
        }
        std::panic("Should not be here.");
    }

}